<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
<!-- 2023-07-17 Mon 10:33 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Circuits logiques combinatoires et séquentiels</title>
<meta name="author" content="Guy Bégin" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Circuits logiques combinatoires et séquentiels</h1>

<div id="outline-container-orgc0a0e35" class="outline-2">
<h2 id="orgc0a0e35">Avant-propos</h2>
<div class="outline-text-2" id="text-orgc0a0e35">
<p>
Ce manuel a été rédigé en fonction de deux objectifs distincts mais
reliés. Le premier objectif était de produire un manuel de qualité, en
français, sur un sujet fondamental en électronique numérique et d'en
faire une <i>Ressource Éducative Libre (REL)</i>. Une recherche préalable
nous avait en effet permis de constater qu'il existe peu de manuels
récents de ce type sur le sujet. En offrant une telle ressource à la
communauté, nous espérons contribuer à rendre plus accessible la
formation dans ce domaine technologique important.
</p>

<p>
Le deuxième objectif était d'expérimenter avec une méthode de
travail permettant d'élaborer de telles ressources éducatives en
faisant appel à un ensemble d'outils libres et accessibles à tous. Le
but était aussi de s'assurer de pouvoir obtenir un ou un ensemble de
documents sources susceptibles d'en faciliter la réutilisation, la
révision et le remixage. Le manuel est donc appelé à devenir une
preuve de concept pour le processus d'élaboration qui a été utilisé.
</p>

<p>
La matière couverte dans ce manuel correspond d'assez près au contenu
du cours <a href="https://etudier.uqam.ca/cours?sigle=MIC1065">MIC1065 Circuits logiques</a>, offert dans le cadre du
<a href="https://etudier.uqam.ca/programme?code=6526">baccalauréat en systèmes informatiques et électroniques</a> de
l'<a href="https://uqam.ca/">Université du Québec à Montréal</a>. 
</p>

<p>
L'auteur, Guy Bégin, est professeur au département d'informatique de
l'Université du Québec à Montréal. Ses recherches l'ont toujours amené
à s'intéresser aux 0 et aux 1 si souvent rencontrés en circuits
logiques, mais également en télécommunications numériques, son champ
de recherche privilégié.
</p>
</div>

<div id="outline-container-org6017347" class="outline-3">
<h3 id="org6017347">Remerciements</h3>
<div class="outline-text-3" id="text-org6017347">
<p>
Ce manuel a été réalisé avec le soutien de &#x2026;
</p>

<p>
Les logiciels libres suivants ont été utilisés à différentes étapes,
pour la rédaction et la préparation des modèles, des images et pour la
simulation:
</p>

<ul class="org-ul">
<li>Rédaction et production
<ul class="org-ul">
<li><a href="https://www.gnu.org/software/emacs/">Emacs</a></li>
<li><a href="https://www.latex-project.org/">LaTeX</a></li>
<li><a href="https://git-scm.com">Git</a></li>
<li><a href="https://pandoc.org/">Pandoc</a></li>
</ul></li>
<li>Schémas
<ul class="org-ul">
<li><a href="https://graphviz.org/">Graphviz</a></li>
<li><a href="https://inkscape.org">Inkscape</a></li>
<li><a href="https://wavedrom.com/">Wavedrom</a></li>
<li><a href="https://schemdraw.readthedocs.io/en/latest/">Schemdraw</a></li>
<li><a href="https://ditaa.sourceforge.net/">Ditaa</a></li>
</ul></li>
<li>Simulation logique
<ul class="org-ul">
<li><a href="https://github.com/hneemann/Digital">Simulateur Digital</a></li>
</ul></li>
<li>Coloration syntaxique
<ul class="org-ul">
<li><a href="https://pygments.org/docs/quickstart/">Pygments</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org9b3bc07" class="outline-3">
<h3 id="org9b3bc07">Licence</h3>
<div class="outline-text-3" id="text-org9b3bc07">

<div id="org594e88c" class="figure">
<p><img src="by-sa.svg" alt="by-sa.svg" class="org-svg" />
</p>
</div>

<p>
Sauf indications contraires, le contenu de ce manuel électronique est
disponible en vertu des conditions de la
<a href="https://creativecommons.org/licenses/by/4.0/deed.fr">Licence
Creative Commons Attribution - Partage dans les mêmes conditions 4.0
International</a>.
</p>

<p>
Vous êtes autorisé à : 
</p>

<dl class="org-dl">
<dt>Partager</dt><dd>– Copier, distribuer et communiquer le matériel par tous
moyens et sous tous formats.</dd>
<dt>Adapter</dt><dd>– Remixer, transformer et créer à partir du matériel pour
toute utilisation, y compris commerciale.</dd>
</dl>

<p>
Selon les conditions suivantes :
</p>

<dl class="org-dl">
<dt>Paternité</dt><dd>– Vous devez citer le nom de l’auteur original.</dd>
<dt>Mêmes conditions</dt><dd>– Si vous remixez, transformez, ou créez à
partir du matériel composant l'Oeuvre originale, vous devez diffuser
l'Oeuvre modifiée avec la même licence.</dd>
</dl>


<p>
Pour citer cet ouvrage: Bégin, G. (2022), Circuits logiques
combinatoires et séquentiels. Université du Québec à Montréal. Licence CC BY-SA
</p>


<div id="orgefdf3ef" class="figure">
<p><img src="Logo_UQAM.svg" alt="Logo_UQAM.svg" class="org-svg" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org5f7149b" class="outline-2">
<h2 id="org5f7149b">Préface</h2>
<div class="outline-text-2" id="text-org5f7149b">
<p>
Ce manuel est une introduction au domaine de la conception des circuits
logiques, qui sont à la base de tous les systèmes numériques
modernes. Il s'adresse tout particulièrement aux étudiants qui suivent
un enseignement technique, ou un premier cycle universitaire, ainsi
qu'à tous ceux qui s'intéressent à l'ingénierie électronique.  Le
lecteur n'a besoin d'aucune connaissance préalable pour pouvoir en
assimiler les concepts, mais une connaissance de la programmation
permettra de pousser l'expérimentation par simulation.
</p>

<p>
Les chapitres 1 à 3 de cet ouvrage sont consacrés aux concepts de base
de la logique binaire et des systèmes de numération. Ces notions sont
présentées d'un point de vue relativement abstrait qui n'est pas
étranger au fait que la logique binaire mise en oeuvre dans les
circuits numériques modernes est fondée sur des principes
mathématiques, voire philosophiques établis bien longtemps avant
l'invention de l'électronique.
</p>

<p>
Dans les trois chapitres suivants, on voit comment la logique peut
s'incarner dans des dispositifs électroniques: d'abord avec des portes
logiques simples (chapitre 4), et plus avant, avec des dispositifs
combinatoires plus complexes (chapitre 6). On présente également les
approches permettant de simplifier les circuits logiques
combinatoires, c'est-à-dire ceux dont le comportement ne dépend pas du
temps (chapitre 5).
</p>

<p>
Les circuits logiques séquentiels, qui eux comportent de la
mémoire, sont considérés ensuite. On présente d'abord les loquets et
bascules, composants de base des circuits séquentiels (chapitre 7),
puis on aborde l'analyse (chapitre 8) et la conception (chapitre 9) de
circuits séquentiels synchrones. Le chapitre 10 présente de nombreux
types de circuits séquentiels typiques, alors que le chapitre 11 est
consacré aux différents types de mémoires.
</p>

<p>
Le chapitre 12 offre une brève introduction aux dispositifs logiques
programmables qui amènent les circuits logiques à un autre degré de
flexibilité et d'intégration.
</p>

<p>
Dans les chapitres 13 et 14, on s'intéresse à la modélisation de
circuits, en introduisant le langage desciptif VHDL, qui permet de
décrire formellement des circuits logiques pour en faire la
conception, la simulation, voire, la synthèse.
</p>

<p>
Le manuel se conclut avec des séries d'exercices (chapitre 15) qui
permettront de mettre en pratique les notions abordées.
</p>


<div id="table-of-contents" role="doc-toc">
<h2>Table des matières</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc0a0e35">Avant-propos</a>
<ul>
<li><a href="#org6017347">Remerciements</a></li>
<li><a href="#org9b3bc07">Licence</a></li>
</ul>
</li>
<li><a href="#org5f7149b">Préface</a></li>
<li><a href="#org61adf84">1. Systèmes de numération</a>
<ul>
<li><a href="#org381caad">1.1. Objectifs</a></li>
<li><a href="#org2902341">1.2. Systèmes numériques</a></li>
<li><a href="#org0fbad6a">1.3. Nombres binaires</a></li>
<li><a href="#org48787bb">1.4. Conversion binaire &lt;-&gt; décimal</a></li>
<li><a href="#org4cde37a">1.5. Notation</a></li>
<li><a href="#orgbefd066">1.6. Représentations compactes de nombres binaires</a>
<ul>
<li><a href="#orga7aa74c">1.6.1. Représentation octale</a></li>
<li><a href="#orgcd4a9d6">1.6.2. Représentation hexadécimale</a></li>
<li><a href="#orga129358">1.6.3. Conversion en sens inverse</a></li>
</ul>
</li>
<li><a href="#org265109b">1.7. Nombres binaires fractionnaires</a></li>
<li><a href="#orgd7acbc6">1.8. Opérations arithmétiques binaires</a>
<ul>
<li><a href="#org0f5e2b8">1.8.1. Multiplication et division par deux</a></li>
</ul>
</li>
<li><a href="#orgd25bf51">1.9. Compléments de nombres</a>
<ul>
<li><a href="#org186e94b">1.9.1. Complément à neuf et complément à un</a></li>
<li><a href="#orgd7e5f38">1.9.2. Complément à dix et complément à deux</a></li>
</ul>
</li>
<li><a href="#orgaa7d9cc">1.10. Nombres signés et codage</a></li>
<li><a href="#org19865f6">1.11. Opérations arithmétiques binaires</a>
<ul>
<li><a href="#org0e2985e">1.11.1. Addition de nombres non signés</a></li>
<li><a href="#org67b621b">1.11.2. Addition de nombres signés</a></li>
<li><a href="#org2e18d47">1.11.3. Soustraction de nombres signés</a></li>
<li><a href="#org5d48eb7">1.11.4. Extension de signe</a></li>
</ul>
</li>
<li><a href="#org86d0578">1.12. Codes binaires</a>
<ul>
<li><a href="#org1e0a140">1.12.1. Code Gray</a></li>
<li><a href="#orgf97ffce">1.12.2. Codes alphanumériques et autres</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd16ca91">2. Logique binaire, fonctions logiques et algèbre de Boole</a>
<ul>
<li><a href="#orgd4c38bc">2.1. Objectifs</a></li>
<li><a href="#org534227b">2.2. Logique binaire</a>
<ul>
<li><a href="#org6dc7976">2.2.1. Variable binaire</a></li>
<li><a href="#org528d2e1">2.2.2. Opérations logiques</a></li>
<li><a href="#org0d8a702">2.2.3. Expression logique</a></li>
<li><a href="#orgcca80c5">2.2.4. Tableaux de vérité</a></li>
</ul>
</li>
<li><a href="#orgc1c28dc">2.3. Formalisme mathématique</a>
<ul>
<li><a href="#org23731ea">2.3.1. Définitions</a></li>
</ul>
</li>
<li><a href="#org0a7e649">2.4. Algèbre de Boole</a></li>
<li><a href="#org94565e8">2.5. Algèbre de Boole à deux valeurs</a></li>
<li><a href="#org2adf65a">2.6. Vérification des postulats</a></li>
</ul>
</li>
<li><a href="#orga946858">3. Théorèmes et propriétés</a>
<ul>
<li><a href="#orgc762e8d">3.1. Objectifs</a></li>
<li><a href="#org18dc2c4">3.2. Dualité</a></li>
<li><a href="#org34624b3">3.3. Théorèmes de base</a>
<ul>
<li><a href="#orgfacea77">3.3.1. Autres fonctions logiques</a></li>
<li><a href="#org59e35e0">3.3.2. Fonctions de plusieurs entrées</a></li>
<li><a href="#orge219f72">3.3.3. Expressions et fonctions binaires</a></li>
</ul>
</li>
<li><a href="#org8f74cd1">3.4. Théorèmes de DeMorgan</a></li>
</ul>
</li>
<li><a href="#org1b43a41">4. Portes logiques</a>
<ul>
<li><a href="#org3cb0589">4.1. Objectifs</a></li>
<li><a href="#orge674202">4.2. Niveaux logiques</a></li>
<li><a href="#org988dcbc">4.3. Logique négative ou positive</a></li>
<li><a href="#org9a7ced1">4.4. Symboles</a>
<ul>
<li><a href="#orgc7243c2">4.4.1. Porte ET</a></li>
<li><a href="#orgb5d1d35">4.4.2. Porte OU</a></li>
<li><a href="#org6a98bb7">4.4.3. Porte inverseur</a></li>
<li><a href="#org9b52782">4.4.4. Porte NON-OU (NOR)</a></li>
<li><a href="#org7e5a443">4.4.5. Porte NON-ET (NAND) et NON-OU (NOR)</a></li>
<li><a href="#org9f9e968">4.4.6. Entrées inversées</a></li>
<li><a href="#orgfbd389b">4.4.7. NAND et NOR, représentations équivalentes</a></li>
<li><a href="#org3dcd574">4.4.8. Porte OU-exclusif (XOR)</a></li>
<li><a href="#orgead0a1e">4.4.9. Porte NON-OU-exclusif ou Équivalence (XNOR)</a></li>
</ul>
</li>
<li><a href="#orga5d5685">4.5. Universalité des NAND et NOR</a></li>
<li><a href="#orgf88ed90">4.6. Limites physiques</a>
<ul>
<li><a href="#orgd1752b9">4.6.1. <i>Fan-out</i></a></li>
<li><a href="#org0fe4f47">4.6.2. Modèles de délai</a></li>
<li><a href="#org616ccda">4.6.3. Porte tampon</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2b169b4">5. Simplification logique</a>
<ul>
<li><a href="#org01a85c0">5.1. Objectifs</a></li>
<li><a href="#orgb93ccde">5.2. Expressions équivalentes</a></li>
<li><a href="#orgd20eaea">5.3. Formes canoniques</a>
<ul>
<li><a href="#orgc0b0e43">5.3.1. Minterms et maxterms</a></li>
<li><a href="#orgd3a9880">5.3.2. Somme de produits</a></li>
<li><a href="#org98d32a9">5.3.3. Produit de sommes</a></li>
<li><a href="#orgf8a195e">5.3.4. Conversion entre formes canoniques</a></li>
<li><a href="#org461ee82">5.3.5. Formes standard</a></li>
</ul>
</li>
<li><a href="#org3149e2f">5.4. Objectifs de minimisation</a></li>
<li><a href="#org6c023f9">5.5. Diagrammes de Karnaugh</a>
<ul>
<li><a href="#orgf2875b9">5.5.1. Procédure de simplification</a></li>
<li><a href="#org9da0bb6">5.5.2. Cas facultatifs</a></li>
<li><a href="#org9f7fc13">5.5.3. Impliquants</a></li>
<li><a href="#org2897878">5.5.4. Impliquant premier</a></li>
<li><a href="#org1a3ca31">5.5.5. Couverture d'une fonction</a></li>
<li><a href="#org711ae71">5.5.6. Impliquant premier essentiel</a></li>
<li><a href="#org137c8d3">5.5.7. Sélection des impliquants</a></li>
<li><a href="#orga3a4be7">5.5.8. Minimisation avec cas facultatifs</a></li>
<li><a href="#org6cf807a">5.5.9. Minimisation avec plusieurs fonctions</a></li>
</ul>
</li>
<li><a href="#org287f682">5.6. Tableau de couverture Quine-McCluskey</a>
<ul>
<li><a href="#org30d6aad">5.6.1. Tableau de couverture réduit</a></li>
<li><a href="#org16b9816">5.6.2. Dominance de lignes</a></li>
<li><a href="#orgf0010db">5.6.3. Dominance de colonnes</a></li>
</ul>
</li>
<li><a href="#orgfdedd65">5.7. Implémentation des fonctions simplifiées</a>
<ul>
<li><a href="#org2053b6d">5.7.1. Implémentation à deux niveaux</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org54e799e">6. Circuits combinatoires typiques</a>
<ul>
<li><a href="#org27ba6c6">6.1. Objectifs</a></li>
<li><a href="#org148d3d5">6.2. Circuit combinatoire</a></li>
<li><a href="#org1d8e1b9">6.3. Analyse d'un circuit logique combinatoire</a>
<ul>
<li><a href="#org7754122">6.3.1. Exemple</a></li>
</ul>
</li>
<li><a href="#org4192cff">6.4. Conception d'un circuit combinatoire</a></li>
<li><a href="#org03af29a">6.5. Alternatives d'implémentation</a>
<ul>
<li><a href="#orgba9d112">6.5.1. Implémentations via la fonction directe</a></li>
<li><a href="#org143cc58">6.5.2. Implémentations via la fonction complémentaire</a></li>
</ul>
</li>
<li><a href="#org037ebb6">6.6. Circuits logiques combinatoires classiques</a></li>
<li><a href="#orgb0dc96b">6.7. Additionneur binaire</a>
<ul>
<li><a href="#orgad678a7">6.7.1. Demi-additionneur</a></li>
<li><a href="#org382f033">6.7.2. Additionneur complet</a></li>
<li><a href="#org03caa89">6.7.3. Additionneur binaire pour \(n\) bits</a></li>
<li><a href="#org941ef3f">6.7.4. Propagation de retenue</a></li>
<li><a href="#org4a44f7f">6.7.5. Anticipation de retenue</a></li>
<li><a href="#org51eaa2d">6.7.6. Soustraction</a></li>
<li><a href="#org604cfb9">6.7.7. Débordements</a></li>
</ul>
</li>
<li><a href="#org7a4ff56">6.8. Multiplexeur</a>
<ul>
<li><a href="#org5293503">6.8.1. Multiplexeur deux-vers-un</a></li>
<li><a href="#org8127cc9">6.8.2. Multiplexeur quatre-vers-un</a></li>
</ul>
</li>
<li><a href="#orgf841fbd">6.9. Décodeur</a>
<ul>
<li><a href="#orgeb38c77">6.9.1. Décodeur avec sortie active basse et signal de contrôle</a></li>
<li><a href="#org6272807">6.9.2. Implémentation de fonctions arbitraires au moyen d'un décodeur</a></li>
</ul>
</li>
<li><a href="#orgc8f52c8">6.10. Encodeur</a>
<ul>
<li><a href="#orgbd46903">6.10.1. Encodeur à priorité</a></li>
</ul>
</li>
<li><a href="#org1053c8a">6.11. Comparateur de magnitude</a></li>
<li><a href="#orgf38e804">6.12. Démultiplexeur</a></li>
<li><a href="#orgd787a11">6.13. Encodeurs divers</a></li>
<li><a href="#org1dec145">6.14. Portes à trois états et tampon de bus</a></li>
</ul>
</li>
<li><a href="#org1b7a21f">7. Circuits séquentiels</a>
<ul>
<li><a href="#org985d274">7.1. Objectifs</a></li>
<li><a href="#org9a73490">7.2. Modèle d'un circuit séquentiel</a></li>
<li><a href="#org9c125a8">7.3. Éléments de mémoire</a></li>
<li><a href="#orgf4c1fce">7.4. Loquets</a>
<ul>
<li><a href="#org14392cf">7.4.1. Loquet SR</a></li>
<li><a href="#orge8661fa">7.4.2. Loquet D</a></li>
</ul>
</li>
<li><a href="#org99744a1">7.5. Application: rebonds d'interrupteurs</a></li>
<li><a href="#org2610970">7.6. Bascules (Flip Flops)</a>
<ul>
<li><a href="#org2632d34">7.6.1. Bascule D</a></li>
<li><a href="#orgeaec931">7.6.2. Délais et réponse temporelle</a></li>
<li><a href="#orge4252cd">7.6.3. Autres bascules</a></li>
<li><a href="#org4dd8153">7.6.4. Bascule JK</a></li>
<li><a href="#org9264659">7.6.5. Bascule T</a></li>
<li><a href="#org99887b4">7.6.6. Tableaux caractéristiques</a></li>
<li><a href="#org36c2eee">7.6.7. Équations caractéristiques</a></li>
<li><a href="#orga248a71">7.6.8. Entrées asynchrones</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6556936">8. Analyse de circuits logiques séquentiels synchrones</a>
<ul>
<li><a href="#org8508588">8.1. Objectifs</a></li>
<li><a href="#orgab2923c">8.2. Démarche d'analyse</a></li>
<li><a href="#org657952e">8.3. Exemple d'analyse</a></li>
<li><a href="#org35ac45f">8.4. Analyse pour des bascules JK</a>
<ul>
<li><a href="#org7d1c85b">8.4.1. Exemple avec bascules JK</a></li>
</ul>
</li>
<li><a href="#org3767d59">8.5. Modèles de machines séquentielles</a></li>
</ul>
</li>
<li><a href="#org84b5db5">9. Conception de circuits logiques séquentiels</a>
<ul>
<li><a href="#org27e0873">9.1. Objectifs</a></li>
<li><a href="#org8644e26">9.2. Conception d'un circuit séquentiel synchrone</a></li>
<li><a href="#org23b6e39">9.3. Spécification fonctionnelle</a></li>
<li><a href="#org6924546">9.4. Diagramme d'état</a></li>
<li><a href="#orga371fde">9.5. Tableau d'états</a></li>
<li><a href="#orgc8f928b">9.6. Réduction du nombre d'états</a>
<ul>
<li><a href="#org87a7c33">9.6.1. Tableau d'implication</a></li>
</ul>
</li>
<li><a href="#org3609b09">9.7. Codage des états</a></li>
<li><a href="#org8e9ba32">9.8. Décodeur d'état</a></li>
<li><a href="#org46372ee">9.9. Décodeur de sorties</a></li>
<li><a href="#orgcc4ae54">9.10. Procédure de conception</a></li>
<li><a href="#org43cc313">9.11. Exemple de conception</a>
<ul>
<li><a href="#org6bdb469">9.11.1. Bascules D</a></li>
<li><a href="#orgccbbeca">9.11.2. Autres types de bascules</a></li>
</ul>
</li>
<li><a href="#org47b36ac">9.12. États interdits</a></li>
<li><a href="#orgd0f79e5">9.13. Exemple avec états <i>one-hot</i></a></li>
</ul>
</li>
<li><a href="#org8adfbd6">10. Circuit séquentiels: registres et compteurs</a>
<ul>
<li><a href="#org2cf7aca">10.1. Objectifs</a></li>
<li><a href="#org8672e97">10.2. Registres</a>
<ul>
<li><a href="#org6f07dfc">10.2.1. Chargement parallèle</a></li>
<li><a href="#orgb2379b9">10.2.2. Registres à décalage</a></li>
</ul>
</li>
<li><a href="#org5753f6b">10.3. Compteurs</a>
<ul>
<li><a href="#orgc95eeef">10.3.1. Compteur asynchrone</a></li>
<li><a href="#org5c6ef41">10.3.2. Compteur synchrone</a></li>
<li><a href="#orgbeef1cc">10.3.3. Compteur bidirectionnel</a></li>
<li><a href="#org7f1052c">10.3.4. Compteur en anneau</a></li>
<li><a href="#org3492be5">10.3.5. Compteur Johnson</a></li>
<li><a href="#orgeb26306">10.3.6. Diviseur de fréquence</a></li>
<li><a href="#org19adbf9">10.3.7. Compteur à chargement parallèle</a></li>
<li><a href="#org54a455c">10.3.8. Compteur modulo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org40f9804">11. Mémoires</a>
<ul>
<li><a href="#org9de0de2">11.1. Objectifs</a></li>
<li><a href="#org7644e6d">11.2. Mémoires</a>
<ul>
<li><a href="#orgb57defa">11.2.1. Mémoires non-volatiles</a></li>
<li><a href="#org0d275df">11.2.2. Mémoires volatiles</a></li>
</ul>
</li>
<li><a href="#org8cfadc4">11.3. Adressage</a>
<ul>
<li><a href="#orga367f24">11.3.1. Lecture et écriture</a></li>
<li><a href="#org2bec9f8">11.3.2. Bus de données</a></li>
<li><a href="#org7513171">11.3.3. Chronogrammes</a></li>
</ul>
</li>
<li><a href="#org8f492b0">11.4. Mémoires mortes</a>
<ul>
<li><a href="#org4874534">11.4.1. Implémentation de fonctions combinatoires</a></li>
<li><a href="#orge53dcd9">11.4.2. Tableau de correspondance</a></li>
<li><a href="#org2363aca">11.4.3. Catégories de mémoires ROM</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8873d6d">12. Logique programmable</a>
<ul>
<li><a href="#orgff6a562">12.1. Objectifs</a></li>
<li><a href="#orgd7f4260">12.2. Dispositifs programmables</a>
<ul>
<li><a href="#org60e45cf">12.2.1. Matrice logique programmable (PLA)</a></li>
<li><a href="#org5c40955">12.2.2. Logique à matrice programmable (PAL)</a></li>
<li><a href="#orgc2fcc24">12.2.3. Logique programmable séquentielle</a></li>
</ul>
</li>
<li><a href="#org7a4d58d">12.3. Circuits intégrés programmables</a></li>
</ul>
</li>
<li><a href="#org1d0b147">13. Langages descriptifs et de modélisation</a>
<ul>
<li><a href="#org9f5453d">13.1. Objectifs</a></li>
<li><a href="#orgfcf7a9d">13.2. Modélisation et simulation</a></li>
<li><a href="#org751d87a">13.3. Le langage VHDL</a></li>
<li><a href="#org28e68cb">13.4. Entité</a></li>
<li><a href="#org28ec914">13.5. Architecture</a></li>
<li><a href="#orgd5b923c">13.6. Signaux et assignation</a></li>
<li><a href="#orgec6f4c5">13.7. Notes sur la syntaxe</a></li>
<li><a href="#org38253bc">13.8. Concurrence</a></li>
<li><a href="#org58afca0">13.9. Vecteurs de bits</a></li>
<li><a href="#org905a75a">13.10. Modèle complet</a></li>
<li><a href="#org236772d">13.11. Modèle comportemental</a></li>
<li><a href="#org36a3c41">13.12. Modèle flux de données</a></li>
<li><a href="#org593e34f">13.13. Modèle structural</a></li>
<li><a href="#org181b628">13.14. Bloc processus</a></li>
<li><a href="#orga5de0fc">13.15. Modélisation du délai</a>
<ul>
<li><a href="#orgf06adf0">13.15.1. Délai inertiel</a></li>
<li><a href="#orgfcc8386">13.15.2. Délai de transport</a></li>
</ul>
</li>
<li><a href="#org56d357f">13.16. Librairies</a></li>
<li><a href="#org4ac69b7">13.17. Encapsulation</a></li>
<li><a href="#org07fe218">13.18. Description de design en VHDL</a>
<ul>
<li><a href="#orgf7602a3">13.18.1. Multiplicateur huit bits</a></li>
</ul>
</li>
<li><a href="#org2cf741d">13.19. Banc d'essai</a></li>
<li><a href="#org9e26d76">13.20. Instanciation</a></li>
<li><a href="#org73cd4cf">13.21. Écoulement du temps</a></li>
<li><a href="#org5bef9d9">13.22. Exemples de banc d'essai</a>
<ul>
<li><a href="#org7a2bcba">13.22.1. Création d'une entité vide pour le banc d'essai</a></li>
<li><a href="#org57cd228">13.22.2. Instanciation du modèle à tester</a></li>
<li><a href="#orgaea0135">13.22.3. Génération de l'horloge et du signal de mise à zéro</a></li>
<li><a href="#orgd98612b">13.22.4. Stimulus</a></li>
<li><a href="#org1656510">13.22.5. Exemples complets</a></li>
</ul>
</li>
<li><a href="#orgd89ba08">13.23. Compilation et simulation</a></li>
</ul>
</li>
<li><a href="#org8eded96">14. Préparation et simulation des modèles VHDL</a>
<ul>
<li><a href="#org117b1a7">14.1. Éditeurs</a></li>
<li><a href="#org541c10d">14.2. Simulateurs gratuits</a>
<ul>
<li><a href="#org139eb9a">14.2.1. Modelsim/Questa</a></li>
<li><a href="#org7c40ed0">14.2.2. Active-HDL (version étudiant)</a></li>
<li><a href="#org1b6b330">14.2.3. Vivado (Xilinx)</a></li>
<li><a href="#org412f991">14.2.4. GHDL/GTKWave</a></li>
<li><a href="#org5b49234">14.2.5. EDA Playground</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf2083e4">15. Exercices</a></li>
</ul>
</div>
</div>
<div id="list-of-tables">
<h2>Liste des tableaux</h2>
<div id="text-list-of-tables">
<ul>
<li><a href="#orgf3af0d5"><span class="table-number">Tableau 1 :</span> Valeur binaire du nombre \(10101\)</a></li>
<li><a href="#orge10d6c7"><span class="table-number">Tableau 2 :</span> Étapes de conversion de 37 en binaire</a></li>
<li><a href="#orgb891209"><span class="table-number">Tableau 3 :</span> Représentation octale</a></li>
<li><a href="#orgc5eb229"><span class="table-number">Tableau 4 :</span> Regroupement pour conversion en octal</a></li>
<li><a href="#orgbc34a81"><span class="table-number">Tableau 5 :</span> Représentation hexadécimale</a></li>
<li><a href="#org86430b6"><span class="table-number">Tableau 6 :</span> Regroupement pour conversion en hexadécimal</a></li>
<li><a href="#orga7cb04f"><span class="table-number">Tableau 7 :</span> Évaluation de la valeur du nombre fractionnaire (101,11)2</a></li>
<li><a href="#orgf09d573"><span class="table-number">Tableau 8 :</span> Étapes pour complément à deux</a></li>
<li><a href="#org4ca0a40"><span class="table-number">Tableau 9 :</span> Nombre de valeurs à représenter entre \(-10\) et \(+10\)</a></li>
<li><a href="#org0a3aeb4"><span class="table-number">Tableau 10 :</span> Assignation de codes aux nombres de 4 bits</a></li>
<li><a href="#orgeb13317"><span class="table-number">Tableau 11 :</span> Tableau de vérité pour l'additionneur binaire</a></li>
<li><a href="#org1b7d07b"><span class="table-number">Tableau 12 :</span> Code Gray à quatre bits</a></li>
<li><a href="#org8543738"><span class="table-number">Tableau 13 :</span> Théorèmes de l'algèbre de Boole</a></li>
<li><a href="#org4c43add"><span class="table-number">Tableau 14 :</span> Tableau de vérité de la fonction NON-ET</a></li>
<li><a href="#org65c1ba8"><span class="table-number">Tableau 15 :</span> Tableau de vérité de la fonction NON-OU</a></li>
<li><a href="#orgfd17abf"><span class="table-number">Tableau 16 :</span> Tableau de vérité de la fonction OU-exclusif</a></li>
<li><a href="#orgc65a594"><span class="table-number">Tableau 17 :</span> Fonction de trois variables</a></li>
<li><a href="#org94e5f2d"><span class="table-number">Tableau 18 :</span> Minterms et maxterms pour trois variables</a></li>
<li><a href="#org5c82437"><span class="table-number">Tableau 19 :</span> Fonction de trois variables</a></li>
<li><a href="#org01e7fe7"><span class="table-number">Tableau 20 :</span> Tableau réduit</a></li>
<li><a href="#org08e8a39"><span class="table-number">Tableau 21 :</span> Tableaux de vérité des fonctions intermédiaires et de la sortie</a></li>
<li><a href="#orgcda6715"><span class="table-number">Tableau 22 :</span> Tableau de vérité pour l'additionneur binaire</a></li>
<li><a href="#org93ae310"><span class="table-number">Tableau 23 :</span> Tableau de vérité pour un demi-additionneur</a></li>
<li><a href="#orgd7f3ab7"><span class="table-number">Tableau 24 :</span> Addition de (+50)10 + (+100)10 = (00110010)2 + (01100100)2</a></li>
<li><a href="#orga69dc1f"><span class="table-number">Tableau 25 :</span> Addition de (-50)10 + (-100)10 = (1100 1110)2 + (1001 1100)2</a></li>
<li><a href="#orgfe3130b"><span class="table-number">Tableau 26 :</span> Tableau de vérité du multiplexeur quatre-vers-un</a></li>
<li><a href="#org3c436d5"><span class="table-number">Tableau 27 :</span> Tableau de vérité du décodeur trois-vers-huit</a></li>
<li><a href="#org0bdbd27"><span class="table-number">Tableau 28 :</span> Tableau de vérité, décodeur 2 vers 4 avec sortie active basse</a></li>
<li><a href="#orgac67f0d"><span class="table-number">Tableau 29 :</span> Tableau de vérité pour la fonction arbitraire</a></li>
<li><a href="#org288c5f3"><span class="table-number">Tableau 30 :</span> Tableau de vérité pour l'encodeur 3 bits</a></li>
<li><a href="#org512738e"><span class="table-number">Tableau 31 :</span> Tableau de vérité pour encodeur 2 bits à priorité</a></li>
<li><a href="#org51fa895"><span class="table-number">Tableau 32 :</span> Tableau de vérité pour un  multiplexeur quatre-vers-un trois états</a></li>
<li><a href="#org36ae46b"><span class="table-number">Tableau 33 :</span> Loquet SR NOR: tableau de fonctionnement</a></li>
<li><a href="#org254c98c"><span class="table-number">Tableau 34 :</span> Loquet SR NAND: tableau de fonctionnement</a></li>
<li><a href="#org59bccb7"><span class="table-number">Tableau 35 :</span> Loquet SR avec signal de contrôle: tableau de fonctionnement</a></li>
<li><a href="#org40bbd81"><span class="table-number">Tableau 36 :</span> Loquet D: tableau de fonctionnement</a></li>
<li><a href="#orge6c4320"><span class="table-number">Tableau 37 :</span> Bascule D</a></li>
<li><a href="#orgafdf38a"><span class="table-number">Tableau 38 :</span> Bascule JK</a></li>
<li><a href="#orgcb57d89"><span class="table-number">Tableau 39 :</span> Bascule T</a></li>
<li><a href="#org8c502c1"><span class="table-number">Tableau 40 :</span> Tableau d'excitation pour l'exemple</a></li>
<li><a href="#org0a5888c"><span class="table-number">Tableau 41 :</span> Tableau d'excitation circuit séquentiel JK</a></li>
<li><a href="#org6af6a90"><span class="table-number">Tableau 42 :</span> Tableau d'état initial</a></li>
<li><a href="#org0e3931f"><span class="table-number">Tableau 43 :</span> Tableau d'état après une simplification</a></li>
<li><a href="#org611ef6b"><span class="table-number">Tableau 44 :</span> Tableau d'état simplifié</a></li>
<li><a href="#org86baa1f"><span class="table-number">Tableau 45 :</span> Tableau d'état (machine de Moore)</a></li>
<li><a href="#org2867990"><span class="table-number">Tableau 46 :</span> Tableau d'implication</a></li>
<li><a href="#orged1be23"><span class="table-number">Tableau 47 :</span> Tableau d'implication, après étape 1</a></li>
<li><a href="#orga2d67a9"><span class="table-number">Tableau 48 :</span> Tableau d'implication, après étape 3</a></li>
<li><a href="#org42577bf"><span class="table-number">Tableau 49 :</span> Tableau d'état réduit (machine de Moore)</a></li>
<li><a href="#orgc2cae29"><span class="table-number">Tableau 50 :</span> Possibilités d'assignation de codes d'états</a></li>
<li><a href="#org3ba2837"><span class="table-number">Tableau 51 :</span> Tableau d'assignation d'état</a></li>
<li><a href="#orga4ea3f1"><span class="table-number">Tableau 52 :</span> Tableau de transition d'états</a></li>
<li><a href="#org15b5a16"><span class="table-number">Tableau 53 :</span> Tableau d'excitation, bascule JK</a></li>
<li><a href="#orga1c4723"><span class="table-number">Tableau 54 :</span> Tableau d'excitation, bascule T</a></li>
<li><a href="#org8ed173e"><span class="table-number">Tableau 55 :</span> Tableau de transition d'états, avec bascules JK</a></li>
<li><a href="#org3b77136"><span class="table-number">Tableau 56 :</span> Assignation <i>one-hot</i></a></li>
<li><a href="#orge75ece5"><span class="table-number">Tableau 57 :</span> Tableau de transition d'états <i>one-hot</i></a></li>
<li><a href="#orgfd23f49"><span class="table-number">Tableau 58 :</span> Codes de sélection et opérations</a></li>
<li><a href="#orga68492d"><span class="table-number">Tableau 59 :</span> Séquence du compteur</a></li>
<li><a href="#org96aa7b4"><span class="table-number">Tableau 60 :</span> Tableau d'état du compteur</a></li>
<li><a href="#org5c67146"><span class="table-number">Tableau 61 :</span> Séquence d'états du compteur Johnson</a></li>
<li><a href="#orge8095d8"><span class="table-number">Tableau 62 :</span> Signaux de contrôle d'une mémoire</a></li>
<li><a href="#org967fc41"><span class="table-number">Tableau 63 :</span> Valeurs pour <i>std<sub>logic</sub></i></a></li>
<li><a href="#org80ddbb8"><span class="table-number">Tableau 64 :</span> Unités de temps</a></li>
</ul>
</div>
</div>
<div id="list-of-listings">
<h2>Liste des programmes</h2>
<div id="text-list-of-listings">
<ul>
<li><span class="listing-number">Programme&nbsp;1&nbsp;:</span> Déclaration d'entité</li>
<li><span class="listing-number">Programme&nbsp;2&nbsp;:</span> Déclarations génériques</li>
<li><span class="listing-number">Programme&nbsp;3&nbsp;:</span> Déclaration d'entité 2</li>
<li><span class="listing-number">Programme&nbsp;4&nbsp;:</span> Déclaration d'architecture</li>
<li><span class="listing-number">Programme&nbsp;5&nbsp;:</span> Expressions</li>
<li><span class="listing-number">Programme&nbsp;6&nbsp;:</span> Assignations et commentaires</li>
<li><span class="listing-number">Programme&nbsp;7&nbsp;:</span> Précédence d'opérations et associativité</li>
<li><span class="listing-number">Programme&nbsp;8&nbsp;:</span> Assignations avec vecteurs de signaux</li>
<li><span class="listing-number">Programme&nbsp;9&nbsp;:</span> Énoncés concurrents</li>
<li><span class="listing-number">Programme&nbsp;10&nbsp;:</span> Énoncés concurrents équivalents</li>
<li><span class="listing-number">Programme&nbsp;11&nbsp;:</span> Vecteur de bits</li>
<li><span class="listing-number">Programme&nbsp;12&nbsp;:</span> Concaténation</li>
<li><span class="listing-number">Programme&nbsp;13&nbsp;:</span> Calcul de somme initial</li>
<li><span class="listing-number">Programme&nbsp;14&nbsp;:</span> Calcul de somme compact</li>
<li><span class="listing-number">Programme&nbsp;15&nbsp;:</span> Bascule JK maître-esclave</li>
<li><span class="listing-number">Programme&nbsp;16&nbsp;:</span> Bloc processus</li>
<li><span class="listing-number">Programme&nbsp;17&nbsp;:</span> Bascule D, front montant, mise à zéro asynchrone</li>
<li><span class="listing-number">Programme&nbsp;18&nbsp;:</span> Processus avec porte OU combinatoire</li>
<li><span class="listing-number">Programme&nbsp;19&nbsp;:</span> Délai inertiel</li>
<li><span class="listing-number">Programme&nbsp;20&nbsp;:</span> Délai de transport</li>
<li><span class="listing-number">Programme&nbsp;21&nbsp;:</span> Déclaration de librairies</li>
<li><span class="listing-number">Programme&nbsp;22&nbsp;:</span> Encapsulation</li>
<li><span class="listing-number">Programme&nbsp;23&nbsp;:</span> Utilisation d'une composante</li>
<li><span class="listing-number">Programme&nbsp;24&nbsp;:</span> Bascule maître-esclave structurale</li>
<li><span class="listing-number">Programme&nbsp;25&nbsp;:</span> Compteur basé sur la bascule</li>
<li><span class="listing-number">Programme&nbsp;26&nbsp;:</span> Multiplicateur 8 bits: entités</li>
<li><span class="listing-number">Programme&nbsp;27&nbsp;:</span> Multiplicateur 8 bits: composante adder</li>
<li><span class="listing-number">Programme&nbsp;28&nbsp;:</span> Multiplicateur 8 bits: composante FF</li>
<li><span class="listing-number">Programme&nbsp;29&nbsp;:</span> Multiplicateur 8 bits: déclarations</li>
<li><span class="listing-number">Programme&nbsp;30&nbsp;:</span> Multiplicateur 8 bits: descriptions</li>
<li><span class="listing-number">Programme&nbsp;31&nbsp;:</span> Entité banc d'essai</li>
<li><span class="listing-number">Programme&nbsp;32&nbsp;:</span> Banc d'essai: instanciation par composant</li>
<li><span class="listing-number">Programme&nbsp;33&nbsp;:</span> Composant lié</li>
<li><span class="listing-number">Programme&nbsp;34&nbsp;:</span> Instanciation directe</li>
<li><span class="listing-number">Programme&nbsp;35&nbsp;:</span> Énoncés liés au temps</li>
<li><span class="listing-number">Programme&nbsp;36&nbsp;:</span> Énoncé after</li>
<li><span class="listing-number">Programme&nbsp;37&nbsp;:</span> Signal de mise à zéro</li>
<li><span class="listing-number">Programme&nbsp;38&nbsp;:</span> Signal d'horloge</li>
<li><span class="listing-number">Programme&nbsp;39&nbsp;:</span> Énoncé wait</li>
<li><span class="listing-number">Programme&nbsp;40&nbsp;:</span> Liste de signaux en attente d'évènement</li>
<li><span class="listing-number">Programme&nbsp;41&nbsp;:</span> Entité vide pour banc d'essai</li>
<li><span class="listing-number">Programme&nbsp;42&nbsp;:</span> Instanciation du modèle</li>
<li><span class="listing-number">Programme&nbsp;43&nbsp;:</span> Génération de signaux de test</li>
<li><span class="listing-number">Programme&nbsp;44&nbsp;:</span> Stimulus pour entrées</li>
<li><span class="listing-number">Programme&nbsp;45&nbsp;:</span> Premier exemple complet de banc d'essai</li>
<li><span class="listing-number">Programme&nbsp;46&nbsp;:</span> Deuxième exemple complet de banc d'essai, portion 1</li>
<li><span class="listing-number">Programme&nbsp;47&nbsp;:</span> Deuxième exemple complet de banc d'essai, portion 2</li>
<li><span class="listing-number">Programme&nbsp;48&nbsp;:</span> Deuxième exemple complet de banc d'essai, portion 3</li>
<li><span class="listing-number">Programme&nbsp;49&nbsp;:</span> Entité de niveau supérieur</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-org61adf84" class="outline-2">
<h2 id="org61adf84"><span class="section-number-2">1.</span> Systèmes de numération</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org381caad" class="outline-3">
<h3 id="org381caad"><span class="section-number-3">1.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Comprendre le fonctionnement du système de numération binaire</li>
<li>Pouvoir effectuer des conversions entre nombres en représentation
binaire, octale, hexadécimale</li>
<li>Comprendre le rôle des compléments, et la représentation de nombres signés</li>
<li>Comprendre la notation fractionnaire</li>
<li>Se familiariser avec quelques codes courants</li>
<li>Pouvoir effectuer des opérations arithmétiques sur des nombres binaires</li>
</ul>
</div>
</div>

<div id="outline-container-org2902341" class="outline-3">
<h3 id="org2902341"><span class="section-number-3">1.2.</span> Systèmes numériques</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Les systèmes numériques sont omniprésents dans notre monde
technologique. La grande force des systèmes numériques est leur
capacité à représenter l'information sous toutes ses formes et à
permettre la manipulation de cette information. Tout ensemble dont les
éléments peuvent être dénombrés, comme un alphabet ou un ensemble fini
de couleurs, se prête naturellement à une représentation
numérique. Mais il est également possible de représenter des
informations qui correspondent à des informations provenant
d'ensembles continus, comme par exemple des informations sonores, en
procédant à une numérisation par échantillonnage et codage. 
</p>

<p>
Une bonne façon de se familiariser avec la représentation numérique de
l'information est d'étudier le système de numération binaire. Dans un
chapitre suivant, nous étudierons les principes fondamentaux de la
logique binaire. C'est sur ces deux bases que nous pourrons établir
notre exploration des circuits logiques.
</p>
</div>
</div>

<div id="outline-container-org0fbad6a" class="outline-3">
<h3 id="org0fbad6a"><span class="section-number-3">1.3.</span> Nombres binaires</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Les nombres binaires sont essentiellement construits de la même façon
que les nombres décimaux avec lesquels nous sommes plus familiers. La
différence fondamentale tient au fait qu'il n'est possible d'utiliser
que deux symboles (chiffres), 0 et 1, plutôt que les dix chiffres de 0
à 9. Les chiffres sont nommés bits (contraction de <b>b</b> inary dig
<b>it</b>).
</p>

<p>
Par exemple, le nombre décimal que nous écrivons \(2843\) correspond à
\(2 \times 1000 + 8 \times 100 + 4 \times 10 + 3 \times 1\). Il s'agit
d'un système positionnel, dans lequel la valeur attribuée à un chiffre
est définie par sa position et par la valeur de la <b>base</b> du système
de numération. Ainsi, pour ce nombre décimal, la base vaut 10 et on a
\(2 \times 10^3 + 8 \times 10^2 + 4 \times 10^1 + 3 \times 10^0\). La
position la plus à gauche est celle dont la valeur est la plus
grande. C'est le <b>chiffre le plus significatif</b>; la position de droite
correspond au <b>chiffre le moins significatif</b>. On peut imaginer une
virgule après le chiffre le moins significatif, pour délimiter la
partie entière du nombre. D'autres chiffres, placés à droite de cette
virgule correspondraient à la partie fractionnaire. On y reviendra.
</p>

<p>
Les mêmes règles positionnelles permettent d'attribuer une valeur à un
nombre binaire, en tenant compte du fait que la base vaut cette
fois-ci 2. Par exemple, la valeur attribuée au nombre binaire
\(10101\) est 
</p>

<p>
\[ 1 \times 2^4 + 0 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1
\times 2^0 = 16+4+1= 21 \]
</p>

<p>
comme on peut voir dans le tableau <a href="#orgf3af0d5">1</a>.
</p>

<table id="orgf3af0d5" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 1 :</span> Valeur binaire du nombre \(10101\)</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Position</th>
<th scope="col" class="org-right">4</th>
<th scope="col" class="org-right">3</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Valeur</td>
<td class="org-right">\(2^4\)</td>
<td class="org-right">\(2^3\)</td>
<td class="org-right">\(2^2\)</td>
<td class="org-right">\(2^1\)</td>
<td class="org-right">\(2^0\)</td>
</tr>

<tr>
<td class="org-left">Valeur déc.</td>
<td class="org-right">16</td>
<td class="org-right">8</td>
<td class="org-right">4</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Bit</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Nous avons ici le <b>bit le plus significatif</b> à gauche et le <b>bit le
moins significatif</b> à droite. Chaque chiffre vaut 2 fois plus que le
chiffre immédiatement placé à sa droite.
</p>
</div>
</div>

<div id="outline-container-org48787bb" class="outline-3">
<h3 id="org48787bb"><span class="section-number-3">1.4.</span> Conversion binaire &lt;-&gt; décimal</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Convertir un nombre entier binaire en nombre décimal se fait
naturellement, en s'appuyant sur les valeurs associées à la notation
positionnelle. La conversion en sens inverse, de décimal à binaire,
est un peu moins évidente. La méthode consiste à faire une division
entière du nombre (et des quotients successifs) par 2 et à noter les
restes obtenus. Le premier reste correspond au bit le moins
significatif, et le dernier au bit le plus significatif.
</p>

<p>
Par exemple, les opération pour convertir 37 en binaire sont résumées
dans le tableau <a href="#orge10d6c7">2</a>.
</p>

<table id="orge10d6c7" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 2 :</span> Étapes de conversion de 37 en binaire</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">Quotient entier</th>
<th scope="col" class="org-right">Reste</th>
<th scope="col" class="org-left">Coefficient</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">37/2</td>
<td class="org-right">18</td>
<td class="org-right">1</td>
<td class="org-left">\(a_0 = 1\)</td>
</tr>

<tr>
<td class="org-left">18/2</td>
<td class="org-right">9</td>
<td class="org-right">0</td>
<td class="org-left">\(a_1 = 0\)</td>
</tr>

<tr>
<td class="org-left">9/2</td>
<td class="org-right">4</td>
<td class="org-right">1</td>
<td class="org-left">\(a_2 = 1\)</td>
</tr>

<tr>
<td class="org-left">4/2</td>
<td class="org-right">2</td>
<td class="org-right">0</td>
<td class="org-left">\(a_3 = 0\)</td>
</tr>

<tr>
<td class="org-left">2/2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">\(a_4 = 0\)</td>
</tr>

<tr>
<td class="org-left">1/2</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">\(a_5 = 1\)</td>
</tr>
</tbody>
</table>

<p>
On obtient ainsi 100101.
</p>
</div>
</div>

<div id="outline-container-org4cde37a" class="outline-3">
<h3 id="org4cde37a"><span class="section-number-3">1.5.</span> Notation</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Puisque les notations de nombres binaires, octaux, hexadécimaux ou
décimaux font appel à des chiffres qui sont tous tirés du même
ensemble, il y a un risque d’ambiguïté si on ne connaît pas la base
utilisée. Par exemple 11 peut soit s'interpréter comme onze (si on
suppose la base dix) ou comme trois (si on suppose la base deux). À
moins que le contexte ne soit absolument clair, il vaut mieux être
explicite pour éviter de telles ambiguïtés. C'est pourquoi on dénote
souvent explicitement la base, comme par exemple, (11)2 pour le nombre
trois en binaire qui pourra être distingué de (11)10, le nombre onze
en décimal.
</p>
</div>
</div>

<div id="outline-container-orgbefd066" class="outline-3">
<h3 id="orgbefd066"><span class="section-number-3">1.6.</span> Représentations compactes de nombres binaires</h3>
<div class="outline-text-3" id="text-1-6">
<p>
En comparant un nombre décimal et sa représentation binaire, comme par
exemple ici 37 et 100101, on voit bien que la représentation binaire
est nettement plus encombrante. On utilise souvent des notations plus
compactes mais qui conservent un lien direct avec la représentation
binaire: la représentation <b>octale</b> et la représentation
<b>hexadécimale</b>.
</p>
</div>

<div id="outline-container-orga7aa74c" class="outline-4">
<h4 id="orga7aa74c"><span class="section-number-4">1.6.1.</span> Représentation octale</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
La représentation octale correspond à utiliser la base 8, avec les
chiffres \(0, 1, \ldots, 7\). On voit la correspondance entre les
nombres en binaire et les chiffres de la représentation octale dans le
tableau <a href="#orgb891209">3</a>.
</p>

<table id="orgb891209" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 3 :</span> Représentation octale</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Binaire</th>
<th scope="col" class="org-right">Octal</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">000</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">001</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">010</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">011</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">100</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">101</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">110</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">111</td>
<td class="org-right">7</td>
</tr>
</tbody>
</table>

<p>
Pour convertir un nombre binaire en nombre octal, il suffit de
regrouper les bits par groupes de trois bits, en partant de la droite
(bit le moins significatif), et de remplacer chaque groupe par le
chiffre en base 8 correspondant.
</p>

<p>
Par exemple pour (1010011110001)2, on aura le découpage du tableau
<a href="#orgc5eb229">4</a>.
</p>

<table id="orgc5eb229" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 4 :</span> Regroupement pour conversion en octal</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Binaire</td>
<td class="org-right">1</td>
<td class="org-right">010</td>
<td class="org-right">011</td>
<td class="org-right">110</td>
<td class="org-right">001</td>
</tr>

<tr>
<td class="org-left">Octal</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">6</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
On obtient le nombre octal (12361)8.
</p>
</div>
</div>

<div id="outline-container-orgcd4a9d6" class="outline-4">
<h4 id="orgcd4a9d6"><span class="section-number-4">1.6.2.</span> Représentation hexadécimale</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
La représentation hexadécimale correspond à utiliser la base 16, avec
les chiffres \(0, 1, \ldots, 9\), auxquels on ajoute les lettres A, B,
C, D, E et F pour représenter les valeurs de dix à quinze
respectivement<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>. On voit la correspondance entre les nombres en binaire et les chiffres de la représentation hexadécimale dans le tableau <a href="#orgbc34a81">5</a>.
</p>

<table id="orgbc34a81" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 5 :</span> Représentation hexadécimale</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Binaire</th>
<th scope="col" class="org-right">Hexadécimal</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0000</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0001</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0010</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">0011</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">0100</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">0101</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">0110</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">0111</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">1000</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-right">1001</td>
<td class="org-right">9</td>
</tr>

<tr>
<td class="org-right">1010</td>
<td class="org-right">A</td>
</tr>

<tr>
<td class="org-right">1011</td>
<td class="org-right">B</td>
</tr>

<tr>
<td class="org-right">1100</td>
<td class="org-right">C</td>
</tr>

<tr>
<td class="org-right">1101</td>
<td class="org-right">D</td>
</tr>

<tr>
<td class="org-right">1110</td>
<td class="org-right">E</td>
</tr>

<tr>
<td class="org-right">1111</td>
<td class="org-right">F</td>
</tr>
</tbody>
</table>


<p>
Pour convertir un nombre binaire en nombre hexadécimal, il suffit de
regrouper les bits par groupes de quatre bits, en partant de la droite
(bit le moins significatif), et de remplacer chaque groupe par le
chiffre en base 16 correspondant
</p>

<p>
Par exemple pour (1010011110001)2, on aura le découpage du tableau
<a href="#org86430b6">6</a>.
</p>

<table id="org86430b6" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 6 :</span> Regroupement pour conversion en hexadécimal</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Binaire</td>
<td class="org-right">1</td>
<td class="org-right">0100</td>
<td class="org-right">1111</td>
<td class="org-right">0001</td>
</tr>

<tr>
<td class="org-left">Hexa</td>
<td class="org-right">1</td>
<td class="org-right">4</td>
<td class="org-right">F</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
On obtient le nombre hexadécimal (14F1)16.
</p>
</div>
</div>

<div id="outline-container-orga129358" class="outline-4">
<h4 id="orga129358"><span class="section-number-4">1.6.3.</span> Conversion en sens inverse</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
La conversion de octal (respectivement, hexadécimal) à binaire se fait
simplement en remplaçant chaque chiffre octal (resp., hexadécimal) par
le groupe de trois (resp., quatre) bits correspondant, en partant du
moins significatif.
</p>
</div>
</div>
</div>

<div id="outline-container-org265109b" class="outline-3">
<h3 id="org265109b"><span class="section-number-3">1.7.</span> Nombres binaires fractionnaires</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Il est aussi possible de représenter des nombres fractionnaires en
base deux. En gardant à l'esprit que la position d'un bit détermine sa
valeur, il suffit d'étendre le principe déjà établi aux bits qui
seront placés après la virgule qui sépare la partie entière de la
partie fractionnaire. Les indices des positions à droite de la virgule
seront négatifs.
</p>

<p>
Le tableau <a href="#orga7cb04f">7</a> donne par exemple le détail de l'évaluation
de la valeur du nombre fractionnaire (101,11)2. On obtient comme
valeur \(1 \times 4 + 0 \times 2 + 1 \times 1 + 1 \times 1/2 + 1
\times 1/4 = 5,75\).
</p>

<table id="orga7cb04f" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 7 :</span> Évaluation de la valeur du nombre fractionnaire (101,11)2</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Position</th>
<th scope="col" class="org-right">2</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-right">-1</th>
<th scope="col" class="org-right">-2</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Valeur</td>
<td class="org-right">\(2^2\)</td>
<td class="org-right">\(2^1\)</td>
<td class="org-right">\(2^0\)</td>
<td class="org-right">\(2^{-1}\)</td>
<td class="org-right">\(2^{-2}\)</td>
</tr>

<tr>
<td class="org-left">Valeur déc.</td>
<td class="org-right">4</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">1/2</td>
<td class="org-right">1/4</td>
</tr>

<tr>
<td class="org-left">Bit</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgd7acbc6" class="outline-3">
<h3 id="orgd7acbc6"><span class="section-number-3">1.8.</span> Opérations arithmétiques binaires</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Il est possible de transposer les opérations arithmétiques habituelles
pour effectuer différentes opération arithmétiques: addition,
soustraction, multiplication, division, avec des nombres
binaires. Nous verrons plus loin comment ces opérations s'exécutent
lorsque nous aurons établi les formes d'encodages binaires qui seront
utilisés pour les nombres, notamment la représentation des nombres
signés.
</p>
</div>

<div id="outline-container-org0f5e2b8" class="outline-4">
<h4 id="org0f5e2b8"><span class="section-number-4">1.8.1.</span> Multiplication et division par deux</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
Pour multiplier un nombre binaire non signé par deux, il suffit de
décaler tous ses bits d'une position vers la gauche. Si le nombre est
entier, on devra insérer un zéro à la position zéro. Si le nombre est
fractionnaire, le bit le plus significatif de la partie fractionnaire se
retrouvera à la position zéro.
</p>

<p>
\[ (10011)2 \times 2 = (100110)2 \]
</p>

<p>
\[ (100,11)2 \times 2 = (1001,1)2 \]
</p>

<p>
Pour diviser un nombre binaire par deux, il suffit de décaler tous ses
bits d'une position vers la droite. Une division fractionnaire
produira possiblement un nombre fractionnaire, comme dans l'exemple
suivant.
</p>
</div>

<ol class="org-ol">
<li><a id="org5768ebd"></a>Division fractionnaire<br />
<div class="outline-text-5" id="text-1-8-1-1">
<p>
\[ (10011)2 \div 2 = (1001,1)2 \]
</p>
</div>
</li>

<li><a id="org21e9658"></a>Division entière<br />
<div class="outline-text-5" id="text-1-8-1-2">
<p>
Pour une division entière (sans fraction), on éliminera le bit qui
aurait été placé après la virgule.
</p>

<p>
\[ (10011)2 \div 2 = (1001)2 \]
</p>

<p>
Il est évident de généraliser ces opérations pour les multiplications
ou divisions par des puissances de 2: par 4, 8, 16, etc.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgd25bf51" class="outline-3">
<h3 id="orgd25bf51"><span class="section-number-3">1.9.</span> Compléments de nombres</h3>
<div class="outline-text-3" id="text-1-9">
<p>
Les compléments de nombres jouent un rôle dans la simplification de
certaines opérations mathématiques et logiques. Dans un système de
numération de base \(b\), on considère deux types de compléments: le
complément à \(b\) et le complément à \(b-1\). Pour la base dix, nous
aurons donc le complément à dix et le complément à neuf. Pour les
nombres binaires (base 2), on aura le complément à deux et le
complément à un.  Pour évaluer les compléments d'un nombre, on doit
tenir compte du nombre de chiffres que comporte ce nombre.
</p>
</div>

<div id="outline-container-org186e94b" class="outline-4">
<h4 id="org186e94b"><span class="section-number-4">1.9.1.</span> Complément à neuf et complément à un</h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
Soit un nombre entier \(N\) en base \(b\) constitué de \(n\) chiffres. Le
complément à \(b-1\) de \(N\) est \((b^n-1)-N\).
</p>

<p>
Par exemple, en base \(b=10\), le complément à neuf pour le nombre décimal
\(N = 4576\) formé de \(n=4\) chiffres sera \((b^n-1)-N = (10^4 -1) -
4576 = 5424\).
</p>

<p>
En base \(b=2\), le complément à un pour le nombre binaire \(N =
(10011)2 = (19)10\) formé de \(n=5\) bits sera \((b^n-1)-N = (2^5
-1) - 19 = 12\) ce qui donne en binaire: \((12)10 = (1100)2\).
</p>

<p>
On peut vérifier qu'il est très facile, en binaire, de déterminer le
complément à un, sans effectuer de calculs, en inversant simplement
chacun des bits de la représentation binaire du nombre à
complémenter. Ainsi, avec notre exemple, on trouve:
</p>

<p>
\[ 10011 \]
</p>

<p>
\[ 01100 \]
</p>

<p>
Remarquons ici un zéro non significatif comme premier bit à gauche.
</p>
</div>
</div>

<div id="outline-container-orgd7e5f38" class="outline-4">
<h4 id="orgd7e5f38"><span class="section-number-4">1.9.2.</span> Complément à dix et complément à deux</h4>
<div class="outline-text-4" id="text-1-9-2">
<p>
Le complément à \(b\) de l'entier \(N\) s'évalue comme
\((b^n)-N\). Cela correspond à ajouter 1 au complément à \(b-1\).
</p>

<p>
Ainsi pour notre exemple précédent en base \(b=10\), le complément à
dix pour le nombre décimal \(N = 4576\) formé de \(n=4\) chiffres sera
\((b^n)-N = (10^4) - 4576 = 5425\).
</p>

<p>
Pour notre autre exemple, en base \(b=2\), le complément à deux pour
le nombre binaire \(N = (10011)2 = (19)10\) formé de \(n=5\) bits
sera \((b^n)-N = (2^5) - 19 = 13\) ce qui donne en binaire:
\((13)10 = (1101)2\).
</p>

<p>
L'évaluation directe à la main, sans calculs, du complément à deux est
également possible en suivant la démarche suivante:
</p>
<ol class="org-ol">
<li>On parcourt le nombre binaire initial à partir (à droite) du bit le moins
significatif, et on retranscrit les bits rencontrés jusqu'à
atteindre un premier bit 1, que l'on retranscrit également.</li>
<li>On continue la retranscription vers la gauche, en inversant cette
fois les bits subséquents.</li>
</ol>

<p>
Par exemple, pour (10110)2, on aura la démarche détaillée dans le
tableau <a href="#orgf09d573">8</a>. Les étapes sont numérotées selon la position
considérée, à partir de la droite.
</p>

<table id="orgf09d573" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 8 :</span> Étapes pour complément à deux</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Nombre</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Étape 0</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-left">Retranscrit</td>
</tr>

<tr>
<td class="org-left">Étape 1</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Retranscrit</td>
</tr>

<tr>
<td class="org-left">Étape 2</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Inversé</td>
</tr>

<tr>
<td class="org-left">Étape 3</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Inversé</td>
</tr>

<tr>
<td class="org-left">Étape 4</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Inversé</td>
</tr>
</tbody>
</table>

<p>
Pour une évaluation par un circuit, on commencera par déterminer le
complément à un par inversion et on lui additionnera 1 pour obtenir le
complément à deux.
</p>
</div>
</div>
</div>

<div id="outline-container-orgaa7d9cc" class="outline-3">
<h3 id="orgaa7d9cc"><span class="section-number-3">1.10.</span> Nombres signés et codage</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Représenter de nombres \(\geq 0\) en binaire est donc relativement
naturel. Dans l'optique où on voudra stocker ces nombres dans une
mémoire binaire numérique, il n'y a qu'à prévoir une taille suffisante
(en nombre de bits) pour pouvoir accommoder des nombres assez grands
pour l'application considérée. Avec \(n\) bits, il est possible de
représenter des entiers de 0 à \(2^n-1\) avec cette représentation
«naturelle».
</p>

<p>
Mais on peut se demander comment représenter des nombres négatifs,
c'est-à-dire \(< 0\). Une première observation est le fait que si on
considère des nombres positif <b>et</b> négatifs, on double en quelque
sorte la quantité de valeurs à représenter. Par exemple, il y a 21
nombres à représenter si on veut pouvoir utiliser les valeurs
comprises entre \(-10\) et \(+10\), comme on peut le voir dans le
tableau <a href="#org4ca0a40">9</a>.
</p>

<table id="org4ca0a40" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 9 :</span> Nombre de valeurs à représenter entre \(-10\) et \(+10\)</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Gamme</th>
<th scope="col" class="org-right">n. de valeurs</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">de -10 à -1</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">de 1 à 10</td>
<td class="org-right">10</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Total</td>
<td class="org-right">21</td>
</tr>
</tbody>
</table>

<p>
Nous devons donc nous assurer d'avoir autant de combinaisons de bits
qu'il sera nécessaire. La deuxième observation est qu'il faudra un
moyen de distinguer les nombres positifs des nombres négatifs. Si on
veut que cette distinction puisse se faire non seulement sur papier,
mais surtout lorsque les nombres seront stockés et manipulés dans un
système électronique, il faut définir un format binaire «tout compris»
qui permette de le faire.
</p>

<p>
Nous devons donc établir un <b>code</b>, c'est-à-dire, une <b>convention</b> qui
permettra de donner un sens à un groupe de bits. Le choix de la
convention devrait être guidé par les usages qui seront ultimement
faits des nombres qui seront représentés.
</p>

<p>
En fait, lorsque nous avons convenu (implicitement) de représenter des
nombres entiers en utilisant directement la conversion en base 2 des
nombres décimaux, nous avons établi un code de représentation, qui,
bien que naturel, n'en est pas moins une convention. Ici, nous devrons
formuler plus explicitement la convention qui sera utilisée pour
représenter les entier signés.
</p>

<p>
Une convention de représentation peut être établie totalement
arbitrairement, mais elle sera sans doute plus utile si elle peut
contribuer à faciliter des opérations courantes réalisées avec les
éléments à représenter. Puisqu'il est question ici de nombre entiers
signés, l'opération à considérer en priorité est l'addition. On
devrait aussi considérer les trois points suivants dans notre choix de
convention pour attribuer des codes binaires aux valeurs. (Pour
illustrer notre réflexion, nous allons considérer des nombre pouvant
être représentés par des codes binaires de quatre bits, ce qui permet
en théorie de représenter un total de 16 valeurs.)
</p>

<ol class="org-ol">
<li>Puisqu'il faudra partager notre ensemble de codes binaires en deux,
il serait logique de placer la représentation pour zéro au centre
de ce découpage.</li>

<li>Les codes binaires utilisés pour un nombre et pour son inverse
additif devraient être disposés symétriquement autour du code
utilisé pour représenter le zéro. Il est naturel de représenter la
valeur zéro avec le code 0000.</li>

<li>L'ordre des codes devrait correspondre à l'ordre des nombres. On
sait bien comment ordonner les nombres entiers, en passant des
nombres négatifs aux nombres positifs.</li>
</ol>

<p>
Quel ordre serait approprié pour les représentations (codes binaires)?
L'ordre naturel, du moins pour les nombres entiers positifs, serait de
passer de 0000 à 0001 à 0010, etc. Il faudra cependant limiter le
nombre de valeurs positives, car il faut réserver des codes pour les
valeurs négatives, et nous avons déjà utilisé un code pour le
zéro. Quel code binaire devrait-on placer juste avant le zéro, pour
représenter -1? Si on dispose l'ensemble des codes binaires entre 0000
et 1111 selon un cycle, tel qu'illustré sur la figure
<a href="#org456f967">1</a>, alors le code approprié pour -1 sera 1111. Et le
code pour -2 sera 1110. Un avantage de cette disposition est que, en
ajoutant 1 pour passer de -2 à -1, on parcourt le cycle dans le même
sens qu'en ajoutant 1 pour passer de 1 à 2.
</p>


<div id="org456f967" class="figure">
<p><img src="Images_png/cycle.png" alt="cycle.png" />
</p>
<p><span class="figure-number">Figure&nbsp;1&nbsp;: </span>Relations entre les codes dans l'assignation en complément à deux</p>
</div>

<p>
En suivant cette logique, on pourra, comme indiqué sur la figure,
assigner les codes dans les boîtes en ellipses, en jaune, à des
valeurs positives et les codes dans les boîtes en hexagones, en vert,
à des valeurs négatives. Si on assigne autant de valeur positives que
de valeurs négatives, un seul code binaire ne sera pas utilisable, le
code 1000, dans la boîte en losange. Tout mouvement selon le sens des
flèches (horaire) sur l'illustration correspond à une soustraction;
tout mouvement en sens inverse correspond à une addition. Les nombres
binaires seront ainsi symétriques par rapport à notre zéro.
</p>

<p>
Nous obtenons ainsi l'assignation du tableau <a href="#org0a3aeb4">10</a>.
</p>

<table id="org0a3aeb4" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 10 :</span> Assignation de codes aux nombres de 4 bits</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Code</th>
<th scope="col" class="org-right">Nombre</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1001</td>
<td class="org-right">-7</td>
</tr>

<tr>
<td class="org-right">1010</td>
<td class="org-right">-6</td>
</tr>

<tr>
<td class="org-right">1011</td>
<td class="org-right">-5</td>
</tr>

<tr>
<td class="org-right">1100</td>
<td class="org-right">-4</td>
</tr>

<tr>
<td class="org-right">1101</td>
<td class="org-right">-3</td>
</tr>

<tr>
<td class="org-right">1110</td>
<td class="org-right">-2</td>
</tr>

<tr>
<td class="org-right">1111</td>
<td class="org-right">-1</td>
</tr>

<tr>
<td class="org-right">0000</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0001</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0010</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">0011</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">0100</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">0101</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">0110</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">0111</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">1000</td>
<td class="org-right">aucun</td>
</tr>
</tbody>
</table>

<p>
Voici quelques observations importantes sur cette représentation.
</p>

<ol class="org-ol">
<li>Tous les codes des nombres négatifs ont le premier bit à gauche
(qui serait le bit le plus significatif) à la valeur 1, alors que
les autres ont codes ont la valeur 0. Ce bit peut ainsi servir
d'indicateur de signe, avec la convention habituelle qu'on ne met
pas de signe au zéro. On parlera ainsi de <b>bit de signe</b> pour
dénoter ce bit, qui ne contribue pas à la grandeur (en valeur
absolue) du nombre.</li>

<li>L'inverse additif d'un nombre \(n\), c'est-à-dire \(-n\), est
représenté par le <b>complément à deux</b> du nombre. Ceci signifie que
pour trouver l'inverse additif d'un nombre, il suffit de calculer
son complément à deux. Le complément à deux du complément à deux nous
re-donnera le nombre initial, conformément à la double négation
\(--n = n\).</li>
</ol>

<p>
Il existe d'autres conventions pour la représentation de nombres
signés, comme par exemple, la représentation signe+magnitude, mais la
représentation en complément à deux est de loin la plus utilisée.
</p>
</div>
</div>

<div id="outline-container-org19865f6" class="outline-3">
<h3 id="org19865f6"><span class="section-number-3">1.11.</span> Opérations arithmétiques binaires</h3>
<div class="outline-text-3" id="text-1-11">
</div>
<div id="outline-container-org0e2985e" class="outline-4">
<h4 id="org0e2985e"><span class="section-number-4">1.11.1.</span> Addition de nombres non signés</h4>
<div class="outline-text-4" id="text-1-11-1">
<p>
En transposant les opérations classiques pour effectuer à la main des
additions ou des soustractions, il est possible d'effectuer des
calculs avec des nombres binaires. Additionner des nombres entier non
signés ne pose pas de difficultés particulières.
</p>

<p>
On suppose deux nombre entiers binaires non signés \(A\) et \(B\)
représentés en utilisant le même nombre de bits (si un nombre est plus
petit, on ajoutera des 0 non significatifs à gauche pour compléter la
représentation). Lorsqu'on effectue l'opération bit par bit, en
partant de la position la moins significative, on peut utiliser la
table d'addition suivante. À la position \(i\), on a trois entrées à
prendre en considération: \(A_{i}\) et \(B_{i}\), les bits des nombres
à additionner et \(R_{i-1}\), la retenue provenant de la position
\(i-1\). En sortie, on a la somme \(S_{i}\) et la retenue \(R_{i}\).
</p>

<table id="orgeb13317" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 11 :</span> Tableau de vérité pour l'additionneur binaire</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(A_{i}\)</th>
<th scope="col" class="org-right">\(B_{i}\)</th>
<th scope="col" class="org-right">\(R_{i-1}\)</th>
<th scope="col" class="org-right">\(R_{i}\)</th>
<th scope="col" class="org-right">\(S_{i}\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>


<p>
Exemple:
</p>

<p>
A: 101110001
B: 001111001
S: 111101010
R: 001110001
</p>

<p>
S'il y a une retenue non nulle à la suite de l'addition à la position
la plus significative, il y a un <b>débordement</b>, car le résultat est trop
grand pour être représenté avec le nombre de bits initial.
</p>
</div>
</div>

<div id="outline-container-org67b621b" class="outline-4">
<h4 id="org67b621b"><span class="section-number-4">1.11.2.</span> Addition de nombres signés</h4>
<div class="outline-text-4" id="text-1-11-2">
<p>
L'addition de nombre signés codés avec la représentation en complément
à deux est nettement avantageuse. Il suffit d’additionner les deux
nombres comme s'il s'agissait de nombre non signés, en incluant les
bits de signe dans le calcul. La retenue qui émane de la position la
plus significative ne doit pas être prise en compte. 
</p>

<p>
Exemple 1:
</p>

<p>
Additionnons \(A=-2\) et \(B=4\), représentés respectivement (1110)2 et (0100)2.
</p>

<p>
A: 1110
B: 0100
S: 0010
R: 1100
</p>

<p>
qui nous donne bien le résultat escompté: S = (0010)2 = (2)10.
</p>

<p>
Exemple 2:
</p>

<p>
Additionnons \(A=3\) et \(B=-5\), représentés respectivement (0011)2 et (1011)2.
</p>

<p>
A: 0011
B: 1011
S: 1110
R: 0011
</p>

<p>
qui nous donne bien le résultat escompté: S = (1110)2 = (-2)10.
</p>

<p>
On peut vérifier facilement qu'additionner un nombre avec son
complément à deux donne toujours zéro, ce qui correspond à faire \(-n + n
= 0\).
</p>

<p>
Comme avec l'addition de nombre entiers non signés, il faudra se
préoccuper des débordements qui peuvent survenir parce que la capacité
de représentation est limitée par la taille (en nombre de bits) des
codes binaires utilisés.
</p>
</div>
</div>

<div id="outline-container-org2e18d47" class="outline-4">
<h4 id="org2e18d47"><span class="section-number-4">1.11.3.</span> Soustraction de nombres signés</h4>
<div class="outline-text-4" id="text-1-11-3">
<p>
La soustraction s'effectue en faisant \(A - B = A + (-B)\), comme suit:
</p>

<ol class="org-ol">
<li>On détermine le complément à deux du nombre à soustraire (ici, \(B\)).</li>
<li>On additionne ce complément à deux au nombre duquel on soustrait  (ici, \(A\)). La
retenue qui émane de la position la plus significative ne doit pas
être prise en compte.</li>
</ol>

<p>
Le résultat s'interprétera comme un nombre signé en complément à deux. 
</p>
</div>
</div>

<div id="outline-container-org5d48eb7" class="outline-4">
<h4 id="org5d48eb7"><span class="section-number-4">1.11.4.</span> Extension de signe</h4>
<div class="outline-text-4" id="text-1-11-4">
<p>
Dans la représentation des nombres signés en complément à deux, le bit
de signe (bit le plus à gauche) est un indication directe du signe
d'un nombre. Si on change la taille des nombres, c'est-à-dire, le nombre
de bits utilisés au total pour la représentation, il faut une
opération spécifique pour préserver l'encodage en complément à deux. 
</p>

<p>
Considérons par exemple le nombre 5, représenté d'abord sur quatre
bits et ensuite sur huit bits. On a pour 5 
</p>

<p>
\[ 0101 \]
</p>

<p>
ou encore 
</p>

<p>
\[ 00000101 \]
</p>

<p>
Quand on compare ces deux représentations, on observe que: 
</p>

<ul class="org-ul">
<li>elles se terminent de la même façon, avec les trois bits 101 qui
représentent la grandeur du nombre;</li>
<li>le bit le plus à gauche est 0 dans les deux cas (même signe);</li>
<li>dans la représentation sur huit bits, il y a des bits 0 entre le bit
de signe et les trois derniers bits.</li>
</ul>

<p>
Considérons maintenant un nombre négatif, le nombre -5, représenté
d'abord sur quatre bits et ensuite sur huit bits. Le complément à deux
de 5 = (0101)2 est
</p>

<p>
\[ 1011 \]
</p>

<p>
alors que le complément à deux de 5 = (00000101)2 est
</p>

<p>
\[ 11111011 \]
</p>

<p>
Quand on compare ces deux représentations, on observe que: 
</p>

<ul class="org-ul">
<li>elles se terminent de la même façon, avec les trois bits 011;</li>
<li>le bit le plus à gauche est 1 dans les deux cas (même signe);</li>
<li>dans la représentation sur huit bits, il y a des bits 1 entre le bit
de signe et les trois derniers bits.</li>
</ul>

<p>
Ces constatations nous amènent à conclure que lorsqu'on augmente la
taille de représentation d'un nombre signé, il faut faire une
<b>extension de signe</b> pour intercaler les bonnes valeurs binaires entre
le bit de signe et les bits qui représentent la grandeur du
nombre. Pour un nombre positif, on doit intercaler des bits 0, alors
que pour un nombre négatif, on intercale des bits 1. On peut donc
énoncer la règle comme <i>on doit intercaler des bits dont la valeur est
la même que le bit de signe.</i>
</p>

<p>
Si, à l'inverse, on réduit la taille des nombres signés, on n'aura
qu'à supprimer des bits, tous égaux au bit de signe, entre le bit de
signe et ceux qui représentent la grandeur du nombre. Si les bits à
supprimer ne sont pas tous égaux au bit de signe, c'est une indication
que la réduction de taille n'est pas possible: la nouvelle taille est
insuffisante pour représenter les nombres correctement.
</p>
</div>
</div>
</div>


<div id="outline-container-org86d0578" class="outline-3">
<h3 id="org86d0578"><span class="section-number-3">1.12.</span> Codes binaires</h3>
<div class="outline-text-3" id="text-1-12">
<p>
Il n'y a pas que des nombres que l'on voudra représenter en
binaire. Il est maintenant le temps de définir ce qu'on appelle un
<b>code binaire</b>, car cette notion est au centre de tous les encodages
que nous aurons à utiliser.
</p>

<p>
Un code binaire sur \(n\) bits est typiquement une association entre,
d'une part, les éléments d'un ensemble que l'on cherche à représenter
et d’autre part, les différents groupes ou patrons possibles avec
\(n\) bits. On appelle parfois ces patrons des mots-code (ou par abus
de langage, des codes). Comme il y a \(2^n\) patrons de bits
différents, il est possible d'associer jusqu'à ce nombre
d'éléments.
</p>

<p>
Une règle, souvent implicite mais essentielle, est qu'<b>on
ne devrait associer qu'un seul élément à un patron de bits donné.</b>
Sinon, l'interprétation du code (le décodage) devient ambiguë. Selon
l'application, il n'est pas toujours nécessaire d'associer tous les
patrons de bits à des éléments. Par exemple, si on veut représenter
les chiffres décimaux, il est nécessaires de disposer d'au moins 10
patrons de bits, ce qui est possible avec \(n=4\). Puisque \(2^4 =
16\), il y aura \(16 - 10 = 6\) patrons de bits inutilisés.
</p>

<p>
La règle spécifique d'association peut être établie arbitrairement,
mais elle est souvent conçue en vue de respecter certaines propriétés
liées aux éléments à représenter ou à la configuration du code
lui-même. C'est ce qu'on a fait, par exemple, pour définir la
convention d'encodage des entiers par complément à deux.
</p>
</div>

<div id="outline-container-org1e0a140" class="outline-4">
<h4 id="org1e0a140"><span class="section-number-4">1.12.1.</span> Code Gray</h4>
<div class="outline-text-4" id="text-1-12-1">
<p>
Lorsqu'on utilise un code binaire pour représenter des valeurs
associées à des phénomènes physiques, il peut être opportun d’utiliser
un encodage dans lequel le nombre de changements de bits est minimal
lorsqu'on passe d'un patron de bits au suivant dans la séquence des
codes. Par exemple, si on cherche à encoder des positions d'un
interrupteur rotatif (comme pour encoder des angles), il est
préférable que lorsqu'on passe d'un position à la suivante en tournant
le commutateur, un seul bit ne change dans la sortie. Ainsi, une
erreur sur un bit n'introduit pas un gros changement dans
l'interprétation de la valeur encodée. Un code Gray permet d'atteindre
cet objectif.
</p>

<p>
Avec le code Gray du tableau <a href="#org1b7d07b">12</a>, on peut voir par exemple que la
transition entre les codes pour 7 et 8 n’entraîne qu'un changement sur
un bit, de 0110 à 1100. Avec un encodage classique basé sur les
entiers binaires, on aurait observé pour ce cas une transition entre
0111 et 1000, qui comporte quatre changements de valeurs de bits.
</p>

<table id="org1b7d07b" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 12 :</span> Code Gray à quatre bits</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Code Gray</th>
<th scope="col" class="org-right">Valeur</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0000</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0001</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0011</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">0010</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">0110</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">0111</td>
<td class="org-right">5</td>
</tr>

<tr>
<td class="org-right">0101</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">0100</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">1100</td>
<td class="org-right">8</td>
</tr>

<tr>
<td class="org-right">1101</td>
<td class="org-right">9</td>
</tr>

<tr>
<td class="org-right">1111</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-right">1110</td>
<td class="org-right">11</td>
</tr>

<tr>
<td class="org-right">1010</td>
<td class="org-right">12</td>
</tr>

<tr>
<td class="org-right">1011</td>
<td class="org-right">13</td>
</tr>

<tr>
<td class="org-right">1001</td>
<td class="org-right">14</td>
</tr>

<tr>
<td class="org-right">1000</td>
<td class="org-right">15</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-orgf97ffce" class="outline-4">
<h4 id="orgf97ffce"><span class="section-number-4">1.12.2.</span> Codes alphanumériques et autres</h4>
<div class="outline-text-4" id="text-1-12-2">
<p>
Vous rencontrerez sans doute plusieurs autres encodages courants,
comme par exemple pour encoder des caractères (code ASCII, codes UTF)
ou pour encoder uniquement des chiffre décimaux (code BCD). Une fois
qu'on a bien compris la règle d'encodage, il n'y a généralement pas de
difficultés à les utiliser.
</p>

<p>
Certains codes sont construits de manière à permettre d’identifier et
même, dans certains cas, de corriger des erreurs dans le stockage ou
la transmission des données encodées. Ces codes sont construits en
fonction de règles d'encodage, qui, lorsqu'elles ne sont pas
respectées, permettent de constater la présence d'erreurs.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd16ca91" class="outline-2">
<h2 id="orgd16ca91"><span class="section-number-2">2.</span> Logique binaire, fonctions logiques et algèbre de Boole</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgd4c38bc" class="outline-3">
<h3 id="orgd4c38bc"><span class="section-number-3">2.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>Situer les opérations de la logique binaire dans leur contexte algébrique</li>
<li>Être familier avec les postulats de l'algèbre de Boole, et les
principaux théorèmes</li>
<li>Pouvoir exprimer une fonction logique par un tableau de vérité</li>
<li>Pouvoir appliquer les théorèmes de DeMorgan</li>
<li>Pouvoir formuler une expression logique à partir d'un tableau de vérité</li>
<li>Pouvoir exprimer une fonction logique en <i>somme de produits</i>, ou en
<i>produit de sommes</i>, et pouvoir convertir d'une forme à l'autre</li>
</ul>
</div>
</div>

<div id="outline-container-org534227b" class="outline-3">
<h3 id="org534227b"><span class="section-number-3">2.2.</span> Logique binaire</h3>
<div class="outline-text-3" id="text-2-2">
<p>
La logique binaire associe une valeur de vérité à des variables, selon
une convention préétablie. Ces valeurs de vérité sont binaires, à
savoir, <b>vrai</b> ou <b>faux</b>. Pour représenter ces valeurs de vérité, on
peut utiliser un encodage binaire, comme par exemple
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Valeur de vérité</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">Valeur binaire</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Vrai</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Faux</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-org6dc7976" class="outline-4">
<h4 id="org6dc7976"><span class="section-number-4">2.2.1.</span> Variable binaire</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Une variable binaire, dénotée par une lettre, permet de désigner une
valeur binaire pouvant assumer une de deux valeurs possible, 0
ou 1. La variable est typiquement associée à une proposition, l'état
d'un élément ou toute autre condition pouvant admettre deux états
distincts. En assignant une valeur binaire à la variable, on définit
une valeur de vérité associée à cette variable, et ainsi à la
condition qu'elle représente. Par exemple, soit \(S\) une variable
binaire qui représente la proposition «le soleil est visible». Alors,
\(S=0\) peut s'interpréter comme «le soleil est visible est faux» ou
«le soleil n'est pas visible».
</p>
</div>
</div>

<div id="outline-container-org528d2e1" class="outline-4">
<h4 id="org528d2e1"><span class="section-number-4">2.2.2.</span> Opérations logiques</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Trois opérations logiques de base permettent d'agir sur des variables
binaires, de les combiner et de formuler des expressions logiques à
partir d'elles.
</p>

<ol class="org-ol">
<li>ET: cette opération est représentée (comme la multiplication) par
un point central ou par l'absence de signe d'opérateur entre les
arguments. Par exemple, \(x \cdot y\) ou \(x y\). La valeur de
l'expression est 1 si et seulement si toutes les variables ont la
valeur 1. Sinon, la valeur est 0.</li>
<li>OU: cette opération est représentée (comme l'addition) par un signe
+. Par exemple, \(x + y\). La valeur de l'expression est 1 si au
moins une des variables a la valeur 1. Si aucune des variables ne
vaut 1, la valeur de l'expression est 0.</li>
<li>NON: cette opération est représentée par un prime, comme par
exemple \(x^\prime\), ou par une barre au-dessus de la variable,
\(\overline{x}\).  L'opération NON renverse la valeur binaire de
son argument: si \(x =0\) alors \(x^ \prime = 1\); si \(x =1\)
alors \(x^ \prime = 0\). Cette opération de négation, est aussi
appelée complément, car complémenter une valeur binaire revient à
faire basculer sa valeur.</li>
</ol>
</div>
</div>

<div id="outline-container-org0d8a702" class="outline-4">
<h4 id="org0d8a702"><span class="section-number-4">2.2.3.</span> Expression logique</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
Une expression logique combine des variables logiques et des
opérations, et peut donc assumer une valeur binaire logique. Cette
valeur logique peut être assignée à une autre variable, en créant
ainsi une équation logique. Par exemple, \(z = x \cdot y\) signifie
que \(z\) assume la valeur de l'expression \(x \cdot y\). À partir des
valeurs logiques des variables (entrées) \(x\) et \(y\), on peut donc
déterminer la valeur logique de la sortie \(z\).
</p>
</div>
</div>

<div id="outline-container-orgcca80c5" class="outline-4">
<h4 id="orgcca80c5"><span class="section-number-4">2.2.4.</span> Tableaux de vérité</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
Une façon de décrire la valeur logique d'une variable de sortie en
fonction des valeurs possibles des variables d'entrée est au moyen
d'un tableau de vérité. Dans un tel tableau, il y a une ligne pour
chaque combinaison possible des valeurs d'entrée, et sur chaque ligne,
on indique la valeur de sortie correspondante. C'est en quelque sorte
une description en extension de la valeur de l'expression de sortie.
</p>

<p>
Voici par exemple les tableaux de vérité pour les opérations de base.
</p>

<p>
Opération ET:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(x \cdot y\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Opération OU:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(x + y\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Opération complément:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(x^{\prime}\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgc1c28dc" class="outline-3">
<h3 id="orgc1c28dc"><span class="section-number-3">2.3.</span> Formalisme mathématique</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Un formalisme mathématique, élaboré bien avant l'avènement des
circuits électroniques numériques, permet de formuler, analyser et
simplifier les expressions de la logique binaire. Il s'agit de
l'algèbre de Boole. 
</p>
</div>

<div id="outline-container-org23731ea" class="outline-4">
<h4 id="org23731ea"><span class="section-number-4">2.3.1.</span> Définitions</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
Une algèbre est un système mathématique, défini pour un ensemble
d'éléments auxquels sont associés un ensemble d'opérateurs et qui
respecte un jeu d'axiomes ou postulats. Une algèbre nécessite donc:
</p>

<ol class="org-ol">
<li>Un ensemble \(S\) d'éléments</li>

<li>Des opérateurs: \(\cdot\), \(\star\), \(+\)</li>

<li>L'application des opérateurs aux différents éléments doit respecter
un certain nombre de propriétés appelées postulats, comme par exemple:

<ul class="org-ul">
<li>Fermeture</li>

<li>Associativité</li>

<li>Commutativité</li>

<li>Existence d'élément identité</li>

<li>Existence d'élément inverse</li>

<li>Distributivité</li>
</ul></li>
</ol>

<p>
Selon le choix des postulats, on arrive à définir différents types de
systèmes algébriques. Par exemple, les nombres réels avec lequel nous
sommes familiers est un système algébrique d'un type appelé <b>corps</b>.
</p>
</div>
</div>
</div>

<div id="outline-container-org0a7e649" class="outline-3">
<h3 id="org0a7e649"><span class="section-number-3">2.4.</span> Algèbre de Boole</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Une algèbre de Boole est un type de système algébrique défini sur un
ensemble \(B\), muni de deux opérateurs dénotés \(+\) et \(\cdot\), et qui
respecte les postulats suivants<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup> (postulats de Huntington):
</p>

<ol class="org-ol">
<li>Fermeture: tout résultat d'une opération sur un élément de
l'ensemble donne un élément de l'ensemble.

<ol class="org-ol">
<li>&spades; Fermeture par rapport à \(+\).</li>

<li>&hearts; Fermeture par rapport à \(\cdot\).</li>
</ol></li>

<li>Éléments identité

<ol class="org-ol">
<li>&spades; Élément identité de \(+\), noté 0: on a \(x + 0 = 0 + x = x\).</li>

<li>&hearts; Élément identité de \(\cdot\), noté 1: on a \(x \cdot 1 = 1 \cdot x = x\).</li>
</ol></li>

<li>Commutativité

<ol class="org-ol">
<li>&spades; Commutativité par rapport à \(+\): on a \(x + y = y + x\).</li>

<li>&hearts; Commutativité par rapport à \(\cdot\): on a \(x \cdot y = y
        \cdot x\).</li>
</ol></li>

<li>Distributivité

<ol class="org-ol">
<li>&spades; \(\cdot\) est distributif sur \(+\): on a \(x \cdot (y + z)= (x \cdot y) +
        (x \cdot z)\).</li>

<li>&hearts; \(+\) est distributif sur \(\cdot\): on a \(x + (y \cdot z)= (x + y) \cdot
        (x + z)\).</li>
</ol></li>

<li>Pour chaque élément \(x \in B\), il existe un élément
\(x^{\prime} \in B\) (appelé complément de \(x\)) tel que

<ol class="org-ol">
<li>&spades; \(x + x^{\prime} = 1\).</li>

<li>&hearts; \(x \cdot x^{\prime} = 0\).</li>
</ol></li>

<li>Il existe au moins deux éléments \(x, y \in B\) tels que \(x \neq y\).</li>
</ol>

<p>
Observons des différences entre une algèbre de Boole et le corps des réels:
</p>

<ol class="org-ol">
<li>Il n'y a pas de loi d'associativité dans les postulats. On peut en
démontrer une, cependant.</li>

<li>L'opération \(+\) est distributive sur \(\cdot\).</li>

<li>Il n'y a pas d'inverse multiplicatif ni d'inverse additif, on ne
peut donc pas faire de soustraction ou de division.</li>

<li>Il y a un concept de complément.</li>

<li>L'ensemble d'éléments est différent. Nous utiliserons pour notre
part l'ensemble \(B: \{0, 1 \}\) pour notre algèbre de Boole.</li>
</ol>
</div>
</div>

<div id="outline-container-org94565e8" class="outline-3">
<h3 id="org94565e8"><span class="section-number-3">2.5.</span> Algèbre de Boole à deux valeurs</h3>
<div class="outline-text-3" id="text-2-5">
<p>
L'ensemble de définition: \(B : \{0, 1 \}\).
</p>

<p>
Opérateur \(\cdot\)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(x \cdot y\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Opérateur \(+\)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(x + y\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Règle de complémentation
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(x^{\prime}\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org2adf65a" class="outline-3">
<h3 id="org2adf65a"><span class="section-number-3">2.6.</span> Vérification des postulats</h3>
<div class="outline-text-3" id="text-2-6">
<ol class="org-ol">
<li>La fermeture est évidente (en regardant les tableaux des opérations).</li>

<li><p>
En observant les tableaux de vérité, on constate que
</p>

<ol class="org-ol">
<li>\(0 + 0 = 0\), \(0 + 1 = 1 + 0 = 1\)</li>

<li>\(1 \cdot 1 = 1\), \(0 \cdot 1 = 1 \cdot 0 = 0\)</li>
</ol>

<p>
ce qui définit les deux éléments identité: 0 pour \(+\) et 1 pour  \(\cdot\).
</p></li>

<li>La commutativité des lois est évidente: les tableaux sont
symétriques.</li>

<li>Les lois de distributivité se démontrent aisément en établissant des
tables de vérité pour les différentes valeurs de \(x, y\) et \(z\).</li>

<li>Par le tableau de complément, on vérifie que

<ol class="org-ol">
<li>\(x + x^{\prime} = 1\), car \(0 + 0^{\prime} = 0 + 1 = 1\) et \(1 +
        1^{\prime} = 1+ 0 = 1\)</li>

<li>\(x \cdot x^{\prime} = 0\) car \(0 \cdot 0^{\prime} = 0 \cdot 1 =
        0\) et \(1 \cdot 1^{\prime} = 1 \cdot 0 = 0\).</li>
</ol></li>

<li>Le postulat 6 est vérifié car il y a deux éléments distincts: 0 et 1.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orga946858" class="outline-2">
<h2 id="orga946858"><span class="section-number-2">3.</span> Théorèmes et propriétés</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgc762e8d" class="outline-3">
<h3 id="orgc762e8d"><span class="section-number-3">3.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Bien saisir les relations de dualité entre les opérations</li>
<li>Connaître les principaux théorèmes de l'algèbre de Boole et pouvoir
les appliquer correctement</li>
<li>Pouvoir passer d'une version d'un théorème à sa version duale</li>
<li>Connaître les autres fonctions logiques importantes</li>
<li>Pouvoir construire un tableau de vérité</li>
</ul>
</div>
</div>

<div id="outline-container-org18dc2c4" class="outline-3">
<h3 id="org18dc2c4"><span class="section-number-3">3.2.</span> Dualité</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Les postulats ont été formulés en paires, identifiés par &spades; et
&hearts;. En interchangeant les opérateurs et les éléments identité, on
transforme un postulat de forme &spades; en un postulat de forme
&hearts;. C'est le principe de <b>dualité</b>. Ainsi, n'importe quelle
expression algébrique demeurera valide si les opérateurs et les
valeurs d'éléments identité sont interchangés.
</p>

<p>
Puisque notre algèbre ne comporte que deux éléments, les deux éléments
identité sont en fait les deux seuls éléments, 0 et 1. On obtient donc
le dual d'une expression en changeant les 0 pour des 1, les 1 pour des
0 et les ET pour des OU, les OU pour des ET.
</p>
</div>
</div>

<div id="outline-container-org34624b3" class="outline-3">
<h3 id="org34624b3"><span class="section-number-3">3.3.</span> Théorèmes de base</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Le tableau <a href="#org8543738">13</a> résume les postulats et théorèmes de base de
notre algèbre. On présente en parallèle chaque version et sa version
duale.
</p>

<table id="org8543738" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 13 :</span> Théorèmes de l'algèbre de Boole</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Version  &spades;</th>
<th scope="col" class="org-left">Version  &hearts;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Postulat 2</td>
<td class="org-left">\(x+0=x\)</td>
<td class="org-left">\(x \cdot 1 = x\)</td>
</tr>

<tr>
<td class="org-left">Postulat 5</td>
<td class="org-left">\(x+x^{\prime} = 1\)</td>
<td class="org-left">\(x \cdot x^{\prime} = 0\)</td>
</tr>

<tr>
<td class="org-left">Theorème 1</td>
<td class="org-left">\(x + x = x\)</td>
<td class="org-left">\(x \cdot x = x\)</td>
</tr>

<tr>
<td class="org-left">Theorème 2</td>
<td class="org-left">\(x + 1 = 1\)</td>
<td class="org-left">\(x \cdot 0 = 0\)</td>
</tr>

<tr>
<td class="org-left">Theorème 3</td>
<td class="org-left">\((x^{\prime})^{\prime} = x\)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Postulat 3</td>
<td class="org-left">\(x + y = y + x\)</td>
<td class="org-left">\(xy = yx\)</td>
</tr>

<tr>
<td class="org-left">Theorème 4</td>
<td class="org-left">\(x + (y + z) = (x + y ) + z\)</td>
<td class="org-left">\(x(yz) = (xy)z\)</td>
</tr>

<tr>
<td class="org-left">Postulat 4</td>
<td class="org-left">\(x(y+z) = xy + xz\)</td>
<td class="org-left">\(x + yz = (x+y)(x+z)\)</td>
</tr>

<tr>
<td class="org-left">Theorème 5</td>
<td class="org-left">\((x + y)^{\prime} = x^{\prime} y^{\prime}\)</td>
<td class="org-left">\((xy)^{\prime} = x^{\prime} + y^{\prime}\)</td>
</tr>

<tr>
<td class="org-left">Theorème 6</td>
<td class="org-left">\(x + xy = x\)</td>
<td class="org-left">\(x(x+y) = x\)</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgfacea77" class="outline-4">
<h4 id="orgfacea77"><span class="section-number-4">3.3.1.</span> Autres fonctions logiques</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
Nous avons vu que les opérateurs logiques ET, OU et NON, qu'on peut
aussi appeler fonctions logiques, sont à la base même de la définition
de notre algèbre de Boole. Il est possible de concevoir d'autres
fonctions logiques qui vont s'avérer utiles pour la formulation, la
conception et la réalisation de systèmes logiques. Voici quelques unes
des plus souvent utilisées.
</p>
</div>

<ol class="org-ol">
<li><a id="org86e9698"></a>Fonction NON-ET<br />
<div class="outline-text-5" id="text-3-3-1-1">
<p>
La fonction NON-ET, souvent désignée NAND, est obtenue en
complémentant la sortie d'une fonction ET: \((x \cdot y)^\prime\).
</p>

<table id="org4c43add" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 14 :</span> Tableau de vérité de la fonction NON-ET</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\((x \cdot y)^\prime\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org1fe2290"></a>Fonction NON-OU (NOR)<br />
<div class="outline-text-5" id="text-3-3-1-2">
<p>
La fonction NON-OU, souvent désignée NOR, est obtenue en complémentant
la sortie d'une fonction OU: \((x + y)^\prime\).
</p>

<table id="org65c1ba8" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 15 :</span> Tableau de vérité de la fonction NON-OU</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\((x + y)^\prime\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="org6552371"></a>Fonction OU-exclusif (XOR)<br />
<div class="outline-text-5" id="text-3-3-1-3">
<p>
La fonction OU-exclusif, souvent désignée XOR, est obtenue en évaluant
\(x \cdot y^\prime + x^\prime \cdot y\). La sortie est 1 seulement si
une seule des entrées est 1. On verra plus loin que cette fonction
joue un rôle important dans la formulation d'un additionneur.
</p>

<table id="orgfd17abf" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 16 :</span> Tableau de vérité de la fonction OU-exclusif</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\((x \cdot y^\prime + x^\prime \cdot y)\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
</div>
</li>
</ol>
</div>

<div id="outline-container-org59e35e0" class="outline-4">
<h4 id="org59e35e0"><span class="section-number-4">3.3.2.</span> Fonctions de plusieurs entrées</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
La plupart des fonctions logiques simples peuvent naturellement se
formuler en fonction de plus de deux entrées. Par exemple, \(a \cdot b
\cdot c\) nous donne une fonction ET à trois entrées, et on peut
facilement imaginer des fonctions ET ou des fonctions OU avec encore
plus d'entrées.
</p>
</div>
</div>

<div id="outline-container-orge219f72" class="outline-4">
<h4 id="orge219f72"><span class="section-number-4">3.3.3.</span> Expressions et fonctions binaires</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
Une fonction binaire peut être décrite par une expression algébrique
Booléenne. Selon les valeurs des variables, la valeur de l'expression
Booléenne détermine la valeur de la fonction. Par exemple, \(F_1\) est
une fonction de trois entrées \(a\) \(b\) et \(c\) définie par
l'expression
</p>

<p>
\[ F_1 = a + b \cdot c^\prime \]
</p>

<p>
La précédence des opération dans les expressions algébriques est (1)
parenthèses, (2) NON, (3) ET, et (4) OU.
</p>

<p>
Il est possible de construire le tableau de vérité pour \(F_1\) en
évaluant la fonction pour les \(2^3 = 8\) combinaisons d'entrées
possibles, comme dans le tableau <a href="#orgc65a594">17</a>.
</p>

<table id="orgc65a594" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 17 :</span> Fonction de trois variables</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(a\)</th>
<th scope="col" class="org-right">\(b\)</th>
<th scope="col" class="org-right">\(c\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(F_1\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
En général, pour une fonction à \(n\) entrées, le tableau de vérité
comportera \(2^n\) lignes.
</p>
</div>
</div>
</div>

<div id="outline-container-org8f74cd1" class="outline-3">
<h3 id="org8f74cd1"><span class="section-number-3">3.4.</span> Théorèmes de DeMorgan</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Le complément d'une fonction \(F\), \(F^\prime\), s'obtient en
remplaçant tous les 0 par des 1 et tous les 1 par des 0 dans les
valeurs de la fonction. Par exemple, en complémentant ainsi les
valeurs dans le tableau de vérité, on effectue ce changement.
</p>

<p>
On peut aussi effectuer ce changement en appliquant les théorèmes de
DeMorgan (Théorème 5 &spades; et &hearts; du tableau <a href="#org8543738">13</a>) qui
peuvent se généraliser à plus de deux variables.
</p>
</div>
</div>
</div>

<div id="outline-container-org1b43a41" class="outline-2">
<h2 id="org1b43a41"><span class="section-number-2">4.</span> Portes logiques</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org3cb0589" class="outline-3">
<h3 id="org3cb0589"><span class="section-number-3">4.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>Être familier avec les symboles usuels des portes logiques</li>
<li>Être familier avec les conventions et règles de dessin de schémas
logiques</li>
<li>Faire la différence entre niveau de signal et valeur logique</li>
<li>Pouvoir expliquer les différences entre le fonctionnement idéalisé
et la réalité physique des portes logiques</li>
</ul>
</div>
</div>

<div id="outline-container-orge674202" class="outline-3">
<h3 id="orge674202"><span class="section-number-3">4.2.</span> Niveaux logiques</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Une porte logique est un dispositif électronique qui implémente une
fonction logique en agissant sur des signaux électriques selon une
convention préétablie. En général, on établit des valeurs binaires en
se basant sur la tension des signaux, en définissant une
correspondance entre des gammes de tensions et les valeurs logiques 0
et 1. Par exemple, pour une tension d'alimentation \(V_{DD}\), on
pourrait avoir les correspondances suivantes:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Gamme de tensions</th>
<th scope="col" class="org-left">Niveau</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">de 0 à  \(V_{DD}/3\)</td>
<td class="org-left">Niveau bas</td>
</tr>

<tr>
<td class="org-left">de \(2V_{DD}/3\) à  \(V_{DD}\)</td>
<td class="org-left">Niveau haut</td>
</tr>
</tbody>
</table>

<p>
Les portes logiques sont manufacturées selon différents standards
technologiques qu'on appelle familièrement des <b>familles logiques</b>. Au
sein d'une même famille, les portes respectent les mêmes références de
niveaux pour pouvoir fonctionner ensemble adéquatement. Une porte peut
comporter une ou plusieurs entrées et agit généralement sur une seule
sortie.
</p>
</div>
</div>

<div id="outline-container-org988dcbc" class="outline-3">
<h3 id="org988dcbc"><span class="section-number-3">4.3.</span> Logique négative ou positive</h3>
<div class="outline-text-3" id="text-4-3">
<p>
On associe ensuite une valeur binaire à chacun des niveaux selon une
certaine convention, par exemple:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Niveau</th>
<th scope="col" class="org-right">Valeur logique</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Niveau bas</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">Niveau haut</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
<p>
qui correspond à une logique positive. La convention inverse nous
donne la logique négative.
</p>

<p>
Certains signaux seront considérés comme actifs lorsque leur niveau
logique sera 0. On parlera alors de signaux <b>actifs bas</b>. La
convention implicite est généralement que les signaux sont <b>actifs
haut</b>.
</p>
</div>
</div>

<div id="outline-container-org9a7ced1" class="outline-3">
<h3 id="org9a7ced1"><span class="section-number-3">4.4.</span> Symboles</h3>
<div class="outline-text-3" id="text-4-4">
<p>
On a défini des symboles pour représenter graphiquement les portes
logiques courantes. Dans un schéma logique, les portes sont
interconnectées entre-elles au moyen de symboles de conducteurs
(fils) qui permettent d'acheminer les valeurs logiques d'une porte à
l'autre.
</p>
</div>

<div id="outline-container-orgc7243c2" class="outline-4">
<h4 id="orgc7243c2"><span class="section-number-4">4.4.1.</span> Porte ET</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
À deux entrées \(S =  A \cdot B\)
</p>


<div id="orgc3b3208" class="figure">
<p><img src="Images_svg/and_logique.svg" alt="and_logique.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;2&nbsp;: </span>Porte ET à deux entrées</p>
</div>

<p>
Les portes qui réalisent des fonctions qui sont associative et
commutatives peuvent aussi se définir avec plus de deux entrées. C'est
le cas avec les fonctions ET et OU.
</p>

<p>
À trois entrées \(S =  A \cdot B \cdot C\)
</p>


<div id="org674b338" class="figure">
<p><img src="Images_svg/and3_logique.svg" alt="and3_logique.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;3&nbsp;: </span>Porte ET à trois entrées</p>
</div>
</div>
</div>

<div id="outline-container-orgb5d1d35" class="outline-4">
<h4 id="orgb5d1d35"><span class="section-number-4">4.4.2.</span> Porte OU</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
À deux entrées \(S =  A + B\)
</p>


<div id="org79479e2" class="figure">
<p><img src="Images_svg/or_logique.svg" alt="or_logique.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;4&nbsp;: </span>Porte OU à deux entrées</p>
</div>
</div>
</div>

<div id="outline-container-org6a98bb7" class="outline-4">
<h4 id="org6a98bb7"><span class="section-number-4">4.4.3.</span> Porte inverseur</h4>
<div class="outline-text-4" id="text-4-4-3">
<p>
L'opération NON qui consiste à complémenter une valeur binaire
s'effectue avec une porte appelée <b>inverseur</b>.  Il n'y a toujours
qu'une seule entrée. \(B = A^\prime\)
</p>


<div id="org3a3eef1" class="figure">
<p><img src="Images_svg/not_logique.svg" alt="not_logique.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;5&nbsp;: </span>Porte inverseur</p>
</div>
</div>
</div>

<div id="outline-container-org9b52782" class="outline-4">
<h4 id="org9b52782"><span class="section-number-4">4.4.4.</span> Porte NON-OU (NOR)</h4>
<div class="outline-text-4" id="text-4-4-4">

<div id="org0d8a3bb" class="figure">
<p><img src="Images_svg/nor_logique.svg" alt="nor_logique.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;6&nbsp;: </span>Porte NOR à deux entrées</p>
</div>
</div>
</div>

<div id="outline-container-org7e5a443" class="outline-4">
<h4 id="org7e5a443"><span class="section-number-4">4.4.5.</span> Porte NON-ET (NAND) et NON-OU (NOR)</h4>
<div class="outline-text-4" id="text-4-4-5">
<p>
Les fonctions NAND et NOR ne sont pas associatives. Par exemple,
</p>

<p>
\[
(x \operatorname{Nor} y) \operatorname{Nor} z \neq x \operatorname{Nor} (y \operatorname{Nor} z) 
\]
</p>

<p>
On peut néanmoins définir des versions à plusieurs entrées de ces
fonctions en ajustant la priorité d'évaluation. Pour une porte NOR à
trois entrées, on fera \((A + B + C)^\prime\).
</p>

<p>
Pour une porte NAND à trois entrées, on fera \(S = (A \cdot B \cdot
C)^\prime\).
</p>


<div id="orgb18c026" class="figure">
<p><img src="Images_svg/nand3_logique.svg" alt="nand3_logique.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;7&nbsp;: </span>Porte NAND à trois entrées</p>
</div>
</div>
</div>

<div id="outline-container-org9f9e968" class="outline-4">
<h4 id="org9f9e968"><span class="section-number-4">4.4.6.</span> Entrées inversées</h4>
<div class="outline-text-4" id="text-4-4-6">
<p>
On utilise souvent l'élément symbolique qui est placé à la sortie de
l'inverseur (un petit cercle) pour indiquer l'inversion d'une entrée
ou d'une sortie d'une porte. C'est le cas à la sortie des portes NAND
et NOR comme on vient de le voir. Un autre exemple est la porte NAND
de la figure <a href="#org3ffda88">8</a>, où une des entrées est également
inversée. La porte évalue donc \(S =  (A^\prime \cdot B  \cdot C)^\prime\)
</p>


<div id="org3ffda88" class="figure">
<p><img src="Images_svg/nand3_logique_invin1.svg" alt="nand3_logique_invin1.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;8&nbsp;: </span>Porte NAND à trois entrées dont une inversée</p>
</div>
</div>
</div>

<div id="outline-container-orgfbd389b" class="outline-4">
<h4 id="orgfbd389b"><span class="section-number-4">4.4.7.</span> NAND et NOR, représentations équivalentes</h4>
<div class="outline-text-4" id="text-4-4-7">
<p>
En vertu du théorème de DeMorgan, on sait que \((x + y)^{\prime} =
x^{\prime} y^{\prime}\) et que \((xy)^{\prime} = x^{\prime} +
y^{\prime}\). On peut donc représenter les portes NAND et NOR de deux
façons équivalentes.
</p>


<div id="orgb53f231" class="figure">
<p><img src="Images_svg/NORequiv.svg" alt="NORequiv.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;9&nbsp;: </span>Deux représentations équivalentes pour une porte NOR</p>
</div>


<div id="org0f27a26" class="figure">
<p><img src="Images_svg/NANDequiv.svg" alt="NANDequiv.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;10&nbsp;: </span>Deux représentations équivalentes pour une porte NAND</p>
</div>
</div>
</div>

<div id="outline-container-org3dcd574" class="outline-4">
<h4 id="org3dcd574"><span class="section-number-4">4.4.8.</span> Porte OU-exclusif (XOR)</h4>
<div class="outline-text-4" id="text-4-4-8">
<p>
La porte XOR à deux entrées donne une sortie 1 seulement lorsque ses
deux entrées sont différentes. Il est possible de définir des portes
XOR à plus de deux entrées, mais il y a différentes interprétations de
ce qu'une telle porte devrait avoir comme comportement. De plus, comme
la réalisation pratique de cette fonction n'est pas aussi simple que
pour les autres fonctions, on se retrouve plus souvent qu'autrement à
devoir mettre des portes à deux entrées en cascade pour augmenter le
nombre d'entrées, ce qui rend moins intéressantes les portes XOR avec
entrées nombreuses.
</p>

<p>
\[ S= A \cdot B^\prime + A^\prime \cdot B \]  
</p>


<div id="org79541b4" class="figure">
<p><img src="Images_svg/exor_logique.svg" alt="exor_logique.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;11&nbsp;: </span>Porte XOR à deux entrées</p>
</div>
</div>
</div>

<div id="outline-container-orgead0a1e" class="outline-4">
<h4 id="orgead0a1e"><span class="section-number-4">4.4.9.</span> Porte NON-OU-exclusif ou Équivalence (XNOR)</h4>
<div class="outline-text-4" id="text-4-4-9">
<p>
La porte <b>Équivalence</b> produit une sortie 1 lorsque ses entrées ont la
même valeur (et sont donc équivalentes). Comme pour les portes XOR,
les portes XNOR à plus de trois entrées peuvent s'interpréter de
différentes façons.
</p>


<div id="org73786e8" class="figure">
<p><img src="Images_svg/xnor_logique.svg" alt="xnor_logique.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;12&nbsp;: </span>Porte XNOR</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga5d5685" class="outline-3">
<h3 id="orga5d5685"><span class="section-number-3">4.5.</span> Universalité des NAND et NOR</h3>
<div class="outline-text-3" id="text-4-5">
<p>
En faisant appel uniquement à des portes de type NAND ou NOR, il est
possible de réaliser n'importe quelle fonction logique, puisqu'il est
possible de réaliser les trois opérateurs de base.
</p>

<ol class="org-ol">
<li>Pour réaliser un inverseur, on utilise une porte NAND à une seule
entrée (ou dont toutes les entrées sont reliées ensemble).</li>
<li>Pour réaliser une porte ET, on fait suivre une porte NAND d'un
inverseur.</li>
<li>Pour réaliser une porte OU, on précède chaque entrée d'une porte
NAND d'un inverseur.</li>
</ol>

<p>
On verra plus loin qu'il est aussi possible de réaliser
avantageusement des fonctions quelconques avec des portes NAND en
exploitant la forme <i>somme de produits</i>.
</p>
</div>
</div>

<div id="outline-container-orgf88ed90" class="outline-3">
<h3 id="orgf88ed90"><span class="section-number-3">4.6.</span> Limites physiques</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Les portes logiques qu'on utilisera en pratique sont des dispositifs
électroniques dont le fonctionnement correspond, dans les grandes
lignes, aux comportements idéalisés des modèles abstraits de l'algèbre
de Boole. Mais il faut toujours garder à l'esprit que la
correspondance entre modèle et réalité physique n'est jamais
parfaite. En raffinant nos modèles pour y incorporer des
caractéristiques, limites ou contraintes appropriées, il sera possible
de mieux tenir compte de la réalité physique.
</p>
</div>

<div id="outline-container-orgd1752b9" class="outline-4">
<h4 id="orgd1752b9"><span class="section-number-4">4.6.1.</span> <i>Fan-out</i></h4>
<div class="outline-text-4" id="text-4-6-1">
<p>
Le <i>fan-out</i> d'une porte logique mesure sa capacité à commander
d'autres portes reliées à sa sortie. Puisque les portes sont des
dispositifs électroniques qui doivent faire circuler un certain
courant électrique pour concrétiser les niveaux de tensions qui
définissent leurs valeurs d'entrée et de sortie, il y a une limite
pratique à la capacité d'une porte de fournir le courant nécessaire
pour faire réagir la sortie des portes qu'elle devrait commander. Le
<i>fan-out</i> mesure cette limite, en nombre de portes à commander. Si on
connecte plus d'entrées à une sortie que sa valeur de <i>fan-out</i>, cette
sortie ne pourra pas atteindre le niveau de tension adéquat, et les
opérations logiques seront faussées.
</p>
</div>
</div>

<div id="outline-container-org0fe4f47" class="outline-4">
<h4 id="org0fe4f47"><span class="section-number-4">4.6.2.</span> Modèles de délai</h4>
<div class="outline-text-4" id="text-4-6-2">
<p>
Dans la mesure où on respecte ses contraintes d'utilisation, notamment
de <i>fan-out</i>, une porte logique se comporte globalement de la façon
attendue, étant donné sa fonction et les conventions de niveaux de
signal établies. Par exemple, le niveau signal à la sortie d'un
inverseur correspondra au niveau de signal attendu pour le complément
de la valeur logique à son entrée. Mais il faut garder à l'esprit que
les portes sont des dispositifs électroniques, et donc physiques,
sujets à des «imperfections» qui diffèrent du comportement idéalisé.
</p>

<p>
Une de ces «imperfections» dont on doit impérativement tenir compte
est le <b>délai de propagation</b> qui se manifeste comme un retard entre
le moment où le signal à l'entrée de la porte assume (se stabilise à)
son niveau de signal, et le moment où la sortie de la porte atteint
son niveau de signal attendu. C'est en quelque sorte le délai entre
une action à l'entrée et son effet sur la sortie. Ce délai limite la
vitesse à laquelle on peut utiliser notre circuit logique. Si on
essaie d'effectuer des transitions plus rapides que le délai, le
comportement ne sera plus conforme aux attentes de conception. On doit
donc respecter une vitesse de commutation maximale imposée par les
délais de propagation.
</p>

<p>
Le délai de propagation peut dépendre de plusieurs facteurs: la
famille logique, le type de porte, le sens de la transition, le
<i>fan-out</i> effectif, les caractéristiques d'interconnexions, etc. Pour
faciliter l'analyse, on fait appel à des modèles de délais plus ou
moins sophistiqués. Un modèle très simple consiste à supposer un délai
de propagation moyen, constant pour toutes les portes d'une famille
donnée. Un modèle un peu plus subtil pourrait prendre en compte des
délais de propagation moyens différents par types de portes. Le délai
de propagation moyen est une caractéristique clé qui différencies les
différentes familles logiques. Les délais sont typiquement de l'ordre
de nanosecondes, permettant des vitesse de commutation dans les
dizaines, centaines, voire, des milliers de MHz.
</p>

<p>
Lorsqu'un signal doit se propager à travers plusieurs portes, les
délais de propagation s'accumulent, limitant encore davantage la
vitesse de commutation de l'ensemble du circuit. La vitesse qui pourra
être atteinte pour l'ensemble d'un circuit sera typiquement déterminée
par le plus lent chemin en terme de temps de propagation.
</p>
</div>

<ol class="org-ol">
<li><a id="orgff6a005"></a>Modèles simples<br />
<div class="outline-text-5" id="text-4-6-2-1">
<p>
Considérons pour illustrer une porte ET à deux entrées \(S = A B\). 
Le modèle le plus simple suppose une porte idéale, sans aucun délai:
le chronogramme suivant montre la sortie qui commute immédiatement
lorsque les conditions d'entrée changent.
</p>


<div id="org5b1ab61" class="figure">
<p><img src="Images_svg/chronopasdelais.svg" alt="chronopasdelais.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;13&nbsp;: </span>Porte ET sans délai</p>
</div>
</div>

<ol class="org-ol">
<li><a id="org82c962c"></a>Modèle avec délai en sortie<br />
<div class="outline-text-6" id="text-4-6-2-1-1">
<p>
Le modèle avec délai en sortie consiste à considérer un délai fixe,
qui affecte la sortie de la porte: la commutation prend effet en
sortie après un délai \(t_p\).
</p>



<div id="org13dda7c" class="figure">
<p><img src="Images_svg/chrononodelaisortie.svg" alt="chrononodelaisortie.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;14&nbsp;: </span>Porte ET avec délai en sortie</p>
</div>
</div>
</li>

<li><a id="orgdae079e"></a>Modèle avec délai en entrée<br />
<div class="outline-text-6" id="text-4-6-2-1-2">
<p>
Le modèle avec délai en entrée est plus nuancé, car il permet de
spécifier un délai différent selon l'entrée qui entraîne le changement
à la sortie.
</p>


<div id="org5f7b170" class="figure">
<p><img src="Images_svg/chrononodelaientree.svg" alt="chrononodelaientree.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;15&nbsp;: </span>Porte ET avec délai aux entrées</p>
</div>
</div>
</li>

<li><a id="orgc503f0c"></a>Modèle combiné<br />
<div class="outline-text-6" id="text-4-6-2-1-3">
<p>
Le modèle combiné consiste à considérer des délais différents par
entrée, et en plus, un délai global en sortie.
</p>
</div>
</li>
</ol>
</li>

<li><a id="orgf1bda49"></a>Condition de course et aléas<br />
<div class="outline-text-5" id="text-4-6-2-2">
<p>
Un autre effet néfaste potentiel des délais à considérer est ce qu'on
appelle une <b>condition de course</b>. Considérons le circuit de la figure
<a href="#org5b1ab61">13</a>.  La sortie de la porte est \(s = a \cdot a^\prime\) qui
devrait normalement donner systématiquement 0. Mais le chemin menant
de l'entrée \(a\) à l'entrée du haut de la porte ET est plus court (en
termes de délais) que le chemin qui mène à l'entrée du bas. En effet,
le signal \(a^\prime\) est retardé d'un délai de propagation
\(t_{p1}\) par rapport à \(a\).
</p>


<div id="org913808c" class="figure">
<p><img src="Images_svg/course.svg" alt="course.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;16&nbsp;: </span>Cas à risque de condition de course</p>
</div>

<p>
En pratique, on pourrait observer un chronogramme qui s'apparente à
celui de la figure suivante (figure <a href="#orgf63a2e4">17</a>), où on voit
que les deux signaux à l'entrée de la porte ET sont simultanément
égaux à 1 pendant une courte période. Une courte impulsion 1 sera donc
générée sur le signal \(s\) en sortie de la porte ET, après le délai
de propagation \(t_{p2}\) de celle-ci. Cette impulsion, qui ne
correspond à rien selon la logique du circuit est appelé un <b>aléa</b> (ou
en anglais, <i>glitch</i>).
</p>


<div id="orgf63a2e4" class="figure">
<p><img src="Images_svg/chronocourse.svg" alt="chronocourse.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;17&nbsp;: </span>Chronogramme montrant une condition de course</p>
</div>

<p>
Ces aléas peuvent être la source de problèmes et de dysfonctionnements
qui sont parfois difficiles à diagnostiquer, et il faut vraiment s'en
méfier. Une telle impulsion, quasi imperceptible, pourrait par exemple
déclencher le basculement de la valeur d'une cellule mémoire plus loin
dans le circuit.
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org616ccda" class="outline-4">
<h4 id="org616ccda"><span class="section-number-4">4.6.3.</span> Porte tampon</h4>
<div class="outline-text-4" id="text-4-6-3">
<p>
La valeur binaire à la sortie d'une porte tampon est la même qu'à
l'entrée. La porte n'agit pas sur la valeur logique mais permet de
reconditionner le signal à son entrée pour le rendre, en sortie,
davantage conforme aux niveaux électriques de référence. Une porte
tampon est essentiellement utilisée pour renforcer et stabiliser le
niveau du signal. Une façon pratique de réaliser une porte tampon est
de placer deux inverseurs l'un à la suite de l'autre. L'utilisation de
portes tampon est un des moyens de s'assurer de respecter les
conditions de <i>fan-out</i>.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org2b169b4" class="outline-2">
<h2 id="org2b169b4"><span class="section-number-2">5.</span> Simplification logique</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org01a85c0" class="outline-3">
<h3 id="org01a85c0"><span class="section-number-3">5.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>Pouvoir formuler une expression logique en forme canonique <i>Produit
de sommes</i> ou <i>Somme de produits</i>, et convertir entre les deux formes</li>
<li>Pouvoir simplifier une expression au moyen d'un diagramme de
Karnaugh</li>
<li>Pouvoir simplifier une expression par la méthode Quine-McCluskey</li>
<li>Être familier avec les approches d'implémentation des fonctions
simplifiées</li>
</ul>
</div>
</div>


<div id="outline-container-orgb93ccde" class="outline-3">
<h3 id="orgb93ccde"><span class="section-number-3">5.2.</span> Expressions équivalentes</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Un des aspects ennuyeux avec les expressions logiques est que la
correspondance entre expression et fonction logique n'est pas
biunivoque: plusieurs expressions différentes peuvent correspondre à
une seule et même fonction. De plus, certaines des expressions
équivalentes peuvent être plus complexes que d'autres. Lorsque vient
le temps d'implémenter avec des portes une fonction logique, il est la
plupart du temps plus efficace d'implémenter selon une expression plus
simple, voir minimale. On doit donc considérer des approches
systématiques et efficaces pour simplifier les expressions logiques.
</p>

<p>
Quand une expression Booléenne est implémentée avec des portes
logiques, chaque terme nécessite une porte et chaque variable au sein
d'un terme correspond à une entrée de la porte. On appelle <b>littéral</b>
une variable qui apparaît dans un terme, sous forme complémentée ou
non. Par exemple, l'expression \(F = x^\prime y^\prime z + xz +
xy^\prime z\) compte huit littéraux. Si on réduit le nombre de
termes, le nombre de littéraux, ou les deux, on obtiendra une
expression qui sera plus simple à implémenter avec des portes.
</p>
</div>
</div>

<div id="outline-container-orgd20eaea" class="outline-3">
<h3 id="orgd20eaea"><span class="section-number-3">5.3.</span> Formes canoniques</h3>
<div class="outline-text-3" id="text-5-3">
</div>
<div id="outline-container-orgc0b0e43" class="outline-4">
<h4 id="orgc0b0e43"><span class="section-number-4">5.3.1.</span> Minterms et maxterms</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Dans une expression, une variable \(x\) peut apparaître telle qu'elle
\(x\) ou complémentée \(x^\prime\). Si on considère les combinaisons
possibles de deux variables via un opérateur ET, on a alors quatres
possibilités: \(x^\prime y^\prime, x^\prime y, x y^\prime,x
y\). Chacun de ces quatres termes s'appelle un <b>minterm</b>.
</p>

<p>
De façon équivalente (duale, en vérité), \(n\) variables reliées par
une fonction OU peuvent donner lieu à \(2^n\) termes distincts,
appelés <b>maxterms</b>. 
</p>

<p>
De façon générale, pour \(n\) variables, on aura \(2^n\) minterms ou
\(2^n\) maxterms différents possibles.
</p>

<p>
Pour étiqueter les différents minterms ou maxterms, on a établi une
convention de numérotation. Le numéro d'étiquette d'un minterm est
construit de la façon suivante. Une variable complémentée amène un bit
d'étiquette 0, une variable telle qu'elle amène un bit d'étiquette 1.
En ordonnant les bits selon l'ordre alphabétique des variables, on
obtient un vecteur de bits qui donnera le numéro à assigner au
minterm.  Par exemple, le minterm \(x y^\prime z\) donnera l'étiquette
101, donc le numéro de minterm (en équivalent décimal) 5.
</p>

<p>
La règle pour les maxterms est duale: une étiquette 0 pour une
variable telle qu'elle, et une étiquette 1 pour une variable
complémentée. Chaque maxterm est le complément du minterm
correspondant (de même numéro), et <i>vice versa</i>.
</p>

<p>
Dans le tableau <a href="#org94e5f2d">18</a>, on montre les symboles de la forme
\(m_j\) pour les mintems et \(M_j\) pour les maxterms, avec \(j\) qui
est l'équivalent décimal de la combinaison de bits correspondante.
</p>

<table id="org94e5f2d" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 18 :</span> Minterms et maxterms pour trois variables</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-right">\(z\)</th>
<th scope="col" class="org-left">Minterm</th>
<th scope="col" class="org-left">Symb.</th>
<th scope="col" class="org-left">Maxterm</th>
<th scope="col" class="org-left">Symb.</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">\(x^\prime y^\prime z^\prime\)</td>
<td class="org-left">\(m_0\)</td>
<td class="org-left">\(x+ y+ z\)</td>
<td class="org-left">\(M_0\)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">\(x^\prime y^\prime z\)</td>
<td class="org-left">\(m_1\)</td>
<td class="org-left">\(x+ y+ z^\prime\)</td>
<td class="org-left">\(M_1\)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">\(x^\prime y z^\prime\)</td>
<td class="org-left">\(m_2\)</td>
<td class="org-left">\(x+ y^\prime+ z\)</td>
<td class="org-left">\(M_2\)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">\(x^\prime y z\)</td>
<td class="org-left">\(m_3\)</td>
<td class="org-left">\(x+ y^\prime+ z^\prime\)</td>
<td class="org-left">\(M_3\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">\(x y^\prime z^\prime\)</td>
<td class="org-left">\(m_4\)</td>
<td class="org-left">\(x^\prime+ y+ z\)</td>
<td class="org-left">\(M_4\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">\(x y^\prime z\)</td>
<td class="org-left">\(m_5\)</td>
<td class="org-left">\(x^\prime+ y+ z^\prime\)</td>
<td class="org-left">\(M_5\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">\(x y z^\prime\)</td>
<td class="org-left">\(m_6\)</td>
<td class="org-left">\(x^\prime+ y^\prime+ z\)</td>
<td class="org-left">\(M_6\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">\(x y z\)</td>
<td class="org-left">\(m_7\)</td>
<td class="org-left">\(x^\prime + y^\prime+ z^\prime\)</td>
<td class="org-left">\(M_7\)</td>
</tr>
</tbody>
</table>

<p>
Pour la fonction \(F_1\) dont le tableau de vérité est le suivant: 
</p>

<table id="org5c82437" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 19 :</span> Fonction de trois variables</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-right">\(z\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(F_1\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
on peut donc écrire
</p>

<p>
\[ F_1 = x y^\prime
z^\prime + x y^\prime z^\prime + x y^\prime z + x y z^\prime + x y z =
m_2 + m_4 + m_5 + m_6 + m_7 \]
</p>

<p>
puisque ce sont les termes pour lesquels la fonction vaut 1. Cette
forme d'expression est une forme canonique appelée <i>somme de
produits</i>.
</p>

<p>
Pour simplifier la notation, on peut écrire de façon plus compacte  
</p>

<p>
\[F_1 = \sum (2, 4, 5, 6, 7)\]
</p>

<p>
où on ne met que les numéros des minterms participant à la somme.
</p>

<p>
Si on veut exprimer le complément d'une fonction, on peut lire dans le
tableau de vérité les combinaisons pour lesquelles la fonction
vaut 0. En prenant un minterm pour chaque combinaison où la fonction
vaut 0 et en faisant un OU de ces termes, on obtient une expression en
<i>somme de produits</i> pour le complément de la fonction. Ainsi, pour la
fonction \(F_1^\prime\), on a
</p>

<p>
\[ F_1^\prime = m_0 + m_1 + m_3 = x^\prime y^\prime z^\prime +
x^\prime y^\prime z + x^\prime y z \]
</p>

<p>
Si on complémente \(F_1^\prime\), on obtiendra naturellement
\(F_1\). En appliquant le théorème de DeMorgan à chaque terme, on
trouve
</p>

<p>
\(F_1 = (x+ y+ z)(x + y + z^\prime)(x + y^\prime + z^\prime) = M_0
\cdot M_1 \cdot M_3\)
</p>

<p>
Cette forme d'expression est aussi une forme canonique appelée
<i>produit de sommes</i>.
</p>

<p>
Pour simplifier la notation, on peut écrire de façon plus compacte  
</p>

<p>
\(F_1 = \prod (0,1,3)\)
</p>

<p>
où on ne met cette fois que les numéros des maxterms participant au
produit.
</p>
</div>
</div>

<div id="outline-container-orgd3a9880" class="outline-4">
<h4 id="orgd3a9880"><span class="section-number-4">5.3.2.</span> Somme de produits</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
Pour \(n\) variables binaires, on a \(2^n\) minterms différents
possibles. Les minterms qui participent à la somme dans l'expression
en forme canonique <i>somme de produits</i> sont ceux qui produisent un 1
dans le tableau de vérité de la fonction. Puisque la fonction peut
valoir 0 ou 1 pour chaque minterm, le nombre total de fonctions
différentes qui peuvent être définies avec \(n\) variables est de
\(2^{2^n}\).
</p>

<p>
Si on veut convertir en forme canonique <i>somme de produits</i> l'expression
pour une fonction qui ne serait pas sous cette forme, on commence par
faire l'expansion de l'expression en forme <i>somme de produits</i>. Ensuite,
on vérifie chaque terme pour voir si toutes les variables en font
partie. S'il manque une ou des variables, on peut faire un ET du
terme avec une expression du type \(x + x^\prime\) dans laquelle \(x\)
est une variable manquante. Ce ET ne change pas la valeur de la
fonction puisque \(x + x^\prime = 1\).
</p>

<p>
Évidemment, on peut toujours trouver la formulation en forme canonique
en se basant sur le tableau de vérité.
</p>
</div>
</div>

<div id="outline-container-org98d32a9" class="outline-4">
<h4 id="org98d32a9"><span class="section-number-4">5.3.3.</span> Produit de sommes</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
Si on veut convertir en forme canonique <i>produit de sommes</i> l'expression
pour une fonction qui ne serait pas sous cette forme, on commence par
faire l'expansion de l'expression en forme <i>produit de sommes</i>. On peut
avantageusement faire appel à la distributivité de \(+\) sur \(\cdot\)
pour ce faire. Ensuite, on vérifie chaque terme pour voir si toutes
les variables en font partie. S'il manque une ou des variables, on
peut faire un OU du terme avec une expression du type \(x \cdot
x^\prime\) dans laquelle \(x\) est une variable manquante. Ce OU ne
change pas la valeur de la fonction puisque \(x \cdot x^\prime = 0\).
</p>
</div>
</div>

<div id="outline-container-orgf8a195e" class="outline-4">
<h4 id="orgf8a195e"><span class="section-number-4">5.3.4.</span> Conversion entre formes canoniques</h4>
<div class="outline-text-4" id="text-5-3-4">
<p>
Prenons notre exemple précédent \(F_1 = \sum (2, 4, 5, 6, 7)\). On
sait que \(F_1^\prime = \sum (0,1,3)\). Si on prend le complément de
\(F_1^\prime\) par le théorème de DeMorgan, on obtient \(F_1 = (m_0 +
m_1 + m_3)^\prime = m_0^\prime \cdot m_1^\prime \cdot m_3^\prime = M_0
\cdot M_1 \cdot M_3 = \prod (0,1,3)\).
</p>

<p>
En effet, de minterm à maxterm, on a \(m_j^\prime = M_j\). Le maxterm
d'indice \(j\) est le complément du minterm de même indice \(j\), et
<i>vice versa</i>.
</p>
</div>
</div>

<div id="outline-container-org461ee82" class="outline-4">
<h4 id="org461ee82"><span class="section-number-4">5.3.5.</span> Formes standard</h4>
<div class="outline-text-4" id="text-5-3-5">
<p>
Les expressions canoniques en <i>somme de produits</i> et en <i>produit de
sommes</i> ne sont généralement pas simples, car toutes les variables
doivent être présentes. Pour l'implémentation, on cherchera des
expressions en formes <i>somme de produits</i> ou <i>produit de sommes</i> dans
lesquelles les termes pourront être simplifiés. C'est-à-dire que les
termes pourront comporter une, deux, trois, etc. variables plutôt
qu'obligatoirement <b>toutes</b> les variables. Toujours pour notre
fonction exemple, on peut écrire
</p>

<p>
\(F_1 = x + y z^\prime\)
</p>

<p>
Lorsqu'on implémente une telle fonction avec des portes logiques, il
faut une porte ET pour chaque terme produit (qui comporte plus d'une
variable) et une porte OU pour faire la somme finale. On obtient une
implémentation à deux niveaux.
</p>

<p>
De façon duale, on peut également obtenir une formulation en <i>produit
de sommes</i> qui aboutira à une implémentation à deux niveaux avec une
porte OU par terme et une porte ET pour le produit final.
</p>
</div>
</div>
</div>


<div id="outline-container-org3149e2f" class="outline-3">
<h3 id="org3149e2f"><span class="section-number-3">5.4.</span> Objectifs de minimisation</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Étant donné une fonction logique de \(n\) variables \(z(x_1, x_2, \ldots,
x_n)\), on veut déterminer une expression pour cette fonction sous la
forme <i>Somme de Produits</i> (S de P) ou <i>Produit de Sommes</i> (P de S) qui
</p>

<ol class="org-ol">
<li>comporte un nombre minimum de termes produits (pour la forme S de P)
ou de termes sommes (pour la forme P de S);</li>

<li>est telle qu'aucune expression pour \(z\) comportant le même nombre
de termes n'utilise moins de littéraux.</li>
</ol>
</div>
</div>

<div id="outline-container-org6c023f9" class="outline-3">
<h3 id="org6c023f9"><span class="section-number-3">5.5.</span> Diagrammes de Karnaugh</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Une méthode visuelle permet de simplifier l'expression logique d'une
fonction en systématisant une procédure faisant appel à un diagramme
qui fait ressortir les simplifications possibles.
</p>

<p>
Un diagramme de Karnaugh (diag-K) est constitué d'un regroupement de
cellules carrées, chaque cellule correspondant à un minterm
possible. Les cellules sont organisées de façon à ce que lorsqu'on
passe d'une cellule à une cellule adjacente (horizontalement ou
verticalement), un seul bit du minterm change, ce qui revient à dire
qu'une seule variable passe de telle qu'elle à complémentée.
</p>

<p>
Cela fait en sorte que si la fonction est 1 pour deux minterms
adjacents, la somme des deux minterms pourra être simplifiée en un
seul terme dans lequel la variable correspondant au bit qui change est
absente. Par exemple, on pourrait avoir pour deux minterms adjacents
\(m_5 + m_7 = xy^\prime z + xyz = xz(y^\prime + y) = xz\). Ici les
deux minterms adjacents diffèrent par la variable \(y\), qui sera donc
supprimée du terme produit résultant.
</p>


<div id="org47cafdf" class="figure">
<p><img src="Images_svg/kmap2.svg" alt="kmap2.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;18&nbsp;: </span>Diag-K à deux variables</p>
</div>


<div id="orga51b459" class="figure">
<p><img src="Images_svg/kmap3minterms.svg" alt="kmap3minterms.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;19&nbsp;: </span>Diag-K à trois variables, avec minterms</p>
</div>

<p>
Sur un diag-K à trois variables, on voit que les bits \(AB\) sont
ordonnés selon un code Gray, de façon à ce qu'un seul des bits change
lorsqu'on passe d'une cellule à la suivante
horizontalement. L'adjacence se poursuit en bout de diagramme: par
exemple, la cellule 100 (\(m_4\)) est adjacente horizontalement à la
cellule 000 (\(m_0\)). On peut imaginer le diagramme comme replié sur
lui-même pour visualiser cette adjacence.
</p>


<div id="org1ab628a" class="figure">
<p><img src="Images_svg/kmap3_repli.svg" alt="kmap3_repli.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;20&nbsp;: </span>Diag-K avec adjacence horizontale</p>
</div>

<p>
Sur un diag-K à quatre variables, l'adjacence repliée est autant horizontale
que verticale.
</p>

<p>
Pour plus de quatre variables, il devient difficile d'utiliser cette
méthode: les diagrammes sont de grande taille et surtout, les règles
d'adjacence ne sont plus aussi facilement observables. Les risques
d'erreurs sont plus grands.
</p>


<div id="orgab405eb" class="figure">
<p><img src="Images_svg/kmap4.svg" alt="kmap4.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;21&nbsp;: </span>Diag-K à quatre variables</p>
</div>
</div>

<div id="outline-container-orgf2875b9" class="outline-4">
<h4 id="orgf2875b9"><span class="section-number-4">5.5.1.</span> Procédure de simplification</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
Pour utiliser un diag-K pour minimiser une fonction logique, 
</p>

<ol class="org-ol">
<li>Les minterms de la fonction à minimiser sont identifiés en insérant
un 1 dans la cellule correspondant à chaque minterm.</li>
<li>On cherche dans le diagramme pour trouver des regroupement de deux
cellules adjacentes qui sont marquées d'un 1.</li>
<li>Chaque groupe de deux cellules 1 adjacentes est marqué comme
groupe. Un même minterm peut être incorporé à plus d'un groupe.</li>
<li>Il est aussi possible de regrouper les groupes: deux groupes de 2
qui sont adjacents peuvent ainsi se regrouper en un groupe
de 4. Les tailles de groupes doivent être des puissances de 2. Il
est ainsi possible de créer des groupes de 2, 4, 8 ou 16 minterms.</li>
<li>Une fois tous les regroupements identifiés, il est possible de lire
l'expression de la fonction en <i>somme de produits</i>. Chaque groupement
correspond à un terme produit, et la ou les variables dont le bit ne
change pas dans le groupe sont conservées; les autres sont
éliminées.</li>
</ol>

<p>
Considérons par exemple la fonction \(F(A,B,C) = \sum (0, 4, 6,
7)\). Après la première étape, on obtient
</p>


<div id="org92f9a7b" class="figure">
<p><img src="Images_svg/kmap3fonct.svg" alt="kmap3fonct.svg" class="org-svg" />
</p>
</div>

<p>
Après les regroupements, on obtient un diag-K comportant trois regroupements
</p>


<div id="org462a8bd" class="figure">
<p><img src="Images_svg/kmap3fonctsimp.svg" alt="kmap3fonctsimp.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;22&nbsp;: </span>Diagramme après les regroupements</p>
</div>

<p>
Le groupe en rouge correspond au produit \(B^\prime C^\prime\), celui
en bleu correspond à \(A B\) et celui en vert correspond à \(A
C^\prime\). L'expression finale en <i>somme de produits</i> est donc \(F =
B^\prime C^\prime + A B + A C^\prime\).
</p>
</div>
</div>

<div id="outline-container-org9da0bb6" class="outline-4">
<h4 id="org9da0bb6"><span class="section-number-4">5.5.2.</span> Cas facultatifs</h4>
<div class="outline-text-4" id="text-5-5-2">
<p>
Certaines fonctions sont incomplètement définies, dans le sens où
certaines combinaisons d'entrées ne se produiront jamais ou seront
sans conséquences si elles se produisent. On parle de <b>cas
indifférents</b> ou <b>facultatifs</b> (en anglais, <i>don't care</i>). Pour la
simplification, ces cas pourront être traités tantôt comme des 0,
tantôt comme des 1, selon ce qui sera le plus avantageux.
</p>

<p>
Pour tenir compte de ces cas, les minterms seront notés avec un X dans
le diagramme de Karnaugh. Dans l'exemple à quatre variables suivant,
sur deux cas facultatifs, un seul, celui correspondant à \(m_{7}\), a
été traité comme un 1, ce qui a permis de créer le regroupement en
bleu. L'autre cas facultatif, correspondant à \(m_{2}\), n'a pas servi
dans un regroupement, ce qui signifie qu'il a été traité comme
un 0. La fonction résultante est donc \(A C^\prime D^\prime + BD + AB
\).
</p>


<div id="orgc8e8d7d" class="figure">
<p><img src="Images_svg/kmap4fonct.svg" alt="kmap4fonct.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;23&nbsp;: </span>Diag-K avec cas facultatifs</p>
</div>
</div>
</div>


<div id="outline-container-org9f7fc13" class="outline-4">
<h4 id="org9f7fc13"><span class="section-number-4">5.5.3.</span> Impliquants</h4>
<div class="outline-text-4" id="text-5-5-3">
<p>
Le choix des regroupements à utiliser doit toujours viser à s'assurer que:
</p>
<ol class="org-ol">
<li>Tous les minterms de la fonction sont couverts par les regroupements choisis.</li>
<li>Le nombre de termes retenus pour l'expression est minimal.</li>
<li>Il n'y a pas de termes redondants, c'est-à-dire, qui couvrent
uniquement des minterms déjà couverts.</li>
</ol>

<p>
Il y a parfois des plus d'une expression qui rencontre ces
critères. Il est possible de systématiser le choix des termes en
prenant en compte le caractère essentiel des termes.
</p>

<p>
Soit \(p(X)\) un terme produit de littéraux tirés de l'ensemble de
variables \(X\). Si, pour une fonction logique \(z(X)\) définie pour le
même ensemble de variables, la relation
</p>

<blockquote>
<p>
pour tout \(A\) tel que \(p(A)=1\), \(z(A)=1\)
</p>
</blockquote>

<p>
tient, alors \(p\) est un <b>impliquant</b> de \(z\). Cela signifie que la
vérité du terme produit \(p\) implique celle de \(z\). <i>Tout minterm de
\(p\) est aussi un minterm de \(z\).</i>
</p>

<p>
Exemple:
</p>

<p>
\[z_1 = ab + bc + a b^{\prime} c\] 
</p>

<p>
\(a b\), \(b c\), \(a b^{\prime} c\) sont des impliquants évidents de \(z_1\).
</p>

<p>
\(a^{\prime} b c\), \(a b c^{\prime}\), \(a b c\), \(a c\) sont aussi des
impliquants de \(z_1\).
</p>


<div id="org8a0b373" class="figure">
<p><img src="Images_svg/kmap3fonctimp.svg" alt="kmap3fonctimp.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;24&nbsp;: </span>Diag-K pour l'exemple des impliquants</p>
</div>
</div>
</div>

<div id="outline-container-org2897878" class="outline-4">
<h4 id="org2897878"><span class="section-number-4">5.5.4.</span> Impliquant premier</h4>
<div class="outline-text-4" id="text-5-5-4">
<p>
Un impliquant \(p\) de la fonction \(z\) est <b>premier</b> si n'importe quel
terme produit obtenu de \(p\) en supprimant un littéral n'est pas un
impliquant de \(z\).
</p>

<p>
Ici, \(a b\) est un impliquant premier de \(z_1\) car ni \(a\) ni \(b\) ne
sont des impliquants de \(z_1\). Mais \(a b^{\prime} c\) n'est pas un
impliquant premier de \(z_1\) car \(a c\) est un impliquant de \(z_1\).
Sur un diagramme de Karnaugh, un impliquant premier (i.p.) est un
groupe qui n'est contenu dans aucun autre groupe plus grand.
</p>
</div>
</div>

<div id="outline-container-org1a3ca31" class="outline-4">
<h4 id="org1a3ca31"><span class="section-number-4">5.5.5.</span> Couverture d'une fonction</h4>
<div class="outline-text-4" id="text-5-5-5">
<p>
Un sous-ensemble d'i.p. qui contient tous les minterms d'une fonction
<b>couvre</b> la fonction.
</p>

<p>
Une <b>couverture minimale</b> est une couverture avec
</p>

<ol class="org-ol">
<li>le nombre minimal d'impliquants premiers,</li>

<li>le moins de littéraux parmi les couvertures avec nombre minimum
d'implicants.</li>
</ol>
</div>
</div>

<div id="outline-container-org711ae71" class="outline-4">
<h4 id="org711ae71"><span class="section-number-4">5.5.6.</span> Impliquant premier essentiel</h4>
<div class="outline-text-4" id="text-5-5-6">
<p>
Un i.p. est <b>essentiel</b> si et seulement si il couvre un minterm de la
fonction qui ne peut être couvert par un autre i.p. de la fonction.
Une couverture de la fonction <b>doit</b> contenir tous les impliquants
premiers essentiels (i.p.e.).
</p>

<p>
Un <b>impliquant premier absolument inessentiel</b> est un i.p. qui couvre
des minterms qui sont tous couverts par les i.p.e. de la fonction.
</p>
</div>
</div>

<div id="outline-container-org137c8d3" class="outline-4">
<h4 id="org137c8d3"><span class="section-number-4">5.5.7.</span> Sélection des impliquants</h4>
<div class="outline-text-4" id="text-5-5-7">
<p>
Règles de sélection des impliquants
</p>

<ol class="org-ol">
<li>Mettre de côté tous les i.p.e. Ils seront utilisés dans la solution
finale.</li>

<li>Éliminer tous les i.p. absolument inessentiels.</li>

<li>Il reste à choisir parmi les i.p. inessentiels pour obtenir une
couverture minimale.</li>
</ol>

<p>
Lorsque le problème est de taille réduite, on peut faire une recherche
exhaustive de toutes les solutions possibles pour choisir la solution
minimale.
</p>
</div>
</div>

<div id="outline-container-orga3a4be7" class="outline-4">
<h4 id="orga3a4be7"><span class="section-number-4">5.5.8.</span> Minimisation avec cas facultatifs</h4>
<div class="outline-text-4" id="text-5-5-8">
<ol class="org-ol">
<li>Lorsqu'on détermine les i.p., on doit considérer les X comme des
1, de façon à pouvoir utiliser les i.p. rendus possibles par les
cas facultatifs.</li>

<li>Lors de la sélection des i.p. pour obtenir une couverture
minimale, on ne doit pas ne pas essayer de couvrir les X.</li>
</ol>
</div>
</div>

<div id="outline-container-org6cf807a" class="outline-4">
<h4 id="org6cf807a"><span class="section-number-4">5.5.9.</span> Minimisation avec plusieurs fonctions</h4>
<div class="outline-text-4" id="text-5-5-9">
<p>
Si deux fonctions \(z_i\) et\(z_j\) ont des expressions minimales qui
comportent un terme commun, une seule porte suffira pour générer ce
terme au profit des deux fonctions.
</p>

<p>
Exemple:
</p>

<p>
\[z_1 = a c + a^{\prime} b c^{\prime} + a^{\prime} c^{\prime} d\]
</p>

<p>
\[z_2 = a c + a^{\prime}  b c^{\prime} d^{\prime} +
a^{\prime} b^{\prime} c^{\prime} d\]
</p>


<div id="org3de3ed4" class="figure">
<p><img src="Images_svg/kmap4z1.svg" alt="kmap4z1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;25&nbsp;: </span>Fonction \(z_1\)</p>
</div>


<div id="org27f6814" class="figure">
<p><img src="Images_svg/kmap4z2.svg" alt="kmap4z2.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;26&nbsp;: </span>Fonction \(z_2\)</p>
</div>

<p>
Il est alors préférable de réutiliser les termes communs et de générer
seulement les termes manquants pour la seconde fonction. Dans cet
exemple, le terme \(a c\) sera calculé une seule fois. Les termes
\(a^{\prime} b c^{\prime} d^{\prime}\) et \(a^{\prime} b^{\prime}
c^{\prime} d\) sont nécessaires pour \(z_2\). Alors, pour \(z_1\), on
fera
</p>

<p>
\[ z_1 =  a c + a^{\prime}  b c^{\prime} d^{\prime} +
a^{\prime} b^{\prime} c^{\prime} d +
a^{\prime} b c^{\prime} d \]
</p>

<p>
qui ne nous coûtera que le dernier terme produit et une somme de
quatre termes.
</p>
</div>
</div>
</div>


<div id="outline-container-org287f682" class="outline-3">
<h3 id="org287f682"><span class="section-number-3">5.6.</span> Tableau de couverture Quine-McCluskey</h3>
<div class="outline-text-3" id="text-5-6">
<p>
La méthode de Quine-McCluskey systématise la sélection des impliquants
en se basant sur des relations qui s'expriment en fonction d'un
tableau de couverture.
</p>

<p>
Un <b>tableau de couverture</b> comporte une ligne pour chaque i.p. et une
colonne pour chaque minterm de la fonction à minimiser \(z\). Un &check; est
inscrit à l'intersection de la ligne \(i\) et de la colonne  \(j\) si
l'i.p.  \(P_i\) de la ligne  \(i\) couvre le minterm  \(m_j\) de la colonne
 \(j\).
</p>

<p>
Le problème de minimisation devient alors: trouver une couverture pour
la fonction \(z\) qui
</p>

<ol class="org-ol">
<li>contient le nombre minimum de lignes</li>

<li>est telle qu'aucune autre couverture à nombre de ligne minimum
comprend moins d'entrées 1 et 0 dans ses codes d'impliquants de
ligne.</li>
</ol>

<p>
Dans le tableau de couverture, on identifie facilement les i.p.e. par
les colonnes qui ne contiennent qu'un &check;. L'i.p. qui couvre une colonne
qui ne contient qu'un &check; est un i.p.e.
</p>

<p>
Puisque les i.p.e. doivent faire partie de la solution finale, toutes
les colonnes couvertes par des i.p.e. seront couvertes dans n'importe
quelle solution. On peut donc éliminer ces colonnes de la suite de la
recherche de la solution, de même que les lignes correspondant aux
i.p.e. On obtient ainsi un tableau de couverture <b>réduit</b>.
</p>

<p>
<b>Il ne faut cependant pas oublier de mettre les i.p.e. dans la solution
finale.</b>
</p>
</div>

<div id="outline-container-org30d6aad" class="outline-4">
<h4 id="org30d6aad"><span class="section-number-4">5.6.1.</span> Tableau de couverture réduit</h4>
<div class="outline-text-4" id="text-5-6-1">
<p>
Le tableau de couverture réduit permet de se concentrer sur la
sélection des i.p. dont la sélection n'est pas évidente <i>a
priori</i>. Considérons pour illustrer la discussion le tableau de
couverture réduit suivant. \(m_c\) est sans doute couvert pas un
i.p.e. qui n'est pas montré ici.
</p>

<table id="org01e7fe7" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 20 :</span> Tableau réduit</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(m_a\)</th>
<th scope="col" class="org-left">\(m_b\)</th>
<th scope="col" class="org-left">\(m_c\)</th>
<th scope="col" class="org-left">\(m_d\)</th>
<th scope="col" class="org-left">\(m_e\)</th>
<th scope="col" class="org-left">\(m_f\)</th>
<th scope="col" class="org-left">\(m_g\)</th>
<th scope="col" class="org-left">\(m_h\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(P_A\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&check;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&check;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&check;</td>
<td class="org-left">&check;</td>
</tr>

<tr>
<td class="org-left">\(P_B\)</td>
<td class="org-left">&check;</td>
<td class="org-left">&check;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&check;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&check;</td>
</tr>

<tr>
<td class="org-left">\(P_C\)</td>
<td class="org-left">&check;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&check;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&check;</td>
<td class="org-left">&check;</td>
</tr>

<tr>
<td class="org-left">\(P_D\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&check;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&check;</td>
</tr>

<tr>
<td class="org-left">\(P_E\)</td>
<td class="org-left">&check;</td>
<td class="org-left">&check;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&check;</td>
<td class="org-left">&check;</td>
<td class="org-left">&check;</td>
<td class="org-left">&check;</td>
<td class="org-left">&check;</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org16b9816" class="outline-4">
<h4 id="org16b9816"><span class="section-number-4">5.6.2.</span> Dominance de lignes</h4>
<div class="outline-text-4" id="text-5-6-2">
<p>
Une ligne \(P_i\) domine une ligne \(P_j\) (noté \(P_i \supseteq
P_j\)) si la ligne \(P_i\) contient un &check; dans toutes les colonnes où
la ligne \(P_j\) contient un &check;. Ici, on a \(P_B \supseteq P_D\) mais
\(P_B\) ne domine pas \(P_A\). On peut voir aussi que \(P_E\) domine
plusieurs lignes.
</p>

<p>
En général, une \(P_i\) dominante contient plus de &check; que \(P_j\). Si
elles ont le même nombre de &check; (dans les mêmes colonnes), on a \(P_i =
P_j\). Il n'y a pas de cas d'égalité ici.
</p>

<p>
Une ligne <b>dominée</b> par une autre peut être éliminée du tableau de
couverture à condition que son nombre de littéraux soit supérieur ou
égal à celui de la ligne dominante.
</p>
</div>
</div>

<div id="outline-container-orgf0010db" class="outline-4">
<h4 id="orgf0010db"><span class="section-number-4">5.6.3.</span> Dominance de colonnes</h4>
<div class="outline-text-4" id="text-5-6-3">
<p>
Une colonne \(m_i\) domine une colonne \(m_j\) (noté \(m_i \supseteq
m_j\)) si la colonne \(m_i\) contient un &check; dans toutes les lignes où
la colonne \(m_j\) contient un &check;. Ici, la colonne \(m_h \supseteq
m_g\) mais \(m_b\) ne domine pas \(m_a\). 
</p>

<p>
Une colonne <b>dominant</b> une autre peut être éliminée du tableau de
couverture, car le fait que la solution finale couvre la colonne
dominée assure que la colonne dominante sera couverte aussi. Donc ici,
la colonne \(m_h\) peut être éliminée.
</p>

<p>
En cas d'égalité, comme on a ici pour \(m_e = m_g\), on peut librement
choisir quelle colonne éliminer.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfdedd65" class="outline-3">
<h3 id="orgfdedd65"><span class="section-number-3">5.7.</span> Implémentation des fonctions simplifiées</h3>
<div class="outline-text-3" id="text-5-7">
<p>
Les circuits logiques simplifiés en forme <i>produit de sommes</i> ou
<i>somme de produits</i> sont souvent mis en oeuvre au moyen de portes NAND
ou NOR plutôt qu'avec des portes ET et OU. La raison est qu'il est
plus simple en pratique de réaliser ces portes.
</p>
</div>

<div id="outline-container-org2053b6d" class="outline-4">
<h4 id="org2053b6d"><span class="section-number-4">5.7.1.</span> Implémentation à deux niveaux</h4>
<div class="outline-text-4" id="text-5-7-1">
<p>
Une fonction en forme <i>somme de produits</i> s'implémente évidemment avec
des portes ET pour les produits et une porte OU pour la somme
finale. Considérons par exemple \(F = AB + CD\).
</p>


<div id="orgae6416b" class="figure">
<p><img src="Images_svg/somme_produits.svg" alt="somme_produits.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;27&nbsp;: </span><i>Somme de produits</i> pour \(F = AB + CD\)</p>
</div>

<p>
La fonction peut aussi s'implémenter tout naturellement en faisant
appel uniquement à des portes NAND. On peut vérifier facilement que le
circuit suivant implémente la même fonction \(F = ((AB)^\prime \cdot
(CD)^\prime)^\prime = AB + CD\)
</p>


<div id="org806a530" class="figure">
<p><img src="Images_svg/somme_produitsNAND2.svg" alt="somme_produitsNAND2.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;28&nbsp;: </span><i>Somme de produits</i> NAND</p>
</div>

<p>
Cette configuration s'interprète plus facilement en représentant la
porte de sortie comme une porte NOR avec les entrées complémentées
(version équivalente de la porte NAND). En effet, la complémentation
de chaque sortie de somme est compensée par la complémentation à
l'entrée de la porte de sortie.
</p>


<div id="org406425d" class="figure">
<p><img src="Images_svg/somme_produitsNAND.svg" alt="somme_produitsNAND.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;29&nbsp;: </span><i>Somme de produits</i> NAND plus évidente</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org54e799e" class="outline-2">
<h2 id="org54e799e"><span class="section-number-2">6.</span> Circuits combinatoires typiques</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org27ba6c6" class="outline-3">
<h3 id="org27ba6c6"><span class="section-number-3">6.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>Pouvoir analyser un circuit combinatoire à partir de son schéma</li>
<li>Pouvoir concevoir un circuit combinatoire à partir d'une spécification</li>
<li>Connaître différentes approches de réalisation</li>
<li>Être familier avec les principaux circuits combinatoires courants et
leurs fonctions: additionneur, décodeur, multiplexeur, encodeur,
comparateur</li>
<li>Comprendre le fonctionnement d'une chaîne d'addition binaire et les
mécanismes de propagation et d'anticipation de retenue</li>
</ul>
</div>
</div>

<div id="outline-container-org148d3d5" class="outline-3">
<h3 id="org148d3d5"><span class="section-number-3">6.2.</span> Circuit combinatoire</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Un circuit logique combinatoire est une combinaison de portes logiques
dont la sortie à un instant donné ne dépend que des valeurs des
entrées à cet instant. Un circuit combinatoire à \(n\) entrées et
\(m\) sorties peut être représenté par un schéma-bloc, dans lequel on
place généralement les entrées à gauche et les sorties à droite.
</p>


<div id="org422ef84" class="figure">
<p><img src="Images_png/circuit_comb.png" alt="circuit_comb.png" />
</p>
<p><span class="figure-number">Figure&nbsp;30&nbsp;: </span>Circuit combinatoire</p>
</div>

<p>
Avec \(n\) entrées, il est possible de créer \(2^n\) combinaisons
différentes des entrées binaires. Pour chaque combinaison, le circuit
peut donner une sortie 0 ou 1. On peut donc préciser la fonction
réalisée par le circuit par un tableau de vérité comportant \(2^n\)
lignes. Comme nous avons \(m\) sorties différentes, il y aura \(m\)
colonnes dans le tableau de vérité pour les fonctions de
sortie. Traditionnellement, on présente les entrées en ordre croissant
de combinaison binaires.
</p>
</div>
</div>

<div id="outline-container-org1d8e1b9" class="outline-3">
<h3 id="org1d8e1b9"><span class="section-number-3">6.3.</span> Analyse d'un circuit logique combinatoire</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Si on est placé devant le schéma d'un circuit logique dont on ne
connaît pas la fonction, on doit en faire l'analyse. La première étape
consiste à vérifier qu'il s'agit bien d'un circuit combinatoire. Si le
schéma ne comporte pas de cellules de mémoire ou de boucles de
rétroaction, on peut conclure que le circuit est combinatoire. Une
boucle de rétroaction consiste en un chemin dans le circuit dans
lequel une valeur d'entrée d'une porte provient, directement ou
indirectement (par l'intermédiaire d'autres portes), de la sortie de
la même porte. La présence de rétroaction est une caractéristique des
circuits logiques séquentiels, que nous étudierons plus loin.
</p>

<p>
Pour interpréter le comportement du circuit, nous devons déterminer
les expressions logiques qu'il met en oeuvre ou établir son tableau de
vérité.
</p>

<p>
Pour déterminer l'expression logique, on procède ainsi:
</p>
<ol class="org-ol">
<li>Étiqueter toutes les sorties des portes qui sont alimentées par les
variables d'entrée du système. Les noms de variables seront
arbitraire, mais devraient être choisis de façon à faciliter
l'interprétation par la suite. Déterminer les fonctions logiques
pour ces variables.</li>
<li>Étiqueter les sorties des portes qui sont alimentées par les
variables d'entrée et par les sorties étiquetées à l'étape
précédente. Déterminer les fonctions logiques pour ces nouvelles
variables.</li>
<li>Répéter l'étape 2 jusqu'à arriver aux variables de sortie du système.</li>
<li>En substituant les expressions logiques des fonctions identifiées,
déterminer l'expression logique pour les sorties du système en
fonction des entrées du système.</li>
</ol>
</div>

<div id="outline-container-org7754122" class="outline-4">
<h4 id="org7754122"><span class="section-number-4">6.3.1.</span> Exemple</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
Considérons le circuit combinatoire à analyser illustré à la figure
suivante.
</p>


<div id="orgb444ad6" class="figure">
<p><img src="Images_svg/circuit_logique_inconnu.svg" alt="circuit_logique_inconnu.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;31&nbsp;: </span>Circuit combinatoire à analyser</p>
</div>

<ol class="org-ol">
<li>Il n'est pas la peine d'étiqueter la sortie de la porte
inverseur. Comme variables intermédiaire, nous considérons \(I_1\)
en sortie de la porte ET à trois entrées et \(I_2\) en sortie de la
porte NOR. On trouve que \(I_1 = A^\prime \cdot B \cdot C\) et que
\(I_2 = (A + D)^\prime = A^\prime \cdot D^\prime\).</li>

<li>On aura donc \(F_1 = I_1 \cdot I_2\).</li>

<li>En substituant, \(F_1 = ( A^\prime \cdot B \cdot C ) \cdot (
   A^\prime \cdot D^\prime) = A^\prime \cdot B \cdot C \cdot
   D^\prime\).</li>

<li>En simplifiant, on obtient finalement \(F_1 = A^\prime \cdot B
   \cdot C \cdot D^\prime\).</li>
</ol>

<table id="org08e8a39" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 21 :</span> Tableaux de vérité des fonctions intermédiaires et de la sortie</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(A\)</th>
<th scope="col" class="org-right">\(C\)</th>
<th scope="col" class="org-right">\(B\)</th>
<th scope="col" class="org-right">\(D\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(I_1\)</th>
<th scope="col" class="org-right">\(I_2\)</th>
<th scope="col" class="org-right">\(F_1\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-org4192cff" class="outline-3">
<h3 id="org4192cff"><span class="section-number-3">6.4.</span> Conception d'un circuit combinatoire</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Concevoir un circuit logique commence avec la formulation de la ou des
fonctions du système et se termine avec une implémentation en portes
logiques des fonctions logiques correspondantes. Voici les étapes à
suivre.
</p>

<ol class="org-ol">
<li>À partir de l'expression du besoin ou des spécifications du
système, déterminer combien d'entrées et de sorties sont
requises, et leur assigner des noms de variables. Le choix des noms
devrait faciliter leur interprétation en lien avec leur fonction.</li>

<li>Formuler le tableau de vérité qui décrit les valeurs logiques que
doivent assumer les sorties en fonction des différentes
combinaisons d'entrées.</li>

<li>Simplifier les expressions logiques pour les différentes fonctions,
en tenant éventuellement compte des partages possibles d'éléments
intermédiaires.</li>

<li>Tracer le circuit logique résultant, et le valider (à la main ou
mieux, par simulation).</li>
</ol>

<p>
L'étape 2 est cruciale, car ce qui sera implémenté (s'il n'y a pas
d'erreurs) est exactement ce que le tableau de vérité spécifie. On
doit donc s'assurer que le tableau est correctement rempli et
représente véritablement les besoins identifiés. Si des hypothèses ou
des choix doivent être faits, notamment dans le cas où l'expression
informelle des besoins est incomplète ou ambiguë, ces choix doivent
être clairement identifiés et documentés, permettant le cas échéant de
les modifier lorsque le système est mis à l'épreuve en fonctionnement.
</p>

<p>
N'importe quelle méthode de simplification peut être utilisée pour
l'étape 3, mais il faut aussi prendre en compte le type de portes
disponibles pour l'implémentation, les délais de propagations à
travers les portes, le nombre d'interconnexions entre sorties et
entrées de portes, et tout autre facteur pratique susceptible
d'orienter les décisions finales.
</p>
</div>
</div>

<div id="outline-container-org03af29a" class="outline-3">
<h3 id="org03af29a"><span class="section-number-3">6.5.</span> Alternatives d'implémentation</h3>
<div class="outline-text-3" id="text-6-5">
<p>
Considérons la fonction logique \(Y\) correspondant au diag-K de la
figure suivante.
</p>


<div id="org7a6449a" class="figure">
<p><img src="Images_svg/kmap3altern.svg" alt="kmap3altern.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;32&nbsp;: </span>Diag-K d'une fonction combinatoire \(Y\) à réaliser</p>
</div>
</div>

<div id="outline-container-orgba9d112" class="outline-4">
<h4 id="orgba9d112"><span class="section-number-4">6.5.1.</span> Implémentations via la fonction directe</h4>
<div class="outline-text-4" id="text-6-5-1">
</div>
<ol class="org-ol">
<li><a id="org15ece0e"></a>Implémentation en <i>somme de produits</i><br />
<div class="outline-text-5" id="text-6-5-1-1">
<p>
En <i>somme de produits</i>, on a \(Y = bc + a^\prime b + a b^\prime
c^\prime\) pour la fonction et \(Y^\prime = a^\prime b^\prime +
b^\prime c + a b c^\prime\) pour son complément. Les implémentations
possibles pour la fonction directe sont illustrées ci-dessous.
</p>


<div id="org3408cbf" class="figure">
<p><img src="Images_svg/circ_altern_1.svg" alt="circ_altern_1.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;33&nbsp;: </span>Implémentation de \(Y\) en <i>somme de produits</i></p>
</div>



<div id="orgaf89ddf" class="figure">
<p><img src="Images_svg/circ_altern_2.svg" alt="circ_altern_2.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;34&nbsp;: </span>Implémentation (en NAND) de \(Y\) en <i>somme de produits</i></p>
</div>
</div>
</li>


<li><a id="orga39113d"></a>Implémentation en <i>produit de sommes</i><br />
<div class="outline-text-5" id="text-6-5-1-2">
<p>
En <i>produit de sommes</i>, on a \(Y =(a + b ) (b + c^\prime ) (a^\prime +
ba^\prime + c)\) pour la fonction et \(Y^\prime = (b^\prime +c^\prime
)(a+b^\prime )(a^\prime +b+c)\) pour son complément.  Les implémentations
possibles pour la fonction directe sont illustrées ci-dessous.
</p>



<div id="orgc0e881e" class="figure">
<p><img src="Images_svg/circ_altern_ps1.svg" alt="circ_altern_ps1.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;35&nbsp;: </span>Implémentation de \(Y\) en <i>produit de sommes</i></p>
</div>


<div id="org43b10b1" class="figure">
<p><img src="Images_svg/circ_altern_ps2.svg" alt="circ_altern_ps2.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;36&nbsp;: </span>Implémentation (en NOR) de \(Y\) en <i>produit de sommes</i></p>
</div>
</div>
</li>
</ol>
</div>


<div id="outline-container-org143cc58" class="outline-4">
<h4 id="org143cc58"><span class="section-number-4">6.5.2.</span> Implémentations via la fonction complémentaire</h4>
<div class="outline-text-4" id="text-6-5-2">
<p>
On peut aussi implémenter la fonction à partir de la fonction
complémentaire \(Y^\prime\), en se basant sur le complément \(Y^\prime
= (b^\prime +c^\prime )(a+b^\prime )(a^\prime +b+c)\) et en inversant
la sortie. Voici les implémentations que l'on obtient alors.
</p>
</div>

<ol class="org-ol">
<li><a id="org39b6cb9"></a>Implémentation en <i>somme de produits</i><br />
<div class="outline-text-5" id="text-6-5-2-1">
<p>
En <i>somme de produits</i>, on a utilisé une porte NOR en sortie pour
obtenir finalement \(Y\).
</p>


<div id="orgead3ed2" class="figure">
<p><img src="Images_svg/circ_altern_comp_sp1.svg" alt="circ_altern_comp_sp1.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;37&nbsp;: </span>Implémentation via \(Y^\prime\) en <i>somme de produits</i></p>
</div>

<p>
Une autre forme fait appel à des portes NAND au premier niveau.
</p>


<div id="orgd229c5a" class="figure">
<p><img src="Images_svg/circ_altern_comp_sp2.svg" alt="circ_altern_comp_sp2.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;38&nbsp;: </span>Implémentation via \(Y^\prime\) en <i>somme de produits</i></p>
</div>
</div>
</li>

<li><a id="org2100e69"></a>Implémentation en <i>produit de sommes</i><br />
<div class="outline-text-5" id="text-6-5-2-2">
<p>
En <i>produit de sommes</i>, en se basant sur le complément \(Y^\prime =
(b^\prime +c^\prime )(a+b^\prime )(a^\prime +b+c)\). On a encore ici
deux variantes selon le type de portes utilisées.
</p>


<div id="org8bb1755" class="figure">
<p><img src="Images_svg/circ_altern_comp_ps1.svg" alt="circ_altern_comp_ps1.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;39&nbsp;: </span>Implémentation via \(Y^\prime\) en <i>produit de sommes</i></p>
</div>



<div id="org5dc75be" class="figure">
<p><img src="Images_svg/circ_altern_comp_ps2.svg" alt="circ_altern_comp_ps2.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;40&nbsp;: </span>Implémentation via \(Y^\prime\) en <i>produit de sommes</i></p>
</div>
</div>
</li>
</ol>
</div>
</div>


<div id="outline-container-org037ebb6" class="outline-3">
<h3 id="org037ebb6"><span class="section-number-3">6.6.</span> Circuits logiques combinatoires classiques</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Nous allons maintenant nous intéresser à un certain nombre de
fonctions typiques que l'on rencontre fréquemment en circuits
logiques. Ce sera aussi l'occasion de mettre en pratique les approches
de conception que nous avons vues.
</p>
</div>
</div>


<div id="outline-container-orgb0dc96b" class="outline-3">
<h3 id="orgb0dc96b"><span class="section-number-3">6.7.</span> Additionneur binaire</h3>
<div class="outline-text-3" id="text-6-7">
<p>
Une des opérations binaires les plus utilisées est l'addition (et la
soustraction). Nous avons présenté à la section <a href="#org0e2985e">1.11.1</a> le tableau de vérité pour un additionneur binaire dont les
entrées sont \(a_{i}\) et \(b_{i}\), les bits des nombres à
additionner, et aussi \(r_{i-1}\), la retenue provenant de la position
\(i-1\). En sortie, on aura la somme \(S_{i}\) et la retenue
\(R_{i}\). Notez que pour bien distinguer la retenue d'entrée de la
retenue de sortie, nous utilisons un symbole minuscule, \(r_{i-1}\),
pour l'entrée et un symbole majuscule, \(R_{i}\), pour la sortie. 
</p>


<div id="org18bdbe8" class="figure">
<p><img src="Images_png/additionneur.png" alt="additionneur.png" />
</p>
<p><span class="figure-number">Figure&nbsp;41&nbsp;: </span>Schéma-bloc d'un additionneur complet</p>
</div>

<table id="orgcda6715" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 22 :</span> Tableau de vérité pour l'additionneur binaire</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(a_{i}\)</th>
<th scope="col" class="org-right">\(b_{i}\)</th>
<th scope="col" class="org-right">\(r_{i-1}\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(R_{i}\)</th>
<th scope="col" class="org-right">\(S_{i}\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-orgad678a7" class="outline-4">
<h4 id="orgad678a7"><span class="section-number-4">6.7.1.</span> Demi-additionneur</h4>
<div class="outline-text-4" id="text-6-7-1">
<p>
Un circuit logique qui effectue l'addition de deux bits est appelé un
demi-additionneur. Mais ce qu'il nous faut vraiment, c'est un
<b>additionneur complet</b>, c'est-à-dire, un circuit de trois entrées qui
fait l’addition de trois bits, puisqu'il faudra pouvoir tenir compte
de la retenue du niveau précédent pour effectuer l'addition sur un
niveau. Il est possible d'implémenter l'additionneur complet avec deux
demi-additionneurs.
</p>

<table id="org93ae310" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 23 :</span> Tableau de vérité pour un demi-additionneur</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(a_{i}\)</th>
<th scope="col" class="org-right">\(b_{i}\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(R_{i}\)</th>
<th scope="col" class="org-right">\(S_{i}\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>


<p>
À partir du tableau de vérité, on peut trouver que pour un
demi-additionneur, \(S_{i} = a_i b_i^\prime + a_i^\prime b_i = a_i
\operatorname{Xor} b_i\) et \(R_{i} = a_i b_i\).
</p>


<div id="orgeb09e49" class="figure">
<p><img src="Images_svg/demi_add2.svg" alt="demi_add2.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;42&nbsp;: </span>Circuit demi-additionneur (en S de P)</p>
</div>



<div id="orgf4f6d69" class="figure">
<p><img src="Images_svg/demi_add.svg" alt="demi_add.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;43&nbsp;: </span>Circuit demi-additionneur avec porte XOR</p>
</div>
</div>
</div>

<div id="outline-container-org382f033" class="outline-4">
<h4 id="org382f033"><span class="section-number-4">6.7.2.</span> Additionneur complet</h4>
<div class="outline-text-4" id="text-6-7-2">
<p>
Une addition binaire complète de deux arguments constitués de \(n\)
bits procède du bit le moins significatif vers le bits le plus
significatif, en additionnant à chaque étape trois bits: \(a_{i}\),
\(b_{i}\) et \(r_{i-1}\) et en produisant une somme \(S_{i}\) et une
retenue \(R_{i}\).
</p>



<div id="org92389a7" class="figure">
<p><img src="Images_svg/kmapSi_fulladder.svg" alt="kmapSi_fulladder.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;44&nbsp;: </span>Diag-K pour \(S_i\), additionneur complet</p>
</div>



<div id="org3049312" class="figure">
<p><img src="Images_svg/kmap3fulladderR.svg" alt="kmap3fulladderR.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;45&nbsp;: </span>Diag-K pour \(R_i\), additionneur complet</p>
</div>


<p>
Les expressions simplifiées sont 
</p>

<p>
\[ S_{i} = a_i^\prime b_i^\prime r_{i-1} + a_i^\prime b_i
r_{i-1}^\prime + a_i b_i^\prime r_{i-1}^\prime + a_i b_i r_{i-1} \]
</p>

<p>
\[ R_{i} = a_i b_i + a_i r_{i-1} + b_i r_{i-1} \]
</p>


<div id="orgc2d214d" class="figure">
<p><img src="Images_svg/fulladderS.svg" alt="fulladderS.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;46&nbsp;: </span>Circuit additionneur complet pour \(S_i\)</p>
</div>




<div id="orga669f5d" class="figure">
<p><img src="Images_svg/fulladderR.svg" alt="fulladderR.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;47&nbsp;: </span>Circuit additionneur complet pour \(R_i\)</p>
</div>


<p>
Comme on le disait précédemment, il est possible de combiner deux
demi-additionneurs pour réaliser un additionneur complet, comme on
peut le voir ici.
</p>



<div id="org895dd0f" class="figure">
<p><img src="Images_svg/fulladderxor.svg" alt="fulladderxor.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;48&nbsp;: </span>Circuit additionneur complet comportant deux demi-additionneurs et une porte OU</p>
</div>
</div>
</div>

<div id="outline-container-org03caa89" class="outline-4">
<h4 id="org03caa89"><span class="section-number-4">6.7.3.</span> Additionneur binaire pour \(n\) bits</h4>
<div class="outline-text-4" id="text-6-7-3">
<p>
Un additionneur binaire est un circuit logique qui permet d'évaluer la
somme arithmétique de deux nombres binaire de \(n\) bits. Il peut être
conçu en combinant des additionneurs complets en cascade, en reliant
la retenue de sortie provenant de la position 0 (la moins
significative) à l'entrée de retenue de la position 1, &#x2026;, la retenue
de sortie provenant de la position \(i-1\) à l'entrée de retenue de la
position \(i\), etc. (figure <a href="#org88cf86f">49</a>).
</p>

<p>
Pour en faire un circuit général pouvant également se combiner en
chaîne, on prévoit une entrée pour une retenue au niveau 0, \(r_0\) et
une sortie pour une retenue du dernier niveau \(n-1\), \(R_{n-1}\). On
doit donc, pour le chaînage, acheminer la sortie retenue du niveau
courant à l'entrée de retenue du niveau suivant.
</p>



<div id="org88cf86f" class="figure">
<p><img src="Images_png/additionneur_cascade.png" alt="additionneur_cascade.png" />
</p>
<p><span class="figure-number">Figure&nbsp;49&nbsp;: </span>Chaîne d'addition</p>
</div>

<p>
Cette réalisation en forme de chaîne, en réutilisant de façon
systématique un bloc élémentaire, est avantageuse d'un point de vue
complexité et flexibilité. Imaginons par exemple le défi de concevoir
un additionneur binaire pour des nombres de quatre bits par la méthode
classique. Comme il faudrait considérer 9 entrées, le tableau de
vérité comporterait \(2^9= 512\) lignes!
</p>
</div>
</div>

<div id="outline-container-org941ef3f" class="outline-4">
<h4 id="org941ef3f"><span class="section-number-4">6.7.4.</span> Propagation de retenue</h4>
<div class="outline-text-4" id="text-6-7-4">
<p>
L'approche en cascade ne comporte pas que des avantages. Lorsqu'on
effectue l'addition de deux nombres, les bits d'entrée des deux
arguments et la retenue d'entrée sont présentés en même temps à
l'additionneur.  Comme dans tout circuit combinatoire, il faut un
certain délai avant que les sorties n'atteignent leur niveau de sortie
final.  Ce délai de propagation dépend de la profondeur du circuit, en
nombre de portes élémentaires à franchir de l'entrée vers la
sortie.  Et c'est évidemment le chemin le plus long qui détermine le
délai de propagation global.  
</p>

<p>
Dans le cas de l'additionneur, le chemin de propagation le plus long
est celui qui mène à la dernière retenue finale \(R_{n-1}\).  En
effet, pour pouvoir calculer \(R_{n-1}\), bien que les valeurs de
\(a_{n-1}\) et \(b_{n-1}\) soient déjà disponibles, il faut attendre
que la valeur de \(r_{n-1} = R_{n-2}\) soit stabilisée avant que le
calcul puisse s'effectuer avec les bonnes valeurs. Il en est de même
avec la bloc précédent, et ainsi, en remontant la chaîne vers \(r_0\),
on trouve le chemin de propagation de retenue comme chemin le plus
long.
</p>

<p>
Pour déterminer le nombre de portes à franchir pour le chemin de
propagation de retenue, nous avons ajouté deux sorties intermédiaires
à notre circuit d'additionneur complet, \(P_i\) et \(G_i\), permettant
de récrire la sortie comme \(S_i = P_i  \operatorname{Xor} r_i\) et la retenue de
sortie comme \(R_i = P_i r_i + G_i\). Les signaux \(P_i\) et \(G_i\)
ne dépendent que des entrées et sont donc disponibles après le délai
des portes ET et XOR. Le chemin de \(r_i\) à \(R_i\) passe par une
porte ET et une porte OU. Pour un additionneur de \(n\) bits
comprenant \(n\) additionneurs complets, on aura une profondeur de
retenue totale de \(2n\) portes.
</p>



<div id="org251647d" class="figure">
<p><img src="Images_svg/fulladderxorPG.svg" alt="fulladderxorPG.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;50&nbsp;: </span>Circuit additionneur complet montrant les signaux intermédiaires \(P_i\) et \(G_i\)</p>
</div>
</div>
</div>

<div id="outline-container-org4a44f7f" class="outline-4">
<h4 id="org4a44f7f"><span class="section-number-4">6.7.5.</span> Anticipation de retenue</h4>
<div class="outline-text-4" id="text-6-7-5">
<p>
Les valeurs calculées par le circuit complet en chaîne ne seront
valides et ne devront être prises en compte que lorsque le délai
maximal se sera écoulé. Entre temps, les valeurs binaires présentes
aux différentes sorties assumeront typiquement des valeurs changeantes
jusqu'à stabilisation finale. Le délai de propagation de retenue est
un facteur qui limite la vitesse à laquelle on pourra calculer la
somme de deux nombres. Et comme l'addition est une opération courante,
souvent utilisée, parfois à répétition, pour réaliser d'autres
opérations arithmétiques, cette limitation est problématique. 
</p>

<p>
Il serait en théorie possible de ramener à un minimum le délai de
calcul de la retenue finale en réalisant cette fonction en deux
niveaux, par exemple avec un <i>produit de sommes</i>. Cette option n'est pas
réaliste, car le nombre d'entrées à considérer en parallèle est prohibitif.
</p>

<p>
Comme solutions de compromis intermédiaires, un certain nombre de
mécanismes ont été élaborés, dont l'approche par anticipation de
retenue, que nous allons explorer ici. On fait appel aux deux signaux
\(P_i = a_i \operatorname{Xor} b_i\) et \(G_i = a_i b_i\), qui donnent
respectivement pour la sortie et la retenue de sortie
</p>

<p>
\[ S_i = P_i \operatorname{Xor} r_{i-1} \]
\[ R_i = P_i r_{i-1} + G_i \]
</p>

<p>
\(G_i\) est le signal qui indique la <b>génération</b> de retenue,
produisant une retenue lorsque \(a_i\) et \(b_i\) sont tous deux à 1,
sans égard à la valeur de la retenue d'entrée \(r_{i-1}\). Le signal
\(P_i\) est l'indicateur de <b>propagation</b> de retenue, parce qu'il
détermine si la retenue du niveau précédent \(r_{i-1}\) sera propagée
à \(R_i\).
</p>

<p>
En partant du niveau 0, voici les expressions pour les différentes retenues:
</p>

<p>
\[ R_0 = r_0 = \operatorname{in}\]
\[ R_1 = G_0 + P_0 R_0 \]
\[ R_2 = G_1 + P_1 R_1 = G_1 + P_1 (G_0 + P_0 R_0) = G_1 + P_1 G_0 + P_1 P_0 R_0 \]
\[ R_3 = G_2 + P_2 R_2 = G_2 + P_2 G_1 + P_2 P_1 G_0 + P_2 P_1 P_0 R_0 \]
etc.
</p>

<p>
Les expressions pour les retenues successives sont en forme <i>somme de
produits</i>, ce qui mène à une implémentation à deux niveaux pour
calculer les retenues rapidement. Contrairement à l'approche de
propagation de retenue, toutes les retenues sont obtenues après un
même délai équivalent à une profondeur de deux portes.  En calculant
d'abord les différentes valeurs de \(P_i\) et \(G_i\) pour chaque
niveau et en utilisant ces résultats intermédiaires pour, d'une part
alimenter le circuit d'anticipateur de retenue et d'autre part,
effectuer \(S_i = P_i  \operatorname{Xor} r_i\), on obtient un additionneur parallèle
plus rapide que la configuration en cascade.
</p>


<div id="orgd41eca8" class="figure">
<p><img src="Images_svg/lookahead1.svg" alt="lookahead1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;51&nbsp;: </span>Circuit d'anticipateur de retenue pour \(n= 4\)</p>
</div>
</div>
</div>


<div id="outline-container-org51eaa2d" class="outline-4">
<h4 id="org51eaa2d"><span class="section-number-4">6.7.6.</span> Soustraction</h4>
<div class="outline-text-4" id="text-6-7-6">
<p>
Pour effectuer une soustraction \(A - B\), il faut effectuer \(A +
(-B)\), c’est-à-dire additionner le complément à deux de \(B\) à
\(A\). On détermine le complément à deux en obtenant d'abord le
complément à un en complémentant chaque bit, et en additionnant ensuite
1 à cette valeur par le biais de l'entrée de retenue de l'additionneur. Il
est ainsi possible de concevoir un additionneur/soustracteur commandé
par un signal de contrôle \(O\). Si \(O=0\), le circuit calcule \(A +
(B)\) et si \(O=1\), le circuit calcule \(A + (-B)\).
</p>

<p>
La complémentation de \(B\) se fait au moyen de portes XOR qui
calculent \(O  \operatorname{Xor} b_i\) et dont la sortie est acheminée à l'entrée
\(B\) de l'additionneur. Lorsque que \(O=1\), leur sortie vaut
\(b_i^\prime\).
</p>


<div id="org527bd86" class="figure">
<p><img src="Images_svg/add_sous.svg" alt="add_sous.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;52&nbsp;: </span>Circuit additionneur/ soustracteur 4 bits</p>
</div>
</div>
</div>

<div id="outline-container-org604cfb9" class="outline-4">
<h4 id="org604cfb9"><span class="section-number-4">6.7.7.</span> Débordements</h4>
<div class="outline-text-4" id="text-6-7-7">
<p>
Un additionneur ou un soustracteur sont conçus en fonction d'une
taille de nombres \(n\). Lorsque le résultat de l'opération dépasse la
limite pouvant être représentée, on doit détecter cette condition et
la signaler par un signal binaire.
</p>

<p>
Le cas de l'addition de nombre non signés est le plus simple. Il
suffit de surveiller la retenue du niveau le plus significatif. Une
retenue de 1 signifie un débordement de l'addition.
</p>

<p>
Les calculs avec des nombres signés en complément à deux peuvent aussi
occasionner des débordements, mais la détection doit tenir compte des
bits qui indiquent le signe des nombres.
</p>

<p>
L'addition de deux nombres de signes différents ne peut pas
occasionner de débordement, puisque la valeur absolue du résultat sera
nécessairement moindre que celle du plus grand des nombres
initiaux. Un débordement ne peut donc se produire que si les deux
nombres additionnés sont de même signe, deux positifs ou deux
négatifs.
</p>

<p>
Prenons le cas de nombres représentés sur huit bits en complément à
deux. La gamme représentable va de -128 à +127 avec un bit qui
représente le signe. Si on additionne (+50)10 = (00110010)2 avec
(+100)10 = (01100100)2, on aura un débordement, car \(150 > 127\). On
voit dans le tableau suivant les bits qui seront produits par
l'addition, avec en évidence les retenues des deux derniers
niveaux. Le bit de signe a été séparé des autres.
</p>

<table id="orgd7f3ab7" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 24 :</span> Addition de (+50)10 + (+100)10 = (00110010)2 + (01100100)2</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Retenues</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-left">011 0010</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-left">110 0100</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-left">001 0110</td>
</tr>
</tbody>
</table>

<p>
Refaisons le même exercice avec deux nombres négatifs: on additionne
(-50)10 = (1100 1110)2 avec (-100)10 = (1001 1100)2, qui créera un
débordement aussi.
</p>

<table id="orga69dc1f" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 25 :</span> Addition de (-50)10 + (-100)10 = (1100 1110)2 + (1001 1100)2</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Retenues</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-left">100 1110</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-left">001 1100</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-left">110 1010</td>
</tr>
</tbody>
</table>

<p>
On peut dans les deux cas détecter le débordement en observant que la
retenue du dernier niveau et la retenue de l'avant dernier niveau sont
différentes. On peut vérifier facilement que les autres cas sans
débordement donnent des retenues égales. Donc, si on fait un
OU-exclusif entre ces deux retenues, un résultat 1 indiquera un
débordement. Ce mécanisme de détection de débordement a été ajouté au
circuit additionneur/soustracteur 4 bits dans la figure suivante pour
générer le signal \(D\) qui indique un débordement.
</p>


<div id="orga135544" class="figure">
<p><img src="Images_svg/add_sous_deb.svg" alt="add_sous_deb.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;53&nbsp;: </span>Circuit additionneur/soustracteur 4 bits avec débordement</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org7a4ff56" class="outline-3">
<h3 id="org7a4ff56"><span class="section-number-3">6.8.</span> Multiplexeur</h3>
<div class="outline-text-3" id="text-6-8">
<p>
Un multiplexeur est un circuit combinatoire qui sélectionne le signal
qui provient d'une de ses entrées, et fait que sa sortie soit égale à
l'entrée sélectionnée. Les signaux de sélection fonctionnent
typiquement selon un encodage binaire, ce qui suppose un nombre
d'entrées de la forme \(2^n\). On désigne le multiplexeur par le
nombre de signaux d'entrées à sélectionner.
</p>
</div>

<div id="outline-container-org5293503" class="outline-4">
<h4 id="org5293503"><span class="section-number-4">6.8.1.</span> Multiplexeur deux-vers-un</h4>
<div class="outline-text-4" id="text-6-8-1">
<p>
Le multiplexeur le plus simple utilise un seul signal de sélection
\(S\) qui permet de choisir une de deux entrées \(I_0\) ou \(I_1\)
pour agir sur la sortie \(Y\).
</p>


<div id="orgfde7e40" class="figure">
<p><img src="Images_svg/mux2b.svg" alt="mux2b.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;54&nbsp;: </span>Circuit du multiplexeur deux-vers-un</p>
</div>


<div id="orge00e7d3" class="figure">
<p><img src="Images_svg/mux2symb.svg" alt="mux2symb.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;55&nbsp;: </span>Symbole du multiplexeur deux-vers-un</p>
</div>
</div>
</div>

<div id="outline-container-org8127cc9" class="outline-4">
<h4 id="org8127cc9"><span class="section-number-4">6.8.2.</span> Multiplexeur quatre-vers-un</h4>
<div class="outline-text-4" id="text-6-8-2">
<p>
Un multiplexeur quatre-vers-un permet de choisir une de quatre entrées
en utilisant deux signaux de sélection. Pour simplifier la
représentation symbolique, les deux signaux de sélection sont
représentés comme un seul fil, qui correspond en fait à une paire de
signaux \(S_0\) et \(S_1\). Pour un multiplexeur à \(2^n\) entrées, on
aurait un vecteur de \(n\) signaux de sélection.
</p>


<div id="org3adfb44" class="figure">
<p><img src="Images_svg/mux4.svg" alt="mux4.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;56&nbsp;: </span>Circuit du multiplexeur quatre-vers-un</p>
</div>


<div id="orga2c2095" class="figure">
<p><img src="Images_svg/mux4symb.svg" alt="mux4symb.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;57&nbsp;: </span>Symbole du multiplexeur quatre-vers-un</p>
</div>

<table id="orgfe3130b" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 26 :</span> Tableau de vérité du multiplexeur quatre-vers-un</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(S_1\)</th>
<th scope="col" class="org-right">\(S_0\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(Y\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(I_0\)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(I_1\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(I_2\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(I_3\)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>



<div id="outline-container-orgf841fbd" class="outline-3">
<h3 id="orgf841fbd"><span class="section-number-3">6.9.</span> Décodeur</h3>
<div class="outline-text-3" id="text-6-9">
<p>
Un décodeur est un circuit combinatoire qui sert à interpréter des
données encodées, le plus souvent en binaire. Il prend un groupe
(vecteur) de \(n\) bits en entrée, et active une sortie parmi jusqu'à
\(2^n\) sorties différentes. Dans le cas où certaines combinaisons
d'entrées ne sont pas utilisées, moins de \(2^n\) sorties peuvent être
produites.
</p>

<p>
Dans un décodeur générique, chaque combinaison binaire distincte
activera une seule sortie. Il y a une correspondance directe entre
chaque sortie possible et un minterm d'entrée.
</p>


<div id="orgdc8d373" class="figure">
<p><img src="Images_svg/decod3_8.svg" alt="decod3_8.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;58&nbsp;: </span>Circuit du décodeur trois-vers-huit</p>
</div>


<table id="org3c436d5" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 27 :</span> Tableau de vérité du décodeur trois-vers-huit</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-right">\(z\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(D_0\)</th>
<th scope="col" class="org-right">\(D_1\)</th>
<th scope="col" class="org-right">\(D_2\)</th>
<th scope="col" class="org-right">\(D_3\)</th>
<th scope="col" class="org-right">\(D_4\)</th>
<th scope="col" class="org-right">\(D_5\)</th>
<th scope="col" class="org-right">\(D_6\)</th>
<th scope="col" class="org-right">\(D_7\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgeb38c77" class="outline-4">
<h4 id="orgeb38c77"><span class="section-number-4">6.9.1.</span> Décodeur avec sortie active basse et signal de contrôle</h4>
<div class="outline-text-4" id="text-6-9-1">
<p>
On peut aussi concevoir des décodeurs basés sur des portes NAND et
dont la sortie sélectionnée est active au niveau bas. Une autre
fonction utile est un signal de contrôle \(E\) qui n'active une sortie
que lorsqu'il est activé.
</p>

<p>
Le décodeur deux-vers-quatre dont le circuit est présenté ci-dessous
présente ces deux caractéristiques. Comme on peut voir dans le tableau
de vérité, tant que le signal de contrôle est inactif ( \(E = 1\)
puisque ce signal est également actif bas), les sorties sont inactives
(au niveau 1) quelles que soient les entrées \(x\) et \(y\). Lorsque
\(E = 0\), une seule sortie passe à 0, selon le code binaire présent
aux entrées \(x\) et \(y\). Notez que tel que conçu et étiqueté, les
entrées \(x\) et \(y\) sont actives hautes.
</p>


<div id="org16b76fc" class="figure">
<p><img src="Images_svg/decode2_4_enable.svg" alt="decode2_4_enable.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;59&nbsp;: </span>Décodeur à sortie active basse</p>
</div>


<table id="org0bdbd27" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 28 :</span> Tableau de vérité, décodeur 2 vers 4 avec sortie active basse</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(E\)</th>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(D_0\)</th>
<th scope="col" class="org-right">\(D_1\)</th>
<th scope="col" class="org-right">\(D_2\)</th>
<th scope="col" class="org-right">\(D_3\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-org6272807" class="outline-4">
<h4 id="org6272807"><span class="section-number-4">6.9.2.</span> Implémentation de fonctions arbitraires au moyen d'un décodeur</h4>
<div class="outline-text-4" id="text-6-9-2">
<p>
Puisqu'un décodeur active sélectivement les \(2^n\) minterms possibles
à partir de ses \(n\) entrées, il est possible d'implémenter, en <i>somme
de produits</i>, une fonction quelconque en acheminant les minterms de la
fonction à une porte OU. Il est même possible d'implémenter plusieurs
fonctions différentes, en leur consacrant chacune une porte OU de
sortie.
</p>

<p>
Voici par exemple une fonction réalisée à partir d'un décodeur
3-vers-8. L'entrée \(I\) correspond à un vecteur de trois bits. Le
tableau de vérité correspondant est donné. On peut voir que les
minterms choisis permettent d'implémenter
</p>

<p>
\[ Y = \sum(0,2,5,6)\]
</p>


<div id="org92943d7" class="figure">
<p><img src="Images_svg/fonct_arbit_decod.svg" alt="fonct_arbit_decod.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;60&nbsp;: </span>Fonction arbitraire réalisée au moyen d'un décodeur</p>
</div>


<table id="orgac67f0d" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 29 :</span> Tableau de vérité pour la fonction arbitraire</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(I_2\)</th>
<th scope="col" class="org-right">\(I_1\)</th>
<th scope="col" class="org-right">\(I_0\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(Y\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Une fonction qui comporte de nombreux minterms exige l'utilisation
d'une porte OU avec un grand nombre d'entrées. Si la fonction à
réaliser exige plus de \(2^n/2\) minterms, il est alors plus
avantageux d'implémenter le complément de la fonction, qui nécessitera
moins de \(2^n/2\) minterms, et d'inverser ensuite la sortie pour
obtenir la fonction.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc8f52c8" class="outline-3">
<h3 id="orgc8f52c8"><span class="section-number-3">6.10.</span> Encodeur</h3>
<div class="outline-text-3" id="text-6-10">
<p>
Un encodeur effectue le travail inverse du décodeur: lorsqu'une de ses
\(2^n\) (ou moins) entrées est activée, il donne le code binaire
correspondant sur ses \(n\) sorties vues comme un vecteur binaire. Le
circuit ne nécessite pas vraiment d'entrée pour \(D_0\).
</p>



<div id="org8dc5db3" class="figure">
<p><img src="Images_svg/encode1.svg" alt="encode1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;61&nbsp;: </span>Encodeur 3 bits</p>
</div>


<table id="org288c5f3" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 30 :</span> Tableau de vérité pour l'encodeur 3 bits</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(D_0\)</th>
<th scope="col" class="org-right">\(D_1\)</th>
<th scope="col" class="org-right">\(D_2\)</th>
<th scope="col" class="org-right">\(D_3\)</th>
<th scope="col" class="org-right">\(D_4\)</th>
<th scope="col" class="org-right">\(D_5\)</th>
<th scope="col" class="org-right">\(D_6\)</th>
<th scope="col" class="org-right">\(D_7\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-right">\(z\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Cette configuration d'encodeur exige qu'une seule entrée ne soit
activée à la fois. Activer plus d'une entrée ne correspond en effet à
rien de valide: comment donner un sens à une telle combinaison au
moyen d'un vecteur de \(n\) bits? Les sorties produites alors seront
des vecteurs binaires sans signification.
</p>
</div>

<div id="outline-container-orgbd46903" class="outline-4">
<h4 id="orgbd46903"><span class="section-number-4">6.10.1.</span> Encodeur à priorité</h4>
<div class="outline-text-4" id="text-6-10-1">
<p>
Une encodeur à priorité met en oeuvre une priorité entre les
entrées. Si plus d'une entrée sont 1 en même temps, la sortie sera
celle qui correspond à l'entrée active qui a la plus grande
priorité. Voici le tableau de vérité pour un encodeur 2 bits à priorité,
dans lequel on a ajouté une sortie \(V\) qui indique la validité des
sorties. Si aucune entrée n'est active, \(V=0\) et les sorties \(x\)
et \(y\) ne doivent pas être prises en compte.
</p>

<p>
Lorsque des entrées sont activées, c'est celle qui a le plus grand
indice qui est prioritaire.
</p>

<table id="org512738e" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 31 :</span> Tableau de vérité pour encodeur 2 bits à priorité</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">\(D_0\)</th>
<th scope="col" class="org-right">\(D_1\)</th>
<th scope="col" class="org-right">\(D_2\)</th>
<th scope="col" class="org-right">\(D_3\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-right">\(y\)</th>
<th scope="col" class="org-right">\(V\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">X</td>
<td class="org-right">X</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">X</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">X</td>
<td class="org-right">X</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">X</td>
<td class="org-right">X</td>
<td class="org-right">X</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>


<div id="org6017e74" class="figure">
<p><img src="Images_svg/kmap4foncencode_pri_x.svg" alt="kmap4foncencode_pri_x.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;62&nbsp;: </span>Diag-K pour \(x\) de l'encodeur à priorité</p>
</div>


<div id="org4d494d4" class="figure">
<p><img src="Images_svg/kmap4foncencode_pri_y.svg" alt="kmap4foncencode_pri_y.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;63&nbsp;: </span>Diag-K pour \(y\) de l'encodeur à priorité</p>
</div>

<p>
En simplifiant, on trouve les expressions suivantes:
</p>

<p>
\[ x = D_2 + D_3 \]
</p>

<p>
\[ y = (D_1 D_2^\prime) + D_3 \]
</p>

<p>
\[ V = D_0 + D_1 + D_2 + D_3 \]
</p>


<div id="org0aa655f" class="figure">
<p><img src="Images_svg/encode_pri.svg" alt="encode_pri.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;64&nbsp;: </span>Encodeur 2 bits à priorité, en P de S</p>
</div>

<p>
Puisque le terme \(x = D_2 + D_3\) est déjà calculé pour \(x\), on
peut le réutiliser pour construire le terme pour \(V\), tel
qu'illustré ci-dessous, ce qui évite d'utiliser une porte OU à quatre
entrées.
</p>


<div id="org3e4a36d" class="figure">
<p><img src="Images_svg/encode_pri2.svg" alt="encode_pri2.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;65&nbsp;: </span>Encodeur 2 bits à priorité avec ré-utilisation d'un des termes</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org1053c8a" class="outline-3">
<h3 id="org1053c8a"><span class="section-number-3">6.11.</span> Comparateur de magnitude</h3>
<div class="outline-text-3" id="text-6-11">
<p>
Comparer la magnitude de deux nombres binaires est une opération qui
peut se systématiser, comme on l'a fait pour l'addition. Considérons
deux nombres binaires non-signés, \(A\) et \(B\) de même taille \(n\),
avec leurs bits respectifs \(a_i\) et \(b_i\). On veut que notre
comparateur active une de trois sorties, selon le cas: \(A < B\), \(A
= B\) ou \(A > B\). Pour illustrer, nous considérerons \(n = 4\).
</p>

<p>
\[ a_3 a_2 a_1 a_0 \]
</p>

<p>
\[ b_3 b_2 b_1 b_0 \]
</p>

<p>
Nous aurons besoin d'une fonction qui permet de déterminer si deux
bits sont égaux. Cette fonction correspond à la fonction <b>Équivalence</b>
ou NOR-exclusif \(a_i b_i + a_i^\prime b_i^\prime\).  Si les bits
diffèrent en position \(i\), \(a_i = 1\) nous permet de conclure que
\(A > B\), et, à l'inverse, \(a_i = 0\) nous indique que \(A < B\). Nous avons ainsi
les éléments qui permettent d'effectuer une comparaison pour un bit,
comme on peut en voir l'implémentation sur la figure suivante.
</p>


<div id="org2fb5ad4" class="figure">
<p><img src="Images_svg/comparateur.svg" alt="comparateur.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;66&nbsp;: </span>Comparateur de magnitude</p>
</div>

<p>
Notre démarche de conception pour \(n\) bits sera calquée sur la
procédure que nous utilisons intuitivement pour faire une telle
comparaison. La comparaison commence au niveau du bit le plus
significatif. Si ces bits sont égaux, on considère la position
suivante, jusqu'à atteindre une position \(i\) où les bits diffèrent
ou la fin des nombres (c'est-à-dire \(i=0\)). Si les bits diffèrent en
position \(i\), \(a_i = 1\) nous permet de conclure que \(A > B\),
alors que \(a_i = 0\) nous indique que \(A < B\).
</p>

<p>
Les signaux intermédiaires \(x_i = a_i b_i + a_i^\prime b_i^\prime\)
qui indiquent si deux bits d'une position sont égaux seront mis à
profit pour alimenter un réseau de conditions en forme somme de
produits qui mettront en application les règles énoncées. Les signaux
de sortie binaires sont \((A = B), (A < B), (A > B)\).  D'une part,
la régularité des opérations simplifie la conception et, d'autre part,
l'implémentation sera simplifiée du fait que certains des termes
nécessaires peuvent être réutilisés.
</p>

<p>
\[ (A = B) = x_3 x_2 x_1 x_0 \] 
</p>

<p>
\[ (A < B) = a_3^\prime b_3 + x_3  a_2^\prime b_2  +  x_3 x_2  a_1^\prime b_1 +  x_3 x_2 x_1  a_0^\prime b_0 \]
</p>

<p>
\[ (A > B) = a_3 b_3^\prime + x_3  a_2 b_2^\prime  +  x_3 x_2  a_1 b_1^\prime +  x_3 x_2 x_1  a_0 b_0^\prime \]
</p>

<p>
On obtient ainsi un comparateur pour des nombres de 4 bits, tel qu'illustré.
</p>


<div id="org3e3a00a" class="figure">
<p><img src="Images_svg/comparateur_4b.svg" alt="comparateur_4b.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;67&nbsp;: </span>Comparateur de magnitude 4 bits</p>
</div>
</div>
</div>

<div id="outline-container-orgf38e804" class="outline-3">
<h3 id="orgf38e804"><span class="section-number-3">6.12.</span> Démultiplexeur</h3>
<div class="outline-text-3" id="text-6-12">
<p>
Un démultiplexeur achemine la valeur logique de son entrée à une
sortie (parmi \(2^n\) sorties) sélectionnée par un code binaire de
sélection. Le démultiplexeur de la figure suivante comporte trois bits
de sélection, et permet donc d'acheminer la valeur de l'entrée \(I\)
vers une des huit sorties \(O_i, i = 0, \ldots, 7\). On peut aussi
interpréter ce circuit comme un décodeur trois-vers-huit avec une
entrée signal de contrôle (<i>enable</i>) \(I\).
</p>


<div id="org8792ad4" class="figure">
<p><img src="Images_svg/demux8.svg" alt="demux8.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;68&nbsp;: </span>Démultiplexeur un-vers-huit</p>
</div>
</div>
</div>

<div id="outline-container-orgd787a11" class="outline-3">
<h3 id="orgd787a11"><span class="section-number-3">6.13.</span> Encodeurs divers</h3>
<div class="outline-text-3" id="text-6-13">
<p>
Il est possible de concevoir des encodeurs pour des fonctions
spécialisées, comme des encodeurs pour commander des affichages. La
démarche de conception s'apparente largement à celles que nous avons
vu dans les exemples précédents.
</p>
</div>
</div>


<div id="outline-container-org1dec145" class="outline-3">
<h3 id="org1dec145"><span class="section-number-3">6.14.</span> Portes à trois états et tampon de bus</h3>
<div class="outline-text-3" id="text-6-14">
<p>
Les portes à trois états ajoutent un troisième état de fonctionnement
aux sorties: en plus des niveaux logiques bas et haut conventionnels,
un troisième état appelé <b>haute-impédance</b> fait en sorte que la sortie
se comporte comme si elle n'était plus connectée au circuit. La sortie
n'agit pas sur le reste du circuit, les autres portes dont les entrées
sont alimentés par la porte en haute-impédance ne sont aucunement
affectées par celle-ci. Pour activer cet état de sortie
haute-impédance, une entrée de contrôle est ajoutée.
</p>


<p>
Le figure ci-dessous montre une porte tampon à trois états. Avec
<code>Contrôle</code> = 0, la sortie est en haute impédance; avec  <code>Contrôle</code> = 1,
la sortie est égale à l'entrée.
</p>


<div id="org1610696" class="figure">
<p><img src="Images_svg/buf_3s.svg" alt="buf_3s.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;69&nbsp;: </span>Porte tampon à trois états</p>
</div>

<p>
En plaçant des tampons à trois états à chaque sortie d'un décodeur, on
peut réaliser un multiplexeur \(n\)-vers-un en reliant les sorties des
tampons à une sortie unique. Ainsi, lorsque qu'une entrée est
sélectionnée au moyen des entrées de sélection, c'est sa valeur qui se
retrouve à la sortie du dispositif. La valeur Z représente l'état
haute-impédance.  Lorsque l'entrée de contrôle \(E = 0\), la sortie est
en haute-impédance.
</p>

<table id="org51fa895" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 32 :</span> Tableau de vérité pour un  multiplexeur quatre-vers-un trois états</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(s_1\)</th>
<th scope="col" class="org-right">\(S_0\)</th>
<th scope="col" class="org-right">\(E\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(I_0\)</th>
<th scope="col" class="org-left">\(I_1\)</th>
<th scope="col" class="org-left">\(I_2\)</th>
<th scope="col" class="org-left">\(I_3\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(Y\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">X</td>
<td class="org-right">X</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">Z</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(I_0\)</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(I_0\)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">X</td>
<td class="org-left">\(I_1\)</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(I_1\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">\(I_2\)</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(I_2\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">\(I_3\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(I_3\)</td>
</tr>
</tbody>
</table>



<div id="org6cc2b6b" class="figure">
<p><img src="Images_svg/mux_4_1_3s.svg" alt="mux_4_1_3s.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;70&nbsp;: </span>Multiplexeur quatre-vers-un trois états</p>
</div>

<p>
La fonctionnalité trois-états permet aussi de concevoir un
émetteur-récepteur de bus. Ce dispositif, illustré à la figure
suivante, permet d'établir une connexion bidirectionnelle entre <code>I/O</code> et
<code>O/I</code>. Lorsque l'entrée de contrôle \(E = 0\), c'est le tampon du haut
qui est actif, et <code>O/I</code> détermine la valeur de <code>I/O</code>. Lorsque \(E = 1\),
c'est le tampon du bas qui est actif, et <code>I/O</code> détermine la valeur de
<code>O/I</code>.
</p>


<div id="orgade81bc" class="figure">
<p><img src="Images_svg/bus_trans.svg" alt="bus_trans.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;71&nbsp;: </span>Emetteur-récepteur de bus</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org1b7a21f" class="outline-2">
<h2 id="org1b7a21f"><span class="section-number-2">7.</span> Circuits séquentiels</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org985d274" class="outline-3">
<h3 id="org985d274"><span class="section-number-3">7.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>Pouvoir identifier un circuit logique séquentiel</li>
<li>Savoir distinguer entre les circuits séquentiels synchrones et asynchrones</li>
<li>Être familier avec les principaux types de loquets, pouvoir en
expliquer le fonctionnement</li>
<li>Être familier avec les principaux types de bascules, pouvoir en
expliquer le fonctionnement</li>
</ul>
</div>
</div>

<div id="outline-container-org9a73490" class="outline-3">
<h3 id="org9a73490"><span class="section-number-3">7.2.</span> Modèle d'un circuit séquentiel</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Les circuits logiques séquentiels sont ceux qui comportent de la
mémoire. Le modèle général d'un circuit séquentiel est illustré sur la
figure <a href="#org5ed0b54">72</a>. On y voit qu'il y a une boucle de rétroaction,
qui fait que les valeurs binaires stockées dans les éléments de
mémoire contribuent au calcul des sorties. Les sorties du circuit à un
instant donné ne dépendent donc pas seulement des entrées présentes à
ce moment, mais aussi de ces valeurs qui sont mémorisées dans le
système. Pour décrire cette situation dans laquelle se trouvent les
valeurs stockées en mémoire, on parle de l'<b>état</b> du système. Selon
les entrées et l'état à un instant donné, le système pourra changer
d'état selon les changements qui seront apportés par la portion
combinatoire aux valeurs mémorisées.
</p>

<p>
On verra donc le système évoluer au fil du temps, passant d'un état à
un autre, et générant des sorties en fonction des entrées et de l'état
du moment. Intuitivement, on peut penser que le nombre d'états
distincts sera fonction du nombre de valeurs binaires qui seront
mémorisées. Le comportement d'un système séquentiel est donc
caractérisé par une séquence temporelle d'entrées, de sorties et de
valeurs interne d'état.
</p>


<div id="org5ed0b54" class="figure">
<p><img src="Images_png/circuit_seq.png" alt="circuit_seq.png" />
</p>
<p><span class="figure-number">Figure&nbsp;72&nbsp;: </span>Modèle de circuit séquentiel</p>
</div>

<p>
On peut distinguer les circuits séquentiels selon la relation de
synchronisation qui existe entre les différents signaux du
système. Dans un circuit séquentiel <b>synchrone</b>, le comportement du
système peut se définir en fonction des valeurs de ses signaux à des
instants discrets prédéterminés. 
</p>

<p>
Le comportement d'un circuit séquentiel <b>asynchrone</b> dépend à tout
moment des signaux d'entrée et de l'ordre dans lequel ces signaux
changent.
</p>

<p>
Un circuit séquentiel synchrone fait appel à un signal spécial appelé
<b>horloge</b> qui rythme les changement d'état et de sorties afin qu'il se
produisent à des instants discrets. Les éléments de mémoire qui
stockent les valeurs binaires sont appelés <b>bascules</b> (<i>flip-flops</i> en
anglais). Il existe différents types de bascules. Nous les étudierons
en détail, car elles sont à la base des circuits séquentiels les plus
utilisés. La figure <a href="#orge25ccab">73</a> présente le modèle général d'un
circuit séquentiel synchrone.
</p>


<div id="orge25ccab" class="figure">
<p><img src="Images_png/circuit_seq_sync.png" alt="circuit_seq_sync.png" />
</p>
<p><span class="figure-number">Figure&nbsp;73&nbsp;: </span>Modèle de circuit séquentiel synchrone</p>
</div>

<p>
Le signal d'horloge est typiquement une onde carrée, telle
qu'illustré sur la figure <a href="#orgbe11fa9">74</a>.
</p>


<div id="orgbe11fa9" class="figure">
<p><img src="Images_svg/horloge.svg" alt="horloge.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;74&nbsp;: </span>Signal d'horloge</p>
</div>
</div>
</div>

<div id="outline-container-org9c125a8" class="outline-3">
<h3 id="org9c125a8"><span class="section-number-3">7.3.</span> Éléments de mémoire</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Un élément de mémoire peut maintenir son état binaire indéfiniment (à
condition, évidemment, qu'il soit alimenté). Son état est observable
par l'intermédiaire de ses sorties. On doit agir via la ou les entrées
de l'élément pour le faire changer d'état. Les différents types
d'éléments de mémoire sont caractérisés par le nombre et le type
d'entrées.
</p>

<p>
Les éléments de mémoire qui sont contrôlés par les niveaux de leurs
entrées sont appelés des <b>loquets</b> (<i>latches</i> en anglais). Les
éléments contrôlés par des changements ou <b>transitions</b> de niveaux
sont appelés des bascules. Les transitions sont appliquées à une
entrée spéciale d'horloge qui sert à déclencher les changements d'état
à des instants précis. Les loquets sont des ingrédients de base dans
la conception des bascules. Nous les étudierons en premier.
</p>
</div>
</div>

<div id="outline-container-orgf4c1fce" class="outline-3">
<h3 id="orgf4c1fce"><span class="section-number-3">7.4.</span> Loquets</h3>
<div class="outline-text-3" id="text-7-4">
</div>
<div id="outline-container-org14392cf" class="outline-4">
<h4 id="org14392cf"><span class="section-number-4">7.4.1.</span> Loquet SR</h4>
<div class="outline-text-4" id="text-7-4-1">
<p>
Le loquet SR est formé de deux portes NOR interconnectées et comporte
deux entrées: \(S\) pour <code>Set</code>, qui permet de mémoriser une valeur 1,
et \(R\) pour <code>Reset</code>, qui permet de mémoriser une valeur 0. Le schéma
classique du loquet SR montré sur la figure <a href="#orgf2f2b5b">75</a> ne fait pas
ressortir la boucle de rétroaction, mais si on déplace un peu les
éléments sans changer les connexions, on voit mieux le lien de retour
caractéristique de la boucle. Sur la figure <a href="#org6f7a717">76</a>, la porte reliée
à \(S\) a été placée devant, mais nous aurions pu tout aussi bien
mettre l'autre porte en avant. Aucune des deux n'est vraiment devant
l'autre, puisqu'il s'agit d'une boucle n'ayant ni début ni fin.
</p>


<div id="orgf2f2b5b" class="figure">
<p><img src="Images_svg/SRlatch.svg" alt="SRlatch.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;75&nbsp;: </span>Schéma du loquet SR avec portes NOR</p>
</div>



<div id="org6f7a717" class="figure">
<p><img src="Images_svg/SRlatch_bouc.svg" alt="SRlatch_bouc.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;76&nbsp;: </span>Schéma du loquet SR NOR mettant la boucle en évidence</p>
</div>

<p>
Quand les sorties sont \(Q=1, Q^\prime=0\), on dit que le loquet est
dans l'état activé (<code>set</code>). Lorsque \(Q=0, Q^\prime=1\), le loquet
est désactivé (<code>reset</code>). Les sorties \(Q\) et \(Q^\prime\) sont
normalement complémentaires. Si on active la condition d'entrée \(S=1,
R=1\), les deux sorties seront à 0, mais lorsqu'on relâchera les
entrées, le loquet passera à un état imprévisible, voire
instable. Dans une application normale, on voudra éviter la cas
d'entrée \(S=1, R=1\). 
</p>

<p>
En fonctionnement normal, à moins de vouloir changer l'état, on garde
les deux entrées à \(S=0, R=0\) et l'état du loquet se maintient. En
appliquant le niveau 1 pendant un certain temps à \(S\) seulement, le
loquet s'active, peu importe l'état dans lequel il se trouvait
auparavant. On doit s'assurer de ramener l'entrée \(S\) à 0 avant
d'effectuer d'autres changements aux entrées, pour éviter le cas
interdit \(S=1, R=1\).
</p>

<p>
De même, en appliquant le niveau 1 pendant un certain
temps à \(R\) seulement, le loquet se désactive, peu importe l'état
dans lequel il se trouvait auparavant.
</p>

<table id="org36ae46b" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 33 :</span> Loquet SR NOR: tableau de fonctionnement</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(S\)</th>
<th scope="col" class="org-right">\(R\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(Q\)</th>
<th scope="col" class="org-right">\(Q^\prime\)</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">après \(s=1, R=0\)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">après \(s=0, R=1\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">interdit</td>
</tr>
</tbody>
</table>

<p>
On peut aussi concevoir un loquet avec des portes NAND, comme sur la
figure <a href="#org5769216">77</a>. Le fonctionnement est sensiblement le même,
si ce n'est que les niveaux sont inversés par rapport au loquet NOR
comme on peut le voir sur le tableau de fonctionnement (tableau
<a href="#org254c98c">34</a>). Par exemple, on garde les deux entrées à \(S=1, R=1\)
pour maintenir l'état du loquet.
</p>


<div id="org5769216" class="figure">
<p><img src="Images_svg/SRlatch_nand.svg" alt="SRlatch_nand.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;77&nbsp;: </span>Loquet SR en portes NAND</p>
</div>

<table id="org254c98c" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 34 :</span> Loquet SR NAND: tableau de fonctionnement</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(S\)</th>
<th scope="col" class="org-right">\(R\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(Q\)</th>
<th scope="col" class="org-right">\(Q^\prime\)</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">après \(s=1, R=0\)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">après \(s=0, R=1\)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">interdit</td>
</tr>
</tbody>
</table>

<p>
On peut ajouter un signal de contrôle d'entrée \(E\) (<i>enable</i>) pour
contrôler <b>quand</b> le loquet pourra être affecté par les signaux
d'entrée. Le circuit est représenté à la figure <a href="#org34d3455">78</a>. Comme
on peut voir dans le tableau <a href="#org59bccb7">35</a>, les sorties des portes
NAND d'entrée demeurent à 1 tant que \(E = 0\), et le loquet ne peut
pas être affecté par les entrées \(S\) et \(R\). Quand on active \(E
= 1\), le circuit peut être actionné par les entrées \(S\) et \(R
\). La condition pour activer est \(S=1, R=0\); pour désactiver,
c'est \(S=0, R=1\). Lorsque \(E = 1\), on ne doit pas faire \(S=1,
R=1\), car on mettrait le loquet dans un état indéterminé.
</p>

<p>
Le loquet SR avec contrôle est surtout important comme
ingrédient de base pour la conception de bascules.
</p>


<div id="org34d3455" class="figure">
<p><img src="Images_svg/SRlatch_nand_en.svg" alt="SRlatch_nand_en.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;78&nbsp;: </span>Loquet SR NAND avec signal de contrôle</p>
</div>

<table id="org59bccb7" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 35 :</span> Loquet SR avec signal de contrôle: tableau de fonctionnement</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(E\)</th>
<th scope="col" class="org-right">\(S\)</th>
<th scope="col" class="org-right">\(R\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">prochain \(Q\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">X</td>
<td class="org-right">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">inchangé</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">inchangé</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(Q = 0\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(Q = 1\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">indéterminé</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orge8661fa" class="outline-4">
<h4 id="orge8661fa"><span class="section-number-4">7.4.2.</span> Loquet D</h4>
<div class="outline-text-4" id="text-7-4-2">
<p>
Une option pour éliminer la condition qui fait apparaître un état
indéterminé est de s'assurer de toujours commander \(S\) et \(R\)
avec des signaux complémentaires. C'est ainsi qu'on arrive au loquet
D, illustré sur la figure <a href="#org11e907c">79</a>, qui ne comporte qu'une entrée de
données \(D\) et une entrée de contrôle \(E\). La valeur de \(D\) est
reflétée à \(Q\) lorsque \(E=1\) et se maintient après que \(E\) passe
à 0 (tableau <a href="#org40bbd81">36</a>).
</p>


<div id="org11e907c" class="figure">
<p><img src="Images_svg/Dlatch.svg" alt="Dlatch.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;79&nbsp;: </span>Schéma du loquet D</p>
</div>

<table id="org40bbd81" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 36 :</span> Loquet D: tableau de fonctionnement</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(E\)</th>
<th scope="col" class="org-right">\(D\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">prochain \(Q\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">inchangé</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(Q = 0\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(Q = 1\)</td>
</tr>
</tbody>
</table>

<p>
Le symbole graphique d'un loquet D est illustré à la figure <a href="#orgc4d4286">80</a>.
</p>


<div id="orgc4d4286" class="figure">
<p><img src="Images_svg/schema_latchD.svg" alt="schema_latchD.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;80&nbsp;: </span>Symbole du loquet D</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org99744a1" class="outline-3">
<h3 id="org99744a1"><span class="section-number-3">7.5.</span> Application: rebonds d'interrupteurs</h3>
<div class="outline-text-3" id="text-7-5">
<p>
Lorsqu'on utilise un interrupteur pour commuter un signal entre les
niveaux qui correspondent aux valeurs logiques 0 et 1, le contact ne
se fait pas de façon franche sans hésitations, et le signal observé
rebondit plusieurs fois avant de se stabiliser à sa valeur, comme on
peut le voir sur la partie de gauche de la figure <a href="#org6da3358">81</a>. Ces
rapides aller-retours entre les niveaux peuvent bien souvent
déclencher un circuit logique et le mettre dans un état
imprévisible. Pour éviter ce problème, on peut faire appel à un loquet
selon la configuration de la partie droite de la figure. Le loquet
réagit dès que l'entrée B passe à 0. Même si cette entrée remonte à 1,
la valeur \(Q\) est maintenue. On obtient donc une transition franche sur
\(Q\).
</p>


<div id="org6da3358" class="figure">
<p><img src="Images_svg/debounce.svg" alt="debounce.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;81&nbsp;: </span>Contacts et rebonds</p>
</div>
</div>
</div>

<div id="outline-container-org2610970" class="outline-3">
<h3 id="org2610970"><span class="section-number-3">7.6.</span> Bascules (Flip Flops)</h3>
<div class="outline-text-3" id="text-7-6">
<p>
Les loquets peuvent remplir le rôle de mémoriser des valeurs binaires,
mais le fait que les changements d'état soient activés par un <b>niveau</b>
pose des difficultés. En effet, si les valeurs à l'entrée changent
pendant que le signal de contrôle est actif, la valeur qui sera
mémorisée par la rétroaction sera la dernière qui aura eu le temps de
s'y établir, qui ne sera pas nécessairement la valeur que le
concepteur voulait. Si la sortie du loquet est acheminée, directement
ou à travers un circuit combinatoire, vers ses entrées ou les entrées
d'autres loquets (activés par le même signal de contrôle) dans une
boucle du circuit séquentiel, il se peut que les délais de propagation
et de prise en compte des entrées fassent que la sortie globale du
circuit séquentiel soit imprévisible.
</p>

<p>
La conception des bascules vise à corriger ce problème, en établissant
un instant précis et prévisible de déclenchement où les valeurs
d'entrée seront prises en compte systématiquement. Le concept
essentiel est que l'état d'une bascule est modifié uniquement au
moment où il y a un changement dans son signal de contrôle. Ce
changement momentané est appelé <b>transition</b> et on dit que c'est la
transition qui provoque le changement d'état qui <b>déclenche</b> la
bascule.
</p>

<p>
On parlera de déclenchement sur le <b>front montant</b> lorsque la
transition qui provoque le déclenchement passe d'un niveau bas vers un
niveau élevé, et de déclenchement sur le <b>front descendant</b> dans le
cas d'une transition du haut vers le bas.  On illustre parfois le
front de déclenchement au moyen d'une flèche, comme on peut le voir
sur la figure <a href="#orgb8e0b4c">82</a>.
</p>


<div id="orgb8e0b4c" class="figure">
<p><img src="Images_svg/horlogeP.svg" alt="horlogeP.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;82&nbsp;: </span>Signaux d'horloge avec fronts de déclenchement</p>
</div>
</div>

<div id="outline-container-org2632d34" class="outline-4">
<h4 id="org2632d34"><span class="section-number-4">7.6.1.</span> Bascule D</h4>
<div class="outline-text-4" id="text-7-6-1">
<p>
Le secret pour isoler la valeur mémorisée par l'élément de mémoire des
changements qui pourraient survenir sur les entrées consiste à
utiliser un mécanisme semblable à celui d'un sas. Selon Larousse, la
définition d'un sas est
</p>

<blockquote>
<p>
Enceinte ou passage clos, muni de deux portes ou systèmes de fermeture
dont on ne peut ouvrir l'un que si l'autre est fermé et qui permet de
passer ou de faire passer d'un milieu à un autre en maintenant ceux-ci
isolés l'un de l'autre.
</p>
</blockquote>

<p>
Dans notre contexte, nous utiliserons deux loquets en série, avec la
sortie du premier, appelé <b>maître</b> reliée à l'entrée du deuxième,
appelé <b>esclave</b>. Le loquet maître sera activé par le signal d'horloge
alors que le loquet esclave sera activé par le complément du signal
d'horloge. De cette façon, un seul des loquets sera actif à la fois,
comme dans un sas. La figure <a href="#org24d8ab6">83</a> illustre la
configuration pour réaliser une bascule D maître-esclave.
</p>


<div id="org24d8ab6" class="figure">
<p><img src="Images_svg/D_mast_slave_sanst.svg" alt="D_mast_slave_sanst.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;83&nbsp;: </span>Bascule D maître-esclave</p>
</div>

<p>
Lorsque le signal d'horloge est au niveau haut, seul le loquet maître
pourra réagir au signal d'entrée. Puis, lorsque le signal d'horloge
sera au niveau bas, ce premier loquet sera désactivé, sa sortie sera
maintenue, et le deuxième loquet sera activé. Comme l'entrée du loquet
esclave est alimentée par le loquet maître dont la sortie est
maintenue, c'est la valeur mémorisée par le maître qui sera mémorisée
dans l'esclave, et qui apparaîtra donc en sortie de l'ensemble.
</p>

<p>
La valeur qui sera ultimement mémorisée est celle qui se trouvait tout
juste avant la transition de l'horloge passant du niveau haut vers le
niveau bas. Nous avons donc créé une bascule sensible au front
descendant.
</p>

<p>
En résumé:
</p>
<ol class="org-ol">
<li>La sortie \(Q\) ne changera qu'une seule fois par cycle d'horloge.</li>
<li>Un changement de valeur sera causé par la valeur d'entrée présente
juste avant le front descendant de l'horloge.</li>
<li>La valeur de sortie changera effectivement (s'il y a lieu) pendant
la demi-période basse de l'horloge.</li>
</ol>

<p>
D'autres configuations permettent de réaliser ce comportement de
sas. Par exemple, le circuit de la figure <a href="#orgab22d93">84</a> utilise
trois éléments en loquet SR NAND: les deux premiers sont activés par
le signal de donnée \(D\) et l'horloge, et le dernier mémorise et
fournit le signal de sortie \(Q\). Cette configuration réalise une
bascule D à déclenchement sur front montant.
</p>


<div id="orgab22d93" class="figure">
<p><img src="Images_svg/D_front_montant.svg" alt="D_front_montant.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;84&nbsp;: </span>Bascule D à déclenchement sur front montant</p>
</div>

<p>
Pour bien comprendre son comportement, la série de figures suivantes
permet d'en suivre le fonctionnement. Sur les figures, les valeurs
binaires sont indiqués par des couleurs: un signal en vert sombre
dénote la valeur 0 et un signal en vert clair représente la valeur 1.
</p>

<p>
Comme on peut voir sur la figure <a href="#org70a2725">85</a>, lorsque \(clk = 0\), les
entrées intermédiaires \(S\) et \(R\) sont maintenues au niveau 1,
quelle que soit la valeur de l'entrée \(D\), ce qui assure de
maintenir la valeur de sortie en \(Q\).
</p>


<div id="org70a2725" class="figure">
<p><img src="Images_svg/D_c0_d0.svg" alt="D_c0_d0.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;85&nbsp;: </span>Bascule au repos  \(clk = 0, D=0\)</p>
</div>

<p>
Même lorsque l'entrée de donnée \(D\) change, la valeur de sortie est
maintenue, comme on voit sur la figure <a href="#orge946f51">86</a>.
</p>


<div id="orge946f51" class="figure">
<p><img src="Images_svg/D_c0_d1.svg" alt="D_c0_d1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;86&nbsp;: </span>Bascule au repos  \(clk = 0, D \rightarrow 1\)</p>
</div>

<p>
Si l'entrée de donnée \(D = 0\) lorsque \(clk\) passe à 1, \(R\)
devient 0, ce qui met \(Q\) à 0 (opération <i>reset</i>) (figure
<a href="#org4867682">87</a>).
</p>


<div id="org4867682" class="figure">
<p><img src="Images_svg/D_c1_d0.svg" alt="D_c1_d0.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;87&nbsp;: </span>Bascule  <i>reset</i> \(clk \rightarrow 1, D=0\)</p>
</div>

<p>
Si l'entrée de donnée \(D\) change pendant que \(clk = 1\), comme sur
la figure <a href="#orgd9740a9">88</a>, \(R\) reste à 0, parce que la porte NAND à
trois entrées a ses trois entrées à 1: par le signal \(clk = 1\), par
la rétroaction du signal \(S\) et par le signal de sortie de la porte
NAND du bas.
</p>


<div id="orgd9740a9" class="figure">
<p><img src="Images_svg/D_c1_dchange.svg" alt="D_c1_dchange.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;88&nbsp;: </span>Bascule   \(clk = 1, D \rightarrow 1\)</p>
</div>

<p>
Quand \(clk\) revient à 0, on a \(S= 1, R=1\) et la sortie \(Q\) ne
peut plus changer.
</p>

<p>
La figure <a href="#orge1dd2da">89</a> présente la bascule dans l'état \(Q=0\)
avec l'entrée de donnée \(D = 1\), juste avant que \(clk\) passe
à 1. On voit que les deux portes NAND du haut sont prêtes à provoquer
un changement d'état de \(S\) lorsque l'horloge passera à 1.
</p>


<div id="orge1dd2da" class="figure">
<p><img src="Images_svg/D_c0_d1_avant.svg" alt="D_c0_d1_avant.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;89&nbsp;: </span>Bascule   \(clk =0, D = 1\)</p>
</div>

<p>
Si l'entrée de donnée \(D = 1\) lorsque \(clk\) passe à 1, on voit
que \(S\) est devenu 1, ce qui a amené \(Q\) à 1 (opération <i>set</i>)
(figure <a href="#org8384425">90</a>).
</p>


<div id="org8384425" class="figure">
<p><img src="Images_svg/D_c1_d1.svg" alt="D_c1_d1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;90&nbsp;: </span>Bascule  <i>set</i> \(clk \rightarrow 1, D=1\)</p>
</div>

<p>
La figure <a href="#org8fdbc1b">91</a> présente un chronogramme qui montre la bascule
qui passe de l'état 0 à l'état 1 et retourne, au cycle suivant, à
l'état 0.
</p>


<div id="org8fdbc1b" class="figure">
<p><img src="Images_svg/chron_D.svg" alt="chron_D.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;91&nbsp;: </span>Chronogramme pour une bascule D</p>
</div>
</div>
</div>

<div id="outline-container-orgeaec931" class="outline-4">
<h4 id="orgeaec931"><span class="section-number-4">7.6.2.</span> Délais et réponse temporelle</h4>
<div class="outline-text-4" id="text-7-6-2">
<p>
Comme dans tout circuit logique, les changements de valeurs logiques
dans les différentes portes qui constituent une bascule ne sont pas
instantanés. Il faut donc laisser le temps nécessaire pour que les
changements puissent se propager, être pris en compte et se stabiliser.
</p>

<p>
Sur la figure <a href="#orgd9bb5a6">92</a>, on indique le délai \(t_{setup}\) entre le
moment où la valeur à l'entrée de donnée D est modifiée et la
prochaine transition de déclenchement de l'horloge. Pour assurer un
fonctionnement adéquat de la bascule, on doit respecter un temps de
<b>mise en place</b> (<i>setup</i>) minimum pendant lequel la valeur à l'entrée
de donnée D doit être maintenue <b>avant</b> la transition de
déclenchement.
</p>

<p>
On montre aussi sur la figure le délai \(t_{hold}\) entre le moment de
déclenchement, et un prochain changement de valeur à l'entrée de
donnée D. Pour un fonctionnement adéquat, on doit également respecter
un temps de <b>maintien</b> (<i>hold</i>) minimum pendant lequel la valeur à
l'entrée de donnée D doit être maintenue <b>après</b> la transition de
déclenchement de l'horloge.
</p>

<p>
Enfin, la figure montre le délai de propagation à la sortie de la
bascule \(t_{prop}\), qui se mesure entre le moment du déclenchement et
le moment où la sortie se stabilise à sa nouvelle valeur.
</p>


<div id="orgd9bb5a6" class="figure">
<p><img src="Images_svg/D_setup.svg" alt="D_setup.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;92&nbsp;: </span>Chronogramme avec temps et délais</p>
</div>

<p>
Le symbole graphique d'une bascule D comporte un petit triangle à
l'entrée d'horloge pour indiquer que le déclenchement se fait sur une
transition. Un déclenchement sur front descendant est indiqué par un
petit cercle d'inversion à l'entrée d'horloge.
</p>


<div id="orgfb0206a" class="figure">
<p><img src="Images_svg/schema_bascules.svg" alt="schema_bascules.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;93&nbsp;: </span>Symboles de bascules</p>
</div>
</div>
</div>

<div id="outline-container-orge4252cd" class="outline-4">
<h4 id="orge4252cd"><span class="section-number-4">7.6.3.</span> Autres bascules</h4>
<div class="outline-text-4" id="text-7-6-3">
<p>
Il y a essentiellement trois opérations possibles pour une bascule:
mettre sa sortie à 1 (<i>set</i>), mettre sa sortie à 0 (<i>reset</i>) ou faire
basculer son état de sortie (<i>toggle</i>).
</p>
</div>
</div>

<div id="outline-container-org4dd8153" class="outline-4">
<h4 id="org4dd8153"><span class="section-number-4">7.6.4.</span> Bascule JK</h4>
<div class="outline-text-4" id="text-7-6-4">
<p>
Une bascule JK comporte deux entrées, ce qui permet de lui faire
exécuter les trois opérations. Activer seulement l'entrée \(J\) fait
un <i>set</i>, activer seulement l'entrée \(K\) fait un <i>reset</i> et activer
les deux entrées fait un <i>toggle</i>. On peut réaliser une bascule JK
comme sur la figure <a href="#org43f1485">94</a>.
</p>


<div id="org43f1485" class="figure">
<p><img src="Images_svg/bascule_JK.svg" alt="bascule_JK.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;94&nbsp;: </span>Bascule JK</p>
</div>

<p>
La figure <a href="#org1ad1834">95</a> montre le chronogramme de fonctionnement
d'une bascule JK. La bascule fait d'abord un <i>set</i>, puis un <i>reset</i> et
enfin trois <i>toggles</i> de suite.
</p>


<div id="org1ad1834" class="figure">
<p><img src="Images_svg/chron_JK.svg" alt="chron_JK.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;95&nbsp;: </span>Chronogramme de la bascule JK</p>
</div>
</div>
</div>

<div id="outline-container-org9264659" class="outline-4">
<h4 id="org9264659"><span class="section-number-4">7.6.5.</span> Bascule T</h4>
<div class="outline-text-4" id="text-7-6-5">
<p>
La bascule T (T pour <i>toggle</i>) change d'état à chaque déclenchement
lorsque l'entrée \(T\) est activée. On peut la réaliser à partir d'une
bascule D ou d'une bascule JK (figure <a href="#org6f9e1fb">96</a>).
</p>


<div id="org6f9e1fb" class="figure">
<p><img src="Images_svg/basculeT.svg" alt="basculeT.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;96&nbsp;: </span>Bascule T</p>
</div>
</div>
</div>

<div id="outline-container-org99887b4" class="outline-4">
<h4 id="org99887b4"><span class="section-number-4">7.6.6.</span> Tableaux caractéristiques</h4>
<div class="outline-text-4" id="text-7-6-6">
<p>
On résume le fonctionnement des différentes bascules au moyen de
tableaux qui décrivent, selon les conditions d'entrée et l'état
présent, quel sera le prochain état après le déclenchement. \(Q(t)\)
représente l'état présent et \(Q(t+1)\) l'état suivant.
</p>

<table id="orge6c4320" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 37 :</span> Bascule D</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(D\)</th>
<th scope="col" class="org-right">\(Q(t+1)\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><i>reset</i></td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left"><i>set</i></td>
</tr>
</tbody>
</table>

<table id="orgafdf38a" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 38 :</span> Bascule JK</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(J\)</th>
<th scope="col" class="org-right">\(K\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(Q(t+1)\)</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(Q(t)\)</td>
<td class="org-left">pas de changement</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">0</td>
<td class="org-left"><i>reset</i></td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">1</td>
<td class="org-left"><i>set</i></td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(Q^\prime(t)\)</td>
<td class="org-left">basculement</td>
</tr>
</tbody>
</table>

<table id="orgcb57d89" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 39 :</span> Bascule T</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(T\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(Q(t+1)\)</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(Q(t)\)</td>
<td class="org-left">pas de changement</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(Q^\prime(t)\)</td>
<td class="org-left">basculement</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org36c2eee" class="outline-4">
<h4 id="org36c2eee"><span class="section-number-4">7.6.7.</span> Équations caractéristiques</h4>
<div class="outline-text-4" id="text-7-6-7">
<p>
On peut de même formuler des équations qui décrivent le comportement
des bascules. Pour une bascule D, on a
</p>

<p>
\[ Q(t+1) = D \]
</p>

<p>
Pour une bascule JK, on a
</p>

<p>
\[ Q(t+1) =J Q^\prime + K^\prime Q \]
</p>

<p>
Pour une bascule T, on a
</p>

<p>
\[ Q(t+1) = T \operatorname{Xor} Q = T Q^\prime + T^\prime Q \]
</p>
</div>
</div>

<div id="outline-container-orga248a71" class="outline-4">
<h4 id="orga248a71"><span class="section-number-4">7.6.8.</span> Entrées asynchrones</h4>
<div class="outline-text-4" id="text-7-6-8">
<p>
Certaines bascules sont aussi munies d'entrées asynchrones, dont
l'effet n'est pas soumis à l'horloge. Ces entrées sont typiquement
utilisées pour faire un <i>reset</i> ou un <i>set</i> de la bascule, par exemple
pour une remise à zéro initiale d'un circuit séquentiel. Une
configuration typique est illustrée par la bascule de la figure
<a href="#orged7d855">97</a> qui comporte une entrée <code>Reset'</code> qui
permet de forcer l'état en agissant sur une porte NAND de chacune des
paires de portes. Cette entrée est active au niveau bas, c'est
pourquoi il y a une indication de complément dans son symbole.
</p>


<div id="orged7d855" class="figure">
<p><img src="Images_svg/D_front_montant_setasyn.svg" alt="D_front_montant_setasyn.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;97&nbsp;: </span>Bascule D avec reset asynchrone</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org6556936" class="outline-2">
<h2 id="org6556936"><span class="section-number-2">8.</span> Analyse de circuits logiques séquentiels synchrones</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org8508588" class="outline-3">
<h3 id="org8508588"><span class="section-number-3">8.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>Pouvoir analyser en détail le comportement d'un circuit séquentiel
synchrone à partir de son schéma, selon différents types de bascules
employées</li>
<li>Pouvoir établir les équations de transition qui commandent les bascules</li>
<li>Être familier avec la notion de tableau d'excitation</li>
<li>Pouvoir tracer un diagramme d'état</li>
<li>Pouvoir interpréter le comportement du système à partir de son
diagramme d'état</li>
<li>Savoir distinguer entre les deux modèles de circuit séquentiels
(Moore et Mealy)</li>
</ul>
</div>
</div>

<div id="outline-container-orgab2923c" class="outline-3">
<h3 id="orgab2923c"><span class="section-number-3">8.2.</span> Démarche d'analyse</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Analyser un circuit logique séquentiel a pour but de déterminer le
comportement qu'aura le circuit selon les séquences d'entrées qui lui
seront appliquées et l'état dans lequel il se trouve initialement. On
voudra aussi connaître quelles séquences de sorties seront produites.
</p>

<p>
Dans la mesure où un circuit comporte une ou des bascules (peu importe
le type) et un signal d'horloge, on peut considérer qu'il s'agit d'un
circuit séquentiel synchrone. Le type de bascule sera pris en compte
pour l'analyse, qui consistera à déterminer, pour un état présent
donné, quel seront les prochains états possibles selon les valeurs
d'entrée.
</p>

<p>
Les grandes lignes de la démarche sont les suivantes.
</p>

<ol class="org-ol">
<li>Identification des éléments fonctionnels:

<ol class="org-ol">
<li>entrées externes</li>

<li>éléments de mémoire</li>

<li>décodeur de prochain état</li>

<li>sorties externes</li>

<li>décodeur de sortie</li>
</ol></li>
<li>Expressions logiques du décodeur de prochain état: établies pour
chaque entrée des bascules, en fonction des entrées externes et des
variables d'état.</li>
<li>Expressions logiques des sorties externes, établies en fonction des
entrées externes et des variables d'état.</li>
<li>Construction du tableau d'excitation.</li>
<li>Diagramme d'état.</li>
<li>Interprétation du comportement du circuit séquentiel.</li>
</ol>

<p>
Au centre de ce processus se trouve l'analyse des circuits
combinatoires qui déterminent ce que seront les entrées des
bascules. Nous chercherons à établir les <b>équations de transition</b> qui
précisent ce que sera le prochain état en fonction des entrées et de
l'état présent.
</p>
</div>
</div>

<div id="outline-container-org657952e" class="outline-3">
<h3 id="org657952e"><span class="section-number-3">8.3.</span> Exemple d'analyse</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Nous allons appliquer la démarche à un exemple qui nous permettra de
mieux expliquer chacune des étapes. Considérons le circuit de la
figure <a href="#org7fcbef4">98</a>.
</p>


<div id="org7fcbef4" class="figure">
<p><img src="Images_svg/exemple_seq1.svg" alt="exemple_seq1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;98&nbsp;: </span>Circuit séquentiel synchrone à analyser</p>
</div>

<ol class="org-ol">
<li>Identification des éléments fonctionnels:

<ol class="org-ol">
<li>Il y a une seule entrée externe \(I\).</li>
<li>Il y a deux éléments de mémoire, étiquetés \(Z_0^n\) et  \(Z_1^n\).</li>
<li>On a un décodeur de prochain état pour deux bascules D.</li>
<li>Il y a deux sorties externes: \(S\) et \(U\).</li>
<li>Il y a un décodeur de sortie.</li>
</ol></li>

<li><p>
Expressions logiques pour le décodeur de prochain état: 
\[ Z_0^{n+1} = I \cdot (Z_1^n)^\prime  + I \cdot Z_0^n \]
</p>

<p>
\[ Z_1^{n+1} = I \cdot Z_1^n +  Z_0^n  \]
</p></li>

<li><p>
Expressions logiques des sorties externes:
\[ S =  Z_0^n \cdot (Z_1^{n})^\prime \]
</p>

<p>
\[ U =  Z_0^n \cdot Z_1^{n} \]
</p></li>

<li><p>
Tableau d'excitation
</p>

<p>
Chaque ligne du tableau d'excitation (tableau <a href="#org8c502c1">40</a>) montre, à gauche,
un état présent (identifiable par les valeurs de bascules) et une
combinaison de valeurs d'entrées, et à droite, le prochain état et les
valeurs de sortie produites.
</p>

<table id="org8c502c1" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 40 :</span> Tableau d'excitation pour l'exemple</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(Z_1^n\)</th>
<th scope="col" class="org-right">\(Z_0^n\)</th>
<th scope="col" class="org-right">\(I\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(Z_1^{n+1}\)</th>
<th scope="col" class="org-right">\(Z_0^{n+1}\)</th>
<th scope="col" class="org-right">\(S\)</th>
<th scope="col" class="org-right">\(U\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>

<li><p>
Diagramme d'état
</p>

<p>
Le diagramme d'état représente de façon schématique le comportement du
circuit séquentiel. Les cercles correspondent aux différents états
dans lesquels le système peut se trouver. On peut utiliser des
étiquettes à l'intérieur des cercles pour nommer les états. On peut
aussi y indiquer les numéros d'états (soit en vecteurs de bits, soit
avec des nombres binaires comme ici sur la figure). Les sorties
produites par le système sont aussi indiquées dans les cercles.  Les
transitions entre les états sont indiquées par des flèches. Une flèche
qui revient vers le même cercle signifie que l'état ne change pas.
</p>

<p>
Les conditions appliquées aux entrées pour déclencher les transitions
sont indiquées sur les flèches. Dans la figure, on voit aussi l'état
initial, identifié par une flèche partant d'un gros point noir.
</p>

<p>
Le diagramme d'état se construit aisément à partir du tableau
d'excitation.
</p>


<div id="orgb2a2d28" class="figure">
<p><img src="Images_svg/exemple_seq1_fsm.svg" alt="exemple_seq1_fsm.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;99&nbsp;: </span>Diagramme d'état</p>
</div></li>

<li><p>
Interprétation du comportement du circuit séquentiel.
</p>

<p>
Le système est initialement à l'état <i>a</i>. Tant que l'entrée \(I\) est 0,
il demeure dans cet état. Lorsque \(I=1\), on passe à l'état <i>b</i>. Si
\(I\) reste à 1, on passe à l'état <i>d</i> et on boucle sur l'état <i>d</i>. Si
\(I\) revient à 0, de l'état <i>b</i> ou <i>d</i>, on passe à l'état <i>c</i>. De l'état <i>c</i>,
si \(I = 1\), on reste dans l'état <i>c</i>. Sinon (\(I = 0\)), on retourne à
l'état <i>a</i>.
</p>

<p>
La figure <a href="#org139d0a8">100</a> montre une trace des formes d'onde
observées en fonctionnement pour le système. Dans cet exemple, le
système boucle d'abord sur l'état <i>a</i> (valeur 0 sur la trace) puis,
passe à l'état <i>b</i> (valeur 1) et ensuite l'état <i>d</i> (valeur 3),
boucle sur l'état <i>d</i> et passe ensuite à l'état <i>c</i> (valeur 2) pour
finalement revenir à l'état <i>a</i>.
</p>


<div id="org139d0a8" class="figure">
<p><img src="Images_svg/exemple_seq1_run.svg" alt="exemple_seq1_run.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;100&nbsp;: </span>Exemple de fonctionnement</p>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-org35ac45f" class="outline-3">
<h3 id="org35ac45f"><span class="section-number-3">8.4.</span> Analyse pour des bascules JK</h3>
<div class="outline-text-3" id="text-8-4">
<p>
Pour analyser un circuit séquentiel utilisant des bascules JK, on
détermine d'abord les expressions \(J_A\) et \(K_A\), \(J_B\) et
\(K_B\), etc., pour chacune des bascules. On doit ensuite se référer
au tableau caractéristique pour ce type de bascule (tableau
<a href="#orgafdf38a">38</a>) pour déterminer quelles seront les prochaines valeurs
de sortie pour chacune des bascules. L'exemple suivant illustre la
procédure.
</p>
</div>

<div id="outline-container-org7d1c85b" class="outline-4">
<h4 id="org7d1c85b"><span class="section-number-4">8.4.1.</span> Exemple avec bascules JK</h4>
<div class="outline-text-4" id="text-8-4-1">
<p>
Considérons le circuit séquentiel de la figure <a href="#org4744449">101</a>.
</p>


<div id="org4744449" class="figure">
<p><img src="Images_svg/seq_JK.svg" alt="seq_JK.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;101&nbsp;: </span>Exemple de circuit séquentiel avec des bascules JK</p>
</div>

<p>
À partir des expression des entrées \(J\) et \(K\) suivantes:
</p>

<p>
\[ J_0 = (q_1^{n})^\prime \]
</p>

<p>
\[ K_0 = q_0^{n} \cdot (q_1^{n})^\prime \]
</p>

<p>
\[ J_1 = q_0^{n} \]
</p>

<p>
\[ K_1 = (q_0^{n})^\prime \cdot q_1^{n} \]
</p>

<p>
on peut remplir le tableau d'excitation (tableau <a href="#org0a5888c">41</a>).
</p>

<table id="org0a5888c" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 41 :</span> Tableau d'excitation circuit séquentiel JK</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(q_1^{n+1}\)</th>
<th scope="col" class="org-right">\(q_0^n\)</th>
<th scope="col" class="org-right">\(J_0\)</th>
<th scope="col" class="org-right">\(K_0\)</th>
<th scope="col" class="org-right">\(J_1\)</th>
<th scope="col" class="org-right">\(K_1\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(q_1^{n+1}\)</th>
<th scope="col" class="org-right">\(q_0^{n+1}\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
À partir du tableau d'excitation, on peut tracer le diagramme d'état
(figure <a href="#org5e059f7">102</a>).
</p>


<div id="org5e059f7" class="figure">
<p><img src="Images_svg/seq_JKb_FSM.svg" alt="seq_JKb_FSM.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;102&nbsp;: </span>Diagramme d'état du circuit séquentiel avec bascules JK</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org3767d59" class="outline-3">
<h3 id="org3767d59"><span class="section-number-3">8.5.</span> Modèles de machines séquentielles</h3>
<div class="outline-text-3" id="text-8-5">
<p>
On appelle les modèles abstraits de systèmes séquentiels des <b>machines
à état fini</b> (en anglais, <i>Finite State Machines</i>, (FSM)).  On
distingue deux modèles de circuit séquentiels, selon la façon dont les
sortie sont obtenues. Dans le modèle de Mealy, les sorties dépendent à
la fois des entrées et des variables d'état présent (figure <a href="#orgfa7ac06">103</a>). Dans
le modèle de Moore, les sorties ne dépendent que des variables d'état présent
(figure <a href="#org13ccc63">104</a>). 
</p>


<div id="orgfa7ac06" class="figure">
<p><img src="Images_png/mealy.png" alt="mealy.png" />
</p>
<p><span class="figure-number">Figure&nbsp;103&nbsp;: </span>Machine de Mealy</p>
</div>


<div id="org13ccc63" class="figure">
<p><img src="Images_png/moore.png" alt="moore.png" />
</p>
<p><span class="figure-number">Figure&nbsp;104&nbsp;: </span>Machine de Moore</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org84b5db5" class="outline-2">
<h2 id="org84b5db5"><span class="section-number-2">9.</span> Conception de circuits logiques séquentiels</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org27e0873" class="outline-3">
<h3 id="org27e0873"><span class="section-number-3">9.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>Pouvoir concevoir un circuit logique séquentiel synchrone à partir
d'une spécification fonctionnelle</li>
<li>Savoir construire un diagramme d'état en fonction d'un besoin</li>
<li>Savoir construire un tableau d'état en fonction d'un diagramme d'état</li>
<li>Pouvoir réduire le nombre d'état nécessaires</li>
<li>Savoir comment assigner des codes binaires aux états et pouvoir
choisir une approche</li>
<li>Pouvoir concevoir un décodeur de prochain état et un décodeur de sortie</li>
</ul>
</div>
</div>

<div id="outline-container-org8644e26" class="outline-3">
<h3 id="org8644e26"><span class="section-number-3">9.2.</span> Conception d'un circuit séquentiel synchrone</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Concevoir un circuit logique séquentiel permet de répondre à un besoin
pratique qui ne peut pas être satisfait par un circuit combinatoire.
Le point de départ est une description, la plus précise possible, du
besoin à remplir: quelle doit ou doivent être les entrées, les
sorties, les conditions qui font passer d'un état au suivant,
etc. Pour un besoin donné, une multitude de solutions
fonctionnellement équivalentes sont possibles, aussi il faudra établir
des critères ou identifier des contraintes qui permettront d'orienter
la conception et le choix final d'une solution. Deux systèmes peuvent
avoir un même comportement vu de l'extérieur, mais comporter des
nombres d'états internes différents.
</p>

<p>
Des considérations pratiques nous amèneront souvent à vouloir réduire
le nombre d'états nécessaires, et à simplifier les différents circuit
combinatoires utilisés. Réduire le nombre de bascules utilisées ne se
traduit pas toujours par un système plus simple, car les décodeurs
d'état et de sortie peuvent s'en retrouver plus complexes.
</p>
</div>
</div>

<div id="outline-container-org23b6e39" class="outline-3">
<h3 id="org23b6e39"><span class="section-number-3">9.3.</span> Spécification fonctionnelle</h3>
<div class="outline-text-3" id="text-9-3">
<p>
Comme dans tout problème de conception, la formulation en mots de la
spécification du système est cruciale. Appliquer parfaitement une
procédure de conception en se basant sur une spécification erronée ne
peut pas conduire à système adéquat.
</p>

<p>
Il faudra un bon bagage d'expérience et d'intuition au concepteur pour
pouvoir interpréter et traduire correctement une description
informelle, plus souvent qu'autrement incomplète, ambiguë et
imprécise, en un design concret qui répond à un besoin maladroitement
exprimé. Il revient au concepteur de s'assurer que ce qu'il a compris
correspond bien à ce qui était demandé.
</p>

<p>
La première question à poser est: Que doit faire le système? Suivront
d'autres questions, amenant à définir davantage de détails: Combien
d'entrées sont nécessaires? Doit-il y avoir des entrées? Combien de
sorties sont nécessaires? Le comportement du système pourra être
essentiellement caractérisé en répondant à la question: Quelle doit
être la séquence des sorties, pour une certaine séquence d'entrées?
Mais comme les séquences d'entrées peuvent être en nombre infini, il
faudra identifier des patrons qui permettront de résumer le
comportement du système.
</p>
</div>
</div>

<div id="outline-container-org6924546" class="outline-3">
<h3 id="org6924546"><span class="section-number-3">9.4.</span> Diagramme d'état</h3>
<div class="outline-text-3" id="text-9-4">
<p>
Un diagramme d'état préliminaire est un bon point de départ pour
définir et étudier le comportement du système. On identifiera les
différents états par des lettres pour les distinguer sans faire
référence à des variables binaires associées à des éléments de
mémoire. Il s'agit dans un premier temps d'un diagramme préliminaire,
parce que le diagramme final qui sera implémenté sera potentiellement
différent.
</p>

<p>
À partir du diagramme d'état, il est possible de vérifier quelle
séquence de sortie correspond à une séquence d'entrée donnée, et ainsi
de valider le comportement.
</p>
</div>
</div>

<div id="outline-container-orga371fde" class="outline-3">
<h3 id="orga371fde"><span class="section-number-3">9.5.</span> Tableau d'états</h3>
<div class="outline-text-3" id="text-9-5">
<p>
Un tableau d'états comporte une ligne par état présent et combinaison
d'entrées. Selon les combinaisons d'entrées possibles, on donne le
prochain état et les valeurs de sortie.
</p>
</div>
</div>

<div id="outline-container-orgc8f928b" class="outline-3">
<h3 id="orgc8f928b"><span class="section-number-3">9.6.</span> Réduction du nombre d'états</h3>
<div class="outline-text-3" id="text-9-6">
<p>
Deux états sont équivalents si, pour chaque combinaison d'entrées, ils
produisent la même sortie et amènent le système dans le même état ou
dans un état équivalent. Considérons le diagramme d'état de la figure
<a href="#orge3afafe">105</a> et le tableau d'état correspondant (tableau 
<a href="#org0e3931f">43</a>). On peut voir qu'il s'agit ici d'une machine de
Mealy, car les valeurs de sortie sont associées aux transitions.
</p>



<div id="orge3afafe" class="figure">
<p><img src="Images_svg/exemp_simplif_net.svg" alt="exemp_simplif_net.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;105&nbsp;: </span>Diagramme d'état avant réduction</p>
</div>


<table id="org6af6a90" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 42 :</span> Tableau d'état initial</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">État présent</th>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">État suivant</th>
<th scope="col" class="org-right">\(S\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">b</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">a</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">f</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">d</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">d</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">e</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">b</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">e</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">a</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">f</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">d</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">f</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">e</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
En inspectant les différents états, on voit que les états <i>c</i> et <i>f</i>
sont équivalents. En remplaçant l'état <i>f</i> par l'état <i>c</i>, on obtient
le nouveau tableau d'état (tableau <a href="#org0e3931f">43</a>).
</p>

<table id="org0e3931f" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 43 :</span> Tableau d'état après une simplification</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">État présent</th>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">État suivant</th>
<th scope="col" class="org-right">\(S\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">b</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">a</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">d</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">d</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">e</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">b</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">e</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">a</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
On voit maintenant que les états <i>a</i> et <i>d</i> sont équivalents. En
remplaçant l'état <i>d</i> par l'état <i>a</i>, on obtient le tableau d'état
simplifié (tableau <a href="#org611ef6b">44</a>). Il n'y a plus de simplification
possible. Nous sommes passés de six états à quatre.
</p>

<table id="org611ef6b" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 44 :</span> Tableau d'état simplifié</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">État présent</th>
<th scope="col" class="org-right">\(x\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">État suivant</th>
<th scope="col" class="org-right">\(S\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">b</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">a</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">d</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">d</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">e</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">e</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">a</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Il faut bien s'assurer que le tableau d'état simplifié produit les
séquences de sortie désirées selon les séquences d'entrée appliquées.
</p>
</div>

<div id="outline-container-org87a7c33" class="outline-4">
<h4 id="org87a7c33"><span class="section-number-4">9.6.1.</span> Tableau d'implication</h4>
<div class="outline-text-4" id="text-9-6-1">
<p>
La méthode du tableau d'implication facilite l'identification des
états redondants à éliminer. Considérons le tableau d'état suivant,
qui correspond cette fois-ci à une machine de Moore dont nous allons
réduire le nombre d'états.
</p>

<table id="org86baa1f" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 45 :</span> Tableau d'état (machine de Moore)</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">État présent</th>
<th scope="col" class="org-left">État suivant</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">État suivant</th>
<th scope="col" class="org-right">\(S\)</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(x=0\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(x=1\)</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-left">g</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-left">f</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">h</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left">e</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">d</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-left">a</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-left">c</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">a</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">f</td>
<td class="org-left">f</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">b</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">g</td>
<td class="org-left">a</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">h</td>
<td class="org-left">c</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">g</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Un tableau d'implication comporte une entrée pour chaque paire d'états
dans le tableau d'état. Avec \(n\) états initialement (ici on a
\(n=8\)), on étiquettera les colonnes avec les \(n-1\) premiers états,
et les lignes avec les \(n-1\) derniers états. La première case vide,
en haut à gauche, sera notée [a;b] et la dernière en bas à droite sera
[g;h]. Voici le tableau avant d'être rempli (tableau
<a href="#org2867990">46</a>). Seules les cases qui ne comportent pas de _
peuvent être remplies. Il n'y a par exemple rien d'utile à mettre dans
une case étiquetée [b;b], et on mettra l'information qui irait dans la
case [c;b] dans la case [b;c].
</p>

<table id="org2867990" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 46 :</span> Tableau d'implication</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">b</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">d</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">f</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">g</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">h</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">a</td>
<td class="org-left">b</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
<td class="org-left">e</td>
<td class="org-left">f</td>
<td class="org-left">g</td>
</tr>
</tbody>
</table>

<ol class="org-ol">
<li>On applique la procédure en considérant chaque case du tableau, ce
qui permet de comparer chaque paire de lignes du tableau d'état.

<ul class="org-ul">
<li>On vérifie dans un premier temps si les sorties sont
différentes. Si c'est le cas, on met un &check; dans la
case. Par exemple ici, <i>a</i> et <i>c</i>, <i>a</i> et <i>e</i>, <i>a</i> et <i>f</i>, <i>a</i> et
<i>h</i> ont des sorties différentes, donc on place des &check;
dans les cases [a;c], [a;e], [a;f] et [a;h].</li>
<li>Si les sorties sont les mêmes, on place dans la case les paires
d'états qu'une équivalence nécessiterait. Par exemple pour la
case [a;b], une équivalence entre <i>a</i> et <i>b</i> nécessiterait les
équivalences g=f et c=h entre les états prochains. Pour la case
[a;d], une équivalence entre <i>a</i> et <i>d</i> nécessiterait les
équivalences g=a et c=c. Cette dernière, évidente, n'est pas
inscrite dans le tableau. Pour [b;d], on trouve f=a et h=c.</li>
<li>Si les sorties sont les mêmes et les paires d'états suivants sont
identiques ou encore sont les états mêmes qu'on est en train de
considérer, on met directement OUI dans le tableau. Par exemple,
pour la case [a;g] on a les paires g=a et c=c, donc on met
OUI. Pour la case [d;g], on a a=a et c=c, on met OUI
également. On continue ainsi, de colonne en colonne, pour obtenir
après ces étapes le résultat suivant (tableau <a href="#orged1be23">47</a>).</li>
</ul></li>
</ol>

<table id="orged1be23" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 47 :</span> Tableau d'implication, après étape 1</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">b</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">g=f c=h</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">d</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">g=a</th>
<th scope="col" class="org-left">f=a h=c</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">d=a</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">f</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">e=f d=b</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">c=f a=b</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">g</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">OUI</th>
<th scope="col" class="org-left">f=a h=c</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">OUI</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">h</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">e=c d=g</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">a=g</th>
<th scope="col" class="org-left">f=c b=g</th>
<th scope="col" class="org-left">&check;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">a</td>
<td class="org-left">b</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
<td class="org-left">e</td>
<td class="org-left">f</td>
<td class="org-left">g</td>
</tr>
</tbody>
</table>

<ol class="org-ol">
<li value="2">L'étape suivante consiste à considérer chaque case qui comporte
une ou des paires d'états impliqués. On regarde la case
correspondant à chaque paire, et s'il y a un &check; dans la
case, alors l'implication ne fonctionne pas. Par exemple, la case
[a;b] repose sur les équivalences g=f et c=h. Or si on regarde la
case [f;g], on voit qu'il s'y trouve un &check;, ce qui veut
dire que <i>f</i> et <i>g</i> ne peuvent pas être équivalents, ce qui
implique que <i>a</i> et <i>b</i> ne pourront pas être équivalents. Ce n'est
pas la peine de regarder la case [c;h].  On remplacera donc les
paires de la case [a;b] par un &check;&check;, pour faire
ressortir ces nouveaux échecs.</li>
<li>Un &check;&check; dans le tableau peut faire échouer d'autres
implications. Il faut donc revoir les cases avec des paires d'états
impliqués pour voir s'il faut changer leur statut. On continue à
revoir ainsi jusqu'à ce qu'il n'y ait plus d'ajouts de
&check;&check;. On obtient finalement le tableau suivant
(tableau <a href="#orga2d67a9">48</a>).</li>
</ol>

<table id="orga2d67a9" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 48 :</span> Tableau d'implication, après étape 3</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">b</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&check;&check;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">c</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">d</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">g=a</th>
<th scope="col" class="org-left">&check;&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">e</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">d=a</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">f</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;&check;</th>
<th scope="col" class="org-left">_</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">g</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">OUI</th>
<th scope="col" class="org-left">&check;&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">OUI</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">_</th>
</tr>

<tr>
<th scope="col" class="org-left">h</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">e=c d=g</th>
<th scope="col" class="org-left">&check;</th>
<th scope="col" class="org-left">a=g</th>
<th scope="col" class="org-left">&check;&check;</th>
<th scope="col" class="org-left">&check;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">a</td>
<td class="org-left">b</td>
<td class="org-left">c</td>
<td class="org-left">d</td>
<td class="org-left">e</td>
<td class="org-left">f</td>
<td class="org-left">g</td>
</tr>
</tbody>
</table>

<ol class="org-ol">
<li value="4">Après cette étape, toutes les  cases qui contiennent OUI ou des
paires d'implications indiquent des équivalences d'états. Ici, on a
les équivalences suivantes: a=d, a=g, c=e, c=h, d=g, e=h. Les états
uniques résultants sont <i>a</i>, <i>b</i>, <i>c</i> et <i>f</i>. On obtient le tableau
d'état réduit suivant (tableau <a href="#org42577bf">49</a>).</li>
</ol>

<table id="org42577bf" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 49 :</span> Tableau d'état réduit (machine de Moore)</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">État présent</th>
<th scope="col" class="org-left">État suivant</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">État suivant</th>
<th scope="col" class="org-right">\(S\)</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(x=0\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(x=1\)</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-left">a</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-left">f</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">c</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left">c</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">a</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">f</td>
<td class="org-left">f</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">b</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-org3609b09" class="outline-3">
<h3 id="org3609b09"><span class="section-number-3">9.7.</span> Codage des états</h3>
<div class="outline-text-3" id="text-9-7">
<p>
Une fois que le nombre d'états a été réduit, il faut assigner des
codes binaires aux états. Si on doit coder \(m\) états, il faudra
\(n\) bits, avec \(2^n \geq m\). Si le nombre de combinaisons
binaires est plus grand que le nombre d'état nécessaires, les
combinaisons inutilisées seront considérées comme des cas facultatifs.
</p>

<p>
Le choix d'une assignation des codes aux états aura des répercussions
sur la complexité du décodeur de prochain état, et sur le décodeur de
sortie. Plusieurs options peuvent être envisagées: assigner des codes
dans l'ordre naturel d'énumération binaire, assigner selon un code
Gray, ou encore choisir une assignation où il y a un seul bit 1 par
code binaire (approche dite <i>one-hot</i>). L'approche <i>one-hot</i> requiert
plus de bascules, mais permet souvent de simplifier les décodeurs de
prochain état et de sortie. Le tableau <a href="#orgc2cae29">50</a> montre
un exemple possible d'assignation pour chacune de ces approches.
</p>

<table id="orgc2cae29" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 50 :</span> Possibilités d'assignation de codes d'états</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">État</th>
<th scope="col" class="org-right">Binaire</th>
<th scope="col" class="org-right">Gray</th>
<th scope="col" class="org-right"><i>One-hot</i></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-right">00</td>
<td class="org-right">00</td>
<td class="org-right">0001</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">01</td>
<td class="org-right">01</td>
<td class="org-right">0010</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">10</td>
<td class="org-right">11</td>
<td class="org-right">0100</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-right">11</td>
<td class="org-right">10</td>
<td class="org-right">1000</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org8e9ba32" class="outline-3">
<h3 id="org8e9ba32"><span class="section-number-3">9.8.</span> Décodeur d'état</h3>
<div class="outline-text-3" id="text-9-8">
<p>
Après avoir décidé d'une assignation, on refait le tableau d'état
simplifié en remplaçant les étiquettes d'états symboliques par les
codes binaires correspondants. On obtient ainsi un <b>tableau de
transition</b>, qui permet d'élaborer les expressions logiques pour le
décodeur de prochain état. Le type de bascules à utiliser déterminera
les sorties nécessaires pour le décodeur d'état, en se basant sur les
tableaux caractéristiques de la section <a href="#org99887b4">7.6.6</a>.
</p>
</div>
</div>

<div id="outline-container-org46372ee" class="outline-3">
<h3 id="org46372ee"><span class="section-number-3">9.9.</span> Décodeur de sorties</h3>
<div class="outline-text-3" id="text-9-9">
<p>
Une fois que le codage d'état est établi, la conception du décodeur de
sortie est directe. Un tableau de vérité avec comme entrées les
valeurs binaires d'états et comme sorties les valeurs de sorties
externes permet de déterminer les fonctions combinatoires à
implémenter.
</p>
</div>
</div>

<div id="outline-container-orgcc4ae54" class="outline-3">
<h3 id="orgcc4ae54"><span class="section-number-3">9.10.</span> Procédure de conception</h3>
<div class="outline-text-3" id="text-9-10">
<p>
La conception d'un circuit séquentiel suit une procédure bien
définie. Étant donnée la complexité de cette tâche, on limite la
conception manuelle à des relativement petits circuits. Pour des
besoins plus ambitieux, des outils de synthèse automatisés ont été
développés. Ces procédures automatisées supposent typiquement des
bascules D, car la correspondance entre l'entrée et la prochaine
sortie est directe. Voici les étapes à suivre:
</p>

<ol class="org-ol">
<li>À partir de la description et des spécifications du comportement
souhaité, concevoir un diagramme d'état.</li>
<li>Réduire le nombre d'état (si pertinent).</li>
<li>Assigner des codes binaires aux états.</li>
<li>Compléter le tableau de transition.</li>
<li>Sélectionner un type de bascules à utiliser.</li>
<li>Déterminer les expressions simplifiées pour le décodeur de prochain
état et le décodeur de sortie.</li>
<li>Tracer le schéma logique du circuit.</li>
</ol>
</div>
</div>

<div id="outline-container-org43cc313" class="outline-3">
<h3 id="org43cc313"><span class="section-number-3">9.11.</span> Exemple de conception</h3>
<div class="outline-text-3" id="text-9-11">
<p>
On doit concevoir un circuit séquentiel qui détecte la séquence
binaire 101 lorsqu'elle apparaît dans sa séquence d'entrée. Une fois
la séquence identifiée, le système produira une sortie 1 et demeurera
dans le même état en continuant de produire une sortie 1, jusqu'à une
remise à zéro.
</p>
</div>

<div id="outline-container-org6bdb469" class="outline-4">
<h4 id="org6bdb469"><span class="section-number-4">9.11.1.</span> Bascules D</h4>
<div class="outline-text-4" id="text-9-11-1">
</div>
<ol class="org-ol">
<li><a id="orgdc0972c"></a>Diagramme d'état<br />
<div class="outline-text-5" id="text-9-11-1-1">
<p>
Selon le diagramme d'état de la figure <a href="#org98a2249">106</a>, le
système démarre dans l'état <i>a</i>, et demeure dans cet état tant que
l'entrée \(A=0\). Lorsque \(A=1\), on passe à l'état <i>b</i>, début de la
reconnaissance du patron 101. Ensuite, si \(A=1\), on reste dans
l'état <i>b</i> parce ce pourrait être le début d'une autre
séquence 101. De l'état <i>b</i>, si \(A=0\), on passe à l'état <i>c</i>, car on
a observé 10 en séquence. De l'état <i>c</i>, si on a \(A=0\), la séquence
observée est maintenant de 100, et on doit tout recommencer en
retournant à l'état <i>a</i>.  De l'état <i>c</i>, si on a \(A=1\), alors on a
reconnu la séquence 101. On met la sortie \(S=1\) et on reste dans cet
état pour toutes les autres transitions, quelle que soit l'entrée. Il
s'agit ici d'une machine de Moore, puisque la sortie est \(S=1\)
produite lorsqu'on est dans l'état <i>d</i>; on a \(S=0\) dans les autres
états.
</p>


<div id="org98a2249" class="figure">
<p><img src="Images_svg/seq_101_sanscode.svg" alt="seq_101_sanscode.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;106&nbsp;: </span>Diagramme d'état pour détecter la séquence 101</p>
</div>
</div>
</li>


<li><a id="org9d120a2"></a>Réduction d'état<br />
<div class="outline-text-5" id="text-9-11-1-2">
<p>
Il n'y a pas de réduction d'états possible ici.
</p>
</div>
</li>

<li><a id="org1dff9e6"></a>Assigner des codes binaires aux états<br />
<div class="outline-text-5" id="text-9-11-1-3">
<p>
Pour quatre états, il nous faudra deux bascules.  Le tableau
   <a href="#org3ba2837">51</a> présente l'assignation d'états choisie.
</p>

<table id="org3ba2837" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 51 :</span> Tableau d'assignation d'état</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">État</th>
<th scope="col" class="org-right">Code</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-right">00</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">01</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-right">11</td>
</tr>
</tbody>
</table>
</div>
</li>


<li><a id="org2fddd25"></a>Compléter le tableau de transition<br />
<div class="outline-text-5" id="text-9-11-1-4">
<p>
Le tableau <a href="#orga4ea3f1">52</a> donne les transitions d'états. 
</p>

<table id="orga4ea3f1" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 52 :</span> Tableau de transition d'états</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(Z_1^n\)</th>
<th scope="col" class="org-right">\(Z_0^n\)</th>
<th scope="col" class="org-right">\(A\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(Z_1^{n+1}\)</th>
<th scope="col" class="org-right">\(Z_0^{n+1}\)</th>
<th scope="col" class="org-right">\(S\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</div>
</li>


<li><a id="org33c5928"></a>Sélectionner un type de bascules à utiliser<br />
<div class="outline-text-5" id="text-9-11-1-5">
<p>
On choisit des bascules D. 
</p>
</div>
</li>

<li><a id="orgaedd202"></a>Déterminer les expressions simplifiées<br />
<div class="outline-text-5" id="text-9-11-1-6">
<p>
Les diagrammes de Karnaugh correspondants sont donnés pour
\(Z_0^{n+1}\) (figure <a href="#orgfaa49ff">107</a>), \(Z_1^{n+1}\) (figure
<a href="#orgcd30c79">108</a>) et \(S\) (figure <a href="#orge1aa274">109</a>).
</p>


<div id="orgfaa49ff" class="figure">
<p><img src="Images_png/diag-k_z0.png" alt="diag-k_z0.png" />
</p>
<p><span class="figure-number">Figure&nbsp;107&nbsp;: </span>Diag-K pour \(Z_0^{n+1}\)</p>
</div>


<div id="orgcd30c79" class="figure">
<p><img src="Images_png/diag-k_z1.png" alt="diag-k_z1.png" />
</p>
<p><span class="figure-number">Figure&nbsp;108&nbsp;: </span>Diag-K pour \(Z_1^{n+1}\)</p>
</div>


<div id="orge1aa274" class="figure">
<p><img src="Images_png/diag-k_S.png" alt="diag-k_S.png" />
</p>
<p><span class="figure-number">Figure&nbsp;109&nbsp;: </span>Diag-K pour \(S\)</p>
</div>
</div>
</li>

<li><a id="orgd87739c"></a>Décodeur de prochain état<br />
<div class="outline-text-5" id="text-9-11-1-7">
<p>
Les expressions pour le décodeur de prochain état sont:
</p>

<p>
\[ Z_1^{n+1} = (A^\prime \cdot Z_0^{n}) + (A \cdot  Z_1^{n}) \]
</p>

<p>
\[ Z_0^{n+1} = A + (Z_0^{n} \cdot Z_1^{n}) \]
</p>
</div>
</li>

<li><a id="orge7db477"></a>Décodeur de sortie<br />
<div class="outline-text-5" id="text-9-11-1-8">
<p>
L'expression pour le décodeur de sortie est:
</p>

<p>
\[ S = Z_0^{n} \cdot Z_1^{n} \]
</p>
</div>
</li>

<li><a id="org4613576"></a>Schéma logique du circuit<br />
<div class="outline-text-5" id="text-9-11-1-9">
<p>
Le circuit obtenu est représenté sur la figure
<a href="#orge0eb813">110</a>. On montre sur la figure
<a href="#orgbfacfbe">111</a> une trace d'exécution. Les premiers coups
d'horloge, l'entrée \(A=0\) et le système demeure dans l'état 0. Puis,
lorsque \(A=1\), on passe à l'état 1. Comme \(A\) reste à 1, on
demeure dans l'état 1 un certain temps. Puis, lorsque \(A=0\), on
passe à l'état 2. Avec \(A=1\) de nouveau, on passe à l'état 3 en
activant la sortie \(S=1\). On ne quittera plus cet état ensuite. Une
deuxième trace d'exécution (figure <a href="#org12f53eb">112</a> ) montre
un cas où le système retourne à l'état 0 après avoir reçu une
séquence 100.
</p>


<div id="orge0eb813" class="figure">
<p><img src="Images_svg/exemp_seq101_circ.svg" alt="exemp_seq101_circ.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;110&nbsp;: </span>Détecteur pour la séquence 101</p>
</div>


<div id="orgbfacfbe" class="figure">
<p><img src="Images_svg/exemp_seq101_trace1.svg" alt="exemp_seq101_trace1.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;111&nbsp;: </span>Trace d'exécution avec succès</p>
</div>


<div id="org12f53eb" class="figure">
<p><img src="Images_svg/exemp_seq101_trace2.svg" alt="exemp_seq101_trace2.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;112&nbsp;: </span>Trace d'exécution sans succès</p>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgccbbeca" class="outline-4">
<h4 id="orgccbbeca"><span class="section-number-4">9.11.2.</span> Autres types de bascules</h4>
<div class="outline-text-4" id="text-9-11-2">
<p>
Les fonctions du décodeur de prochain état se formulent naturellement
en fonction de bascules D.  Pour faire l'implémentation avec des
bascules JK ou T, il faut pouvoir déterminer les entrées nécessaires
pour amener les changements d'états requis. Pour ce faire, on
utilisera des <b>tableaux d'excitation</b> qui listent les combinaisons
d'entrées pour passer d'un état présent \(Q_n\) à un état prochain
\(Q_{n+1}\). Le tableau d'excitation pour une bascule JK est donné
dans le tableau <a href="#org15b5a16">53</a> et celui pour une bascule T est donné
dans le tableau <a href="#orga1c4723">54</a>.
</p>

<table id="org15b5a16" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 53 :</span> Tableau d'excitation, bascule JK</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(Q_n\)</th>
<th scope="col" class="org-right">\(Q_{n+1}\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(J\)</th>
<th scope="col" class="org-left">\(K\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">0</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">1</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">X</td>
<td class="org-left">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">X</td>
<td class="org-left">0</td>
</tr>
</tbody>
</table>

<table id="orga1c4723" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 54 :</span> Tableau d'excitation, bascule T</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(Q_n\)</th>
<th scope="col" class="org-right">\(Q_{n+1}\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(T\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Reprenons le tableau de transition d'états pour notre exemple, tableau
<a href="#orga4ea3f1">52</a>, en ajoutant les signaux à générer pour des
bascules JK. On obtient alors le tableau <a href="#org8ed173e">55</a>.
</p>

<table id="org8ed173e" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 55 :</span> Tableau de transition d'états, avec bascules JK</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(Z_1^n\)</th>
<th scope="col" class="org-right">\(Z_0^n\)</th>
<th scope="col" class="org-right">\(A\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(Z_1^{n+1}\)</th>
<th scope="col" class="org-left">\(J\)</th>
<th scope="col" class="org-left">\(K\)</th>
<th scope="col" class="org-right">\(Z_0^{n+1}\)</th>
<th scope="col" class="org-left">\(J\)</th>
<th scope="col" class="org-left">\(K\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-left">0</td>
<td class="org-left">X</td>
<td class="org-right">0</td>
<td class="org-left">0</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-left">0</td>
<td class="org-left">X</td>
<td class="org-right">1</td>
<td class="org-left">1</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-left">1</td>
<td class="org-left">X</td>
<td class="org-right">0</td>
<td class="org-left">X</td>
<td class="org-left">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-left">0</td>
<td class="org-left">X</td>
<td class="org-right">1</td>
<td class="org-left">X</td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-left">X</td>
<td class="org-left">1</td>
<td class="org-right">0</td>
<td class="org-left">0</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-left">X</td>
<td class="org-left">0</td>
<td class="org-right">1</td>
<td class="org-left">1</td>
<td class="org-left">X</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-left">X</td>
<td class="org-left">0</td>
<td class="org-right">1</td>
<td class="org-left">x</td>
<td class="org-left">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-left">X</td>
<td class="org-left">0</td>
<td class="org-right">1</td>
<td class="org-left">x</td>
<td class="org-left">0</td>
</tr>
</tbody>
</table>

<p>
On trouve les expressions simplifiées suivantes:
</p>

<p>
\[ J_{Z_1} = A^\prime \cdot Z_0^n \]
</p>

<p>
\[ K_{Z_1} = A^\prime \cdot (Z_0^n)^\prime \]
</p>

<p>
\[ J_{Z_0} = A \] 
</p>

<p>
\[ K_{Z_0} = (A + Z_1^n)^\prime \]
</p>

<p>
Ce qui nous donne l'implémentation de la figure <a href="#orgc6cd59f">113</a>.
</p>


<div id="orgc6cd59f" class="figure">
<p><img src="Images_svg/exemp_seq101_JK.svg" alt="exemp_seq101_JK.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;113&nbsp;: </span>Détecteur pour la séquence 101, bascules JK</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org47b36ac" class="outline-3">
<h3 id="org47b36ac"><span class="section-number-3">9.12.</span> États interdits</h3>
<div class="outline-text-3" id="text-9-12">
<p>
Lorsque le nombre d'états nécessaires pour le fonctionnement de la
machine à état fini est strictement inférieur au nombre total d'états
possibles avec les bascules utilisées, un certain nombre d'états
(physiques) ne seront pas utilisés dans le fonctionnement normal du
circuit séquentiel. On parlera alors d'<b>états interdits</b>.  Lors de la
formulation des tableaux de vérité pour le décodeur de prochain état,
ces états donneront lieu à des cas facultatifs, qui pourront permettre
la simplification du circuit combinatoire du décodeur.
</p>

<p>
Il faut toutefois se méfier de scénarios dans lesquels la machine à
état pourrait se retrouver dans un tel état interdit en raison d'un
dysfonctionnement momentané ou lors de la mise en marche du
système. Considérons par exemple un circuit séquentiel dont le
diagramme d'état (tel qu'implémenté après conception) est illustré
ci-dessous (figure <a href="#orgcb541b2">114</a>). En fonctionnement normal, le
système évolue entre les états <i>a</i>, <i>b</i> et <i>c</i>. Mais si pour une
raison quelconque, le système entre dans l'état <i>d</i>, il restera coincé
en bouclant sur cet état pour toujours (ou peut-être jusqu'à un
prochain dysfonctionnement).
</p>


<div id="orgcb541b2" class="figure">
<p><img src="Images_svg/etat_interdit.svg" alt="etat_interdit.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;114&nbsp;: </span>Diagramme d'état avec état interdit</p>
</div>


<p>
Une solution serait de modifier le décodeur de prochain état pour
s'assurer que, de l'état interdit, on revient toujours vers un état
normal, comme on peut le voir sur la figure suivante (figure
<a href="#org2d0e370">115</a>), où de l'état <i>d</i>, on reviendra toujours
vers l'état <i>c</i>. 
</p>


<div id="org2d0e370" class="figure">
<p><img src="Images_svg/etat_interdit_revient.svg" alt="etat_interdit_revient.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;115&nbsp;: </span>Diagramme d'état qui assure le retour en fonctionnement normal</p>
</div>
</div>
</div>

<div id="outline-container-orgd0f79e5" class="outline-3">
<h3 id="orgd0f79e5"><span class="section-number-3">9.13.</span> Exemple avec états <i>one-hot</i></h3>
<div class="outline-text-3" id="text-9-13">
<p>
Dans l'exemple suivant, on explore l'assignation d'états <i>one-hot</i>
dans laquelle il n'y a qu'un seul bit 1 par code binaire.
</p>

<p>
Considérons le diagramme d'état suivant (figure <a href="#org58b2bc3">116</a>).
</p>


<div id="org58b2bc3" class="figure">
<p><img src="Images_svg/exemple_one-hot.svg" alt="exemple_one-hot.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;116&nbsp;: </span>Diagramme d'état pour assignation <i>one-hot</i></p>
</div>

<p>
Le tableau d'assignation d'état correspondant est donné dans le
tableau <a href="#org3b77136">56</a> ci-dessous.
</p>

<table id="org3b77136" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 56 :</span> Assignation <i>one-hot</i></caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">État</th>
<th scope="col" class="org-right"><i>One-hot</i></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-right">100</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">010</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">001</td>
</tr>
</tbody>
</table>

<p>
Chaque état aura sa propre bascule active, dont les sorties seront
dénotées \(A\), \(B\) et \(C\). Le tableau de transition d'états qu'on
obtient comporte un grand nombre de cas facultatifs et d'états
inutilisés, que nous n'avons pas indiqués ici. Le tableau
<a href="#orge75ece5">57</a> ne montre que les six transitions spécifiées
dans le diagramme d'état.
</p>

<table id="orge75ece5" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 57 :</span> Tableau de transition d'états <i>one-hot</i></caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(A^n\)</th>
<th scope="col" class="org-right">\(B^n\)</th>
<th scope="col" class="org-right">\(C^n\)</th>
<th scope="col" class="org-left">\(x\)</th>
<th scope="col" class="org-left">\(y\)</th>
<th scope="col" class="org-left">\(z\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(A^{n+1}\)</th>
<th scope="col" class="org-right">\(B^{n+1}\)</th>
<th scope="col" class="org-right">\(C^{n+1}\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">0</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">1</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">X</td>
<td class="org-left">0</td>
<td class="org-left">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">X</td>
<td class="org-left">0</td>
<td class="org-left">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">X</td>
<td class="org-left">1</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">X</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Il est possible de formuler le décodeur de prochain état directement,
par inspection des transitions spécifiées.  Si on considère les
transitions qui entrent dans l'état <i>a</i>, il y a trois façons différentes
d'arriver en <i>a</i>:
</p>
<ul class="org-ul">
<li>à partir de <i>a</i>, sous la condition \(x=0\)</li>
<li>à partir de <i>b</i>, sous la condition \(y=0, z=1\)</li>
<li>à partir de <i>c</i>, sans conditions</li>
</ul>

<p>
L'équation de prochain état pour <i>a</i> sera ainsi 
\[
A^{n+1} = A^{n}x^\prime + B^n y^\prime z + C^n
\]
</p>

<p>
Le même raisonnement nous permet d'écrire pour les autres bascules:
\[
B^{n+1} = A^{n}x + B^n y^\prime z^\prime
\]
et 
\[
C^{n+1} = B^n y
\]
</p>

<p>
Le décodeur de prochain état est simplifié, car les bits d'état
offrent une indication directe de l'état dans lequel la machine se
trouve. Le fonctionnement de la machine entraîne peu de transitions,
ce qui résulte en une consommation d'énergie réduite, et moins de
risque de <i>glitches</i>. La vitesse de commutation ne dépend pas du
nombre d'états. Ajouter ou retrancher un état peu se faire sans avoir
à tout refaire la conception.  L'assignation <i>one-hot</i> est
particulièrement intéressante lorsqu'on est moins limité par le nombre
de bascules que par le nombre d'éléments combinatoires. 
</p>

<p>
Le principal inconvénient de cette approche est la croissance du
nombre de bascules, qui est linéaire avec le nombre d'états plutôt que
logarithmique. Par exemple, pour 30 états, il faudra 30 bascules alors
qu'avec un encodage binaire, il n'en faudrait que cinq. Il faut aussi
considérer qu'il y a un grand nombre d'états interdits, et prendre les
précautions qui s'imposent pour éviter les problèmes de fonctionnement
coincé.
</p>
</div>
</div>
</div>

<div id="outline-container-org8adfbd6" class="outline-2">
<h2 id="org8adfbd6"><span class="section-number-2">10.</span> Circuit séquentiels: registres et compteurs</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-org2cf7aca" class="outline-3">
<h3 id="org2cf7aca"><span class="section-number-3">10.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>Être familier avec les principaux circuits séquentiels classiques:
registres, registres à décalage, compteurs</li>
<li>Savoir comment sont implémentées les différentes opérations:
chargement, remise à zéro, comptage vers le haut/bas, décalage</li>
<li>Pouvoir utiliser des compteurs pour générer des séquences de
synchronisation</li>
<li>Pouvoir distinguer entre compteur synchrone et compteur asynchrone</li>
</ul>
</div>
</div>

<div id="outline-container-org8672e97" class="outline-3">
<h3 id="org8672e97"><span class="section-number-3">10.2.</span> Registres</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Un registre est un groupe de bascules activées par un même signal
d'horloge. Chaque bascule permet de stocker un bit en
mémoire. Différentes configurations d'interconnexion entre les
bascules et éventuellement des composantes combinatoires permettent de
concevoir des types de registres pouvant remplir des rôles variés.
</p>

<p>
La figure <a href="#org19d1a1a">117</a> montre un registre parallèle de quatre bits,
qui permet de stocker 4 valeurs binaires indépendantes. Le schéma du
bas est une représentation symbolique du registre, dans laquelle on
représente les entrées et sorties comme des vecteurs de quatre bits.
</p>


<div id="org19d1a1a" class="figure">
<p><img src="Images_svg/regist_4.svg" alt="regist_4.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;117&nbsp;: </span>Registre parallèle à quatre bits</p>
</div>
</div>

<div id="outline-container-org6f07dfc" class="outline-4">
<h4 id="org6f07dfc"><span class="section-number-4">10.2.1.</span> Chargement parallèle</h4>
<div class="outline-text-4" id="text-10-2-1">
<p>
Si on veut concevoir un registre parallèle polyvalent, on doit le
munir de la possibilité de le charger à partir des entrées ou de
maintenir les valeurs déjà mémorisées. On ajoutera donc une entrée
<i>charge</i> au registre pour contrôler ces opérations.
</p>

<p>
Comment mettre en oeuvre ce chargement/maintien demande un peu de
réflexion. Il serait possible d'agir (à la façon d'un signal <i>enable</i>
via une porte ET par exemple) sur l'entrée d'horloge des bascules
pour empêcher leur contenu d'être affecté par les entrées. Mais
alors, on briserait le principe de synchronisation qui veut que tous
les éléments d'un système soient tous commandés en même temps par une
même horloge.
</p>

<p>
La solution consiste à toujours mettre à jour le contenu des bascules: 
</p>

<ol class="org-ol">
<li>Lorsque <i>charge</i> est inactif (fonction maintien), la sortie de
chaque bascule, réacheminée à l'entrée, est sélectionnée pour
récrire le même contenu.</li>
<li>Lorsque <i>charge</i> est actif (fonction chargement), c'est l'entrée
externe qui est sélectionnée pour écrire un nouveau contenu.</li>
</ol>

<p>
La sélection se fait au moyen d'un multiplexeur deux-vers-un à
l'entrée de chaque bascule. La figure <a href="#org5d74ab7">118</a> montre le schéma
du registre chargeable.
</p>


<div id="org5d74ab7" class="figure">
<p><img src="Images_svg/reg_4_paral.svg" alt="reg_4_paral.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;118&nbsp;: </span>Registre parallèle à quatre bits chargeable</p>
</div>
</div>
</div>

<div id="outline-container-orgb2379b9" class="outline-4">
<h4 id="orgb2379b9"><span class="section-number-4">10.2.2.</span> Registres à décalage</h4>
<div class="outline-text-4" id="text-10-2-2">
<p>
Un registre à décalage consiste en une chaîne de bascules, la sortie
de l'une reliée à l'entrée de la suivante. La figure <a href="#orge2266a5">119</a> montre
un registre à décalage de quatre bits. À chaque coup d'horloge,
l'entrée est insérée dans la première bascule, à droite, et le contenu
du registre est décalé d'une position vers la gauche. La sortie
provient de la dernière bascule à droite.
</p>


<div id="orge2266a5" class="figure">
<p><img src="Images_svg/shift4.svg" alt="shift4.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;119&nbsp;: </span>Registre à décalage 4 bits</p>
</div>

<p>
En utilisant un multiplexeur quatre-vers-un pour sélectionner ce qui
sera inséré dans une bascule, il est possible de concevoir un registre
à décalage universel. Les différents opérations sont le <i>maintien</i>, le
<i>décalage à droite</i> avec entrée \(G\), le <i>décalage à gauche</i> avec entrée
\(D\) et le <i>chargement parallèle</i>, avec les entrées \(I_i, i=1, \ldots,
4\).
</p>

<p>
Les différentes opérations sont commandées par les deux signaux de
sélection, tel qu'indiqué dans le tableau <a href="#orgfd23f49">58</a>.
</p>

<table id="orgfd23f49" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 58 :</span> Codes de sélection et opérations</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Sél.</th>
<th scope="col" class="org-left">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">00</td>
<td class="org-left">Maintien</td>
</tr>

<tr>
<td class="org-right">01</td>
<td class="org-left">Décalage droite</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">Décalage gauche</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-left">Chargement parallèle</td>
</tr>
</tbody>
</table>


<div id="orge8b3a8f" class="figure">
<p><img src="Images_svg/shift4_univ.svg" alt="shift4_univ.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;120&nbsp;: </span>Registre à décalage universel</p>
</div>

<p>
Les registres à décalage sont notamment utilisés pour convertir des
données parallèles en données sérielles et vice versa, des opérations
très utiles dans le contexte d'interfaces de communication. On peut
également s'en servir pour faire des multiplications ou divisions par
deux, comme on l'a vu à la section <a href="#org0f5e2b8">1.8.1</a>.
</p>
</div>
</div>
</div>



<div id="outline-container-org5753f6b" class="outline-3">
<h3 id="org5753f6b"><span class="section-number-3">10.3.</span> Compteurs</h3>
<div class="outline-text-3" id="text-10-3">
<p>
Un registre dont la séquence d'états est systématique est appelé un
<b>compteur</b>. Le comptage peut être contrôlé par une entrée spécifique
ou par l'entrée d'horloge. La séquence d'états est toujours la même
pour un type de compteur donné. Par exemple, les états d'un compteur
binaire à deux bits suivent la séquence \(00 \rightarrow 01
\rightarrow 10 \rightarrow 11 \rightarrow 00 \ldots\) La sortie
correspond directement aux bits d'état. On distingue les compteurs
<b>asynchrones</b> et les compteurs <b>synchrones</b>. Quel que soit le type de
compteur, il y a toujours un retour vers l'état initial, car la
séquence d'états est un cycle.
</p>
</div>

<div id="outline-container-orgc95eeef" class="outline-4">
<h4 id="orgc95eeef"><span class="section-number-4">10.3.1.</span> Compteur asynchrone</h4>
<div class="outline-text-4" id="text-10-3-1">
<p>
Dans un compteur binaire asynchrone, la sortie d'une bascule de poids
moins significatif est acheminée à l'entrée d'horloge de la bascule
suivante. C'est la transition de la sortie de la bascule de poids
moins significatif qui déclenche la bascule suivante. La figure
<a href="#org0f33b14">121</a> montre un compteur asynchrone construit à partir de
bascules T. La séquence de sortie est donnée dans le tableau
<a href="#orga68492d">59</a>. On peut voir qu'après huit étapes, la séquence se
répète.
</p>


<div id="org0f33b14" class="figure">
<p><img src="Images_svg/rippleT3.svg" alt="rippleT3.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;121&nbsp;: </span>Compteur asynchrone</p>
</div>

<table id="orga68492d" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 59 :</span> Séquence du compteur</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(A_2\)</th>
<th scope="col" class="org-right">\(A_1\)</th>
<th scope="col" class="org-right">\(A_0\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Les compteurs asynchrones sont très simples, mais l'inconvénient est
que les transitions d'états ne sont pas synchrones. En particulier,
les bits d'état ne changent pas tous en même temps. Par exemple, si le
compteur passe de 0111 à 1000, la sortie peut passer par des états
intermédiaires parasites: 0111 \(\rightarrow\) 0110 \(\rightarrow\) 1100
\(\rightarrow\) 1000.
</p>
</div>
</div>

<div id="outline-container-org5c6ef41" class="outline-4">
<h4 id="org5c6ef41"><span class="section-number-4">10.3.2.</span> Compteur synchrone</h4>
<div class="outline-text-4" id="text-10-3-2">
<p>
Dans un compteur synchrone, toutes les bascules sont commandées par un
même signal d'horloge, et les changements d'états sont
synchronisés. Les changements d'états sont contrôlés par les signaux
d'entrée appliqués aux bascules, comme dans le fonctionnement normal
d'un circuit séquentiel synchrone.
</p>

<p>
Le diagramme d'état d'un compteur trois bits (huit états) est un
cycle, comme on peut le voir sur la figure <a href="#org72f1b73">122</a>. Le tableau
d'états correspondant est donné dans le tableau <a href="#org96aa7b4">60</a>.
</p>



<div id="org72f1b73" class="figure">
<p><img src="Images_svg/compt8_FSM.svg" alt="compt8_FSM.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;122&nbsp;: </span>Diagramme d'état d'un compteur</p>
</div>

<table id="org96aa7b4" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 60 :</span> Tableau d'état du compteur</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(Z_2^n\)</th>
<th scope="col" class="org-right">\(Z_1^n\)</th>
<th scope="col" class="org-right">\(Z_0^n\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(Z_2^{n+1}\)</th>
<th scope="col" class="org-right">\(Z_1^{n+1}\)</th>
<th scope="col" class="org-right">\(Z_0^{n+1}\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Les expressions pour le décodeur de prochain état sont: 
</p>

<p>
\[  Z_2^{n+1} = Z_0^n \cdot Z_1^n \cdot (Z_2^{n})^\prime + (Z_0^{n})^\prime \cdot Z_2^n + (Z_1^{n})^\prime \cdot Z_2^n \]
</p>

<p>
\[  Z_1^{n+1} = Z_0^{n} \cdot (Z_1^{n})^\prime + (Z_0^{n})^\prime \cdot Z_1^n \]
</p>

<p>
\[  Z_0^{n+1} = (Z_0^{n})^\prime \]
</p>


<p>
Le schéma correspondant est donné à la figure <a href="#org471cf73">123</a>.
</p>


<div id="org471cf73" class="figure">
<p><img src="Images_svg/compt8.svg" alt="compt8.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;123&nbsp;: </span>Schéma logique du compteur à 3 bits</p>
</div>

<p>
On peut ajouter aux compteurs des fonctions diverses: comptage vers le
haut, comptage vers le bas, préchargement parallèle, remise à zéro,
etc.
</p>

<p>
Le compteur de la figure <a href="#org471cf73">123</a> a été conçu comme un circuit
séquentiel général, avec un décodeur de prochain état en forme <i>somme
de produits</i>. Il est également possible de concevoir un compteur
synchrone directement, sans passer par la méthodologie classique, en
suivant un raisonnement tout simple. La bascule du bit le moins
significatif \(Z_0\) doit changer d'état à tous les coups
d'horloge. La bascule du bit suivant \(Z_1\) doit changer d'état
seulement lorsque le bit précédent \(Z_0\) vaut 1. La bascule du bit
suivant \(Z_2\) doit changer d'état seulement lorsque les bits
précédents \(Z_1, Z_0\) valent tous deux 1. Et on peut pousser le
raisonnement pour un compteur quelconque: 
</p>
<blockquote>
<p>
la bascule d'un bit \(Z_i\)
doit changer d'état seulement lorsque les bits précédents
\(Z_{i-1},Z_{i-2},\ldots, Z_0\) valent tous 1.
</p>
</blockquote>


<p>
Le compteur à quatre bits de la figure <a href="#orgd4dd5a3">124</a> a été conçu
selon cette approche, à partir de bascules JK.  L'utilisation d'une
porte ET par bascule permet de mettre en oeuvre les
conditions. L'entrée \(E\) est un contrôle <i>enable</i> pour activer le
comptage. On a aussi prévu une sortie <code>Prochain</code> pour pouvoir
connecter en cascade d'autres compteurs.
</p>


<div id="orgd4dd5a3" class="figure">
<p><img src="Images_svg/compt_4bits.svg" alt="compt_4bits.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;124&nbsp;: </span>Schéma logique du compteur à 4 bits</p>
</div>

<p>
Si on réfléchit de la même façon au comptage vers le bas, on constate
que la règle devient:
</p>

<blockquote>
<p>
la bascule d'un bit \(Z_i\) doit changer d'état
seulement lorsque les bits précédents \(Z_{i-1},Z_{i-2},\ldots, Z_0\)
valent tous 0.
</p>
</blockquote>
<p>
Cette fois-ci, les conditions se baseront sur les sorties
complémentées des bascules précédentes.
</p>
</div>
</div>

<div id="outline-container-orgbeef1cc" class="outline-4">
<h4 id="orgbeef1cc"><span class="section-number-4">10.3.3.</span> Compteur bidirectionnel</h4>
<div class="outline-text-4" id="text-10-3-3">
<p>
En combinant les deux conditions au moyen d'un multiplexeur deux-vers-
un, il est facile de concevoir un compteur haut/bas, tel qu'illustré
sur la figure <a href="#org4851d1b">125</a>.
</p>


<div id="org4851d1b" class="figure">
<p><img src="Images_svg/compt_updown.svg" alt="compt_updown.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;125&nbsp;: </span>Schéma logique du compteur haut/bas à 4 bits</p>
</div>
</div>
</div>

<div id="outline-container-org7f1052c" class="outline-4">
<h4 id="org7f1052c"><span class="section-number-4">10.3.4.</span> Compteur en anneau</h4>
<div class="outline-text-4" id="text-10-3-4">
<p>
Un compteur en anneau est un registre à décalage connecté en boucle où
une seule bascule est active à la fois. Il y a donc dans la sortie un
seul bit 1, qui se décale de façon cyclique: \(0010 \rightarrow 0001
\rightarrow 1000 \rightarrow 0100 \rightarrow 0010, \ldots\) La
figure <a href="#orgb901255">126</a> illustre un compteur en anneau de quatre bits. Une
entrée <code>Init</code> permet d'injecter un bit 1 dans le registre au début. La
trace montre les formes d'onde obtenues.
</p>

<p>
On utilise fréquemment ce type de compteur pour générer des signaux de
synchronisation. En effet, chaque sortie devient active à son tour
dans le cycle, pendant une période d'horloge.
</p>


<div id="orgb901255" class="figure">
<p><img src="Images_svg/ring4.svg" alt="ring4.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;126&nbsp;: </span>Compteur en anneau à 4 bits</p>
</div>
</div>
</div>

<div id="outline-container-org3492be5" class="outline-4">
<h4 id="org3492be5"><span class="section-number-4">10.3.5.</span> Compteur Johnson</h4>
<div class="outline-text-4" id="text-10-3-5">
<p>
Un compteur Johnson permet de doubler le nombre d'états distincts par
rapport au compteur en anneau en injectant le complément du dernier
bit dans l'entrée du registre à décalage.  La figure <a href="#org4fd30d6">127</a>
illustre un compteur en anneau Johnson de quatre bits, de même que la
trace de fonctionnement. La séquence d'états est donnée dans le
tableau <a href="#org5c67146">61</a>.
</p>



<div id="org4fd30d6" class="figure">
<p><img src="Images_svg/johnson4.svg" alt="johnson4.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;127&nbsp;: </span>Compteur Johnson à 4 bits</p>
</div>


<table id="org5c67146" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 61 :</span> Séquence d'états du compteur Johnson</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">No.</th>
<th scope="col" class="org-right">\(a\)</th>
<th scope="col" class="org-right">\(b\)</th>
<th scope="col" class="org-right">\(c\)</th>
<th scope="col" class="org-right">\(d\)</th>
<th scope="col" class="org-left">ET requis</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">\(a^\prime d^\prime\)</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">\(a b^\prime\)</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">\(b c^\prime\)</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">\(c^\prime d^\prime\)</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">\(a d^\prime\)</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">\(a^\prime b\)</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">\(b^\prime c\)</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">\(c^\prime d\)</td>
</tr>
</tbody>
</table>


<p>
On peut construire des signaux de synchronisation distincts en
combinant deux par deux au moyen d'une porte ET des signaux de sortie
voisins (dans le cycle) ou leurs compléments. Le tableau <a href="#org5c67146">61</a>
donne les paires de sorties à combiner pour ce faire avec le compteur
Johnson de quatre bits.
</p>

<p>
Nous avons appliqué ce principe à un compteur Johnson de deux bits,
présenté sur la figure <a href="#orgded9eb4">128</a>. La figure montre une trace
d'exécution avec les signaux de sortie. On y voit que chacun des
quatres signaux est activé à son tour.
</p>


<div id="orgded9eb4" class="figure">
<p><img src="Images_svg/johnson2_quad_decode.svg" alt="johnson2_quad_decode.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;128&nbsp;: </span>Compteur Johnson à 2 bits et circuit de décodage pour signaux de synchronisation</p>
</div>

<p>
Si on s'intéresse aux sorties des bascules de ce même compteur
Johnson, on peut voir sur la trace d'exécution de la figure
<a href="#orgc3716cc">129</a> qu'on obtient des signaux en <b>quadrature</b>,
c'est-à-dire que les sorties sont déphasées de 90 degrés les unes par
rapport aux autres, comme le sont des fonctions \(\sin(), \cos(),
-\sin(), -\cos()\).
</p>


<div id="orgc3716cc" class="figure">
<p><img src="Images_svg/johnson2_quad.svg" alt="johnson2_quad.svg" class="org-svg" /> 
</p>
<p><span class="figure-number">Figure&nbsp;129&nbsp;: </span>Signaux en quadrature obtenus au moyen d'un compteur Johnson à 2 bits</p>
</div>
</div>
</div>

<div id="outline-container-orgeb26306" class="outline-4">
<h4 id="orgeb26306"><span class="section-number-4">10.3.6.</span> Diviseur de fréquence</h4>
<div class="outline-text-4" id="text-10-3-6">
<p>
Un compteur peut être utilisé pour diviser la fréquence d'un signal
périodique. Par exemple, la sortie d'un compteur à un bit change
d'état à tous les deux coups d'horloge, ce qui constitue une division
par deux de la fréquence d'horloge. Cette approche permet
naturellement des divisions par des puissances de deux.
</p>

<p>
On peut aussi utiliser un compteur Johnson, qui permettra alors, selon
le nombre d'étages du compteur, des divisions de fréquence par des
diviseurs, comme trois ou cinq, qui ne sont pas des puissances de deux.
</p>
</div>
</div>

<div id="outline-container-org19adbf9" class="outline-4">
<h4 id="org19adbf9"><span class="section-number-4">10.3.7.</span> Compteur à chargement parallèle</h4>
<div class="outline-text-4" id="text-10-3-7">
<p>
Un compteur à chargement parallèle est illustré à la figure
<a href="#orgdccd60a">130</a>. En activant l'entrée <code>Compte</code>, le comptage
se fait vers le haut. En activant l'entrée <code>Charge</code>, les entrées \(
I_i, i=0, \ldots, 3\) sont insérées dans les bascules. Il y a aussi une
sortie <code>ov</code> qui indique lorsque le compteur atteint sa valeur
maximale. Cette sortie peut être utilisée pour activer un autre
compteur pour des bits de plus haut niveau.
</p>

<p>
La trace d’exécution de la figure <a href="#org6989ba9">131</a>
montre le comptage de 4 jusqu'à 15 et retour à 0. On voit le signal
<code>ov</code> s'activer sur 15. 
</p>


<div id="orgdccd60a" class="figure">
<p><img src="Images_svg/comptchargement.svg" alt="comptchargement.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;130&nbsp;: </span>Compteur à chargement parallèle</p>
</div>


<div id="org6989ba9" class="figure">
<p><img src="Images_svg/compt_chargement_tracecompte.svg" alt="compt_chargement_tracecompte.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;131&nbsp;: </span>Trace d'exécution, de 0 à 15</p>
</div>

<p>
La trace de la figure suivante montre le compteur qui
passe de 0 à 5, puis un chargement parallèle de la valeur 12.
</p>


<div id="orgdee1387" class="figure">
<p><img src="Images_svg/compt_chargement_trace_charge.svg" alt="compt_chargement_trace_charge.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;132&nbsp;: </span>Trace d'exécution, de 0 à 5 et chargement de 12</p>
</div>
</div>
</div>

<div id="outline-container-org54a455c" class="outline-4">
<h4 id="org54a455c"><span class="section-number-4">10.3.8.</span> Compteur modulo</h4>
<div class="outline-text-4" id="text-10-3-8">
<p>
On peut réaliser aisément un compteur modulo dont le cycle est plus
court que le maximum possible, en utilisant un compteur avec
chargement parallèle.  Par exemple, pour réaliser un compteur qui
compte de 0 jusqu'à 12, il suffit de décoder au moyen d'une porte ET
l'état qui doit être le dernier du cycle, et d'utiliser le signal de
sortie obtenu pour charger la valeur 0 dans le compteur. On obtient
ainsi un compteur modulo-13, dont le cycle compte 13 états.  La figure
illustre le compteur modulo-13, de même qu'une trace d'exécution sur
laquelle on voit le passage de 12 à 0.
</p>


<div id="orgb92ccb0" class="figure">
<p><img src="Images_svg/compt_mod13.svg" alt="compt_mod13.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;133&nbsp;: </span>Compteur modulo-13</p>
</div>

<p>
On pourrait aussi réaliser un compteur qui compte par exemple de 4 à
15, en utilisant cette fois la sortie <code>ov</code> pour activer le chargement
d'une valeur initiale 4.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org40f9804" class="outline-2">
<h2 id="org40f9804"><span class="section-number-2">11.</span> Mémoires</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org9de0de2" class="outline-3">
<h3 id="org9de0de2"><span class="section-number-3">11.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-11-1">
<ul class="org-ul">
<li>Pouvoir distinguer entre mémoire volatile et non-volatile</li>
<li>Pouvoir distinguer entre mémoire volatile statique et dynamique</li>
<li>Connaître l'organisation typique d'une mémoire et le fonctionnement
de l'adressage</li>
<li>Comprendre le fonctionnement d'un bus de données</li>
<li>Pouvoir interpréter les cycles d'écriture et de lecture</li>
<li>Pouvoir implémenter une fonction combinatoire arbitraire à l'aide d'une
mémoire ROM</li>
<li>Pouvoir utiliser un tableau de correspondance</li>
<li>Être familier avec les différents types de mémoires non-volatiles</li>
</ul>
</div>
</div>

<div id="outline-container-org7644e6d" class="outline-3">
<h3 id="org7644e6d"><span class="section-number-3">11.2.</span> Mémoires</h3>
<div class="outline-text-3" id="text-11-2">
<p>
Une mémoire est utilisée pour stocker des valeurs binaires à plus ou
moins long terme. Généralement, l'information stockée dans la mémoire
sera lue et acheminée dans des registres pour être traitée par un
circuit logique de traitement. Les résultats du traitement seront
typiquement stockés de nouveau dans la mémoire. Constituée d'un grand
nombre de cellules permettant chacune de stocker un bit, la mémoire
est dotée de mécanismes permettant d'accéder aux cellules pour en
faire la lecture ou l'écriture.
</p>

<p>
On distingue les mémoires non-volatiles (en anglais, <i>Read Only
Memories</i>, (ROM)) et les mémoires volatiles (en anglais, <i>Random Access
Memories</i>, (RAM)).
</p>
</div>

<div id="outline-container-orgb57defa" class="outline-4">
<h4 id="orgb57defa"><span class="section-number-4">11.2.1.</span> Mémoires non-volatiles</h4>
<div class="outline-text-4" id="text-11-2-1">
<p>
Dans une mémoire ROM, les données sont stockées une fois pour
toute. Elles y demeurent même après que la mémoire ait été mise hors
tension. Dans le cycle de vie des données, il y a donc <b>une</b> écriture
initiale, mais autant de lectures qu'on le souhaite. Il ne peut pas y
avoir de récriture.
</p>

<p>
Une mémoire ROM est considérée comme un dispositif <b>programmable</b>,
dans le sens que le processus d'écriture initial demande une action
particulière, une procédure spécifique au niveau matériel. On verra au
chapitre <a href="#org8873d6d">12</a> d'autres dispositifs logiques
programmables. La programmation d'une ROM se fait en agissant sur des
connexions dites <b>fusibles</b>. Initialement, le fusible est comme un fil
qui permet au signal de passer. En le programmant, le fusible devient
un circuit ouvert qui ne laisse plus passer le signal.
</p>
</div>
</div>

<div id="outline-container-org0d275df" class="outline-4">
<h4 id="org0d275df"><span class="section-number-4">11.2.2.</span> Mémoires volatiles</h4>
<div class="outline-text-4" id="text-11-2-2">
<p>
Une mémoire RAM stocke l'information de façon temporaire. En principe,
le contenu est conservé tant que la mémoire est maintenue sous
tension. Mais la réalité est un peu plus complexe, comme on le verra
plus loin.
</p>

<p>
L'opération d'<b>écriture</b> permet de stocker des valeurs, et la
<b>lecture</b> permet d'extraire l'information de la mémoire.
</p>

<p>
Une mémoire RAM <b>statique</b> consiste en un ensemble de loquets qui
permettent de conserver des données binaires. L'information est
maintenue tant que la mémoire est alimentée. 
</p>

<p>
Les mémoires RAM <b>dynamiques</b> stockent l'information sous la forme
d'une charge capacitive au sein des transistors du circuit
intégré. Comme cette charge se disperse au fil du temps, la mémoire
doit être rafraîchie régulièrement, en y récrivant périodiquement à
très court intervalle (millisecondes) la même valeur qui est déjà
stockée.
</p>

<p>
Les mémoires dynamiques consomment beaucoup moins que les mémoires
statiques et offrent des capacités de stockage largement supérieures,
car une cellule de mémoire comporte beaucoup moins d'éléments
(essentiellement un transistor par cellule). En contrepartie, les
temps d'accès aux mémoires statiques sont nettement meilleurs et on
n'a pas à se préoccuper de rafraîchissement.
</p>
</div>
</div>
</div>

<div id="outline-container-org8cfadc4" class="outline-3">
<h3 id="org8cfadc4"><span class="section-number-3">11.3.</span> Adressage</h3>
<div class="outline-text-3" id="text-11-3">
<p>
Les cellules des mémoires sont organisées en petits groupes appelés
<b>mots</b>, de façon à ce que l'on puisse accéder à chaque groupe
indépendamment. Toutes les cellules d'un mot sont lues ou écrites
ensemble.
</p>

<p>
Cet accès individuel aux mots, appelé <b>adressage</b>, est une
caractéristique de flexibilité essentielle. Le temps d'accès aux
données est le même, quel que soit l'endroit dans la mémoire où un mot
en particulier est stocké. Les mots sont généralement constitués d'un
nombre de bits multiple de huit: 8, 16 ou 32 bits sont des tailles de
mots courantes. Un groupe de huit bits est appelé <b>octet</b>.
</p>

<p>
L'adressage se fait au moyen d'un <b>décodeur d'adresses</b>, qui est
simplement un décodeur binaire tel que vu à la section <a href="#orgf841fbd">6.9</a>. Le
nombre de bits d'adresse détermine la capacité (en nombre de mots) de
la mémoire: pour \(k\) adresses, on aura \(2^k\) mots distincts. Les
tailles de mémoire sont souvent exprimées au moyen de multiplicateurs:
K (kilo) correspondant à \(2^{10}\), M (mega) correspondant à \(2^{20}\)
ou G (giga) correspondant à \(2^{30}\).
</p>



<div id="orga08b661" class="figure">
<p><img src="Images_png/memoire.png" alt="memoire.png" />
</p>
<p><span class="figure-number">Figure&nbsp;134&nbsp;: </span>Schéma d'une mémoire</p>
</div>
</div>

<div id="outline-container-orga367f24" class="outline-4">
<h4 id="orga367f24"><span class="section-number-4">11.3.1.</span> Lecture et écriture</h4>
<div class="outline-text-4" id="text-11-3-1">
<p>
L'opération choisie, écriture ou lecture, est commandée par une ou des
entrées à cet effet. L'accès à un espace-mémoire (un mot) se fait
selon une séquence bien précise. Pour une écriture:
</p>

<ol class="org-ol">
<li>Les bits d'adresse du mot sont appliqués aux lignes d'adresses.</li>
<li>Les données à écrire sont appliquées aux lignes d'entrée.</li>
<li>On active l'entrée de commande <code>Écriture</code>.</li>
</ol>

<p>
Les données de l'entrée sont alors stockées dans la case-mémoire adressée.
</p>

<p>
Pour une lecture:
</p>

<ol class="org-ol">
<li>Les bits d'adresse du mot sont appliqués aux lignes d'adresses.</li>
<li>On active l'entrée de commande <code>Lecture</code>.</li>
</ol>

<p>
Les données présentes dans la case-mémoire adressée sont ensuite
disponibles à la sortie de la mémoire.
</p>

<p>
Les mémoires disponibles sur le marché optent souvent pour une
combinaison des signaux de contrôle, avec un seul signal qui détermine
le sens de l'action, comme on peut le voir dans le tableau
<a href="#orge8095d8">62</a>. Le signal <code>Enable</code>, parfois appelé <code>Chip
select</code>, permet d'activer une mémoire dans un ensemble où plusieurs
mémoires sont utilisées.
</p>

<table id="orge8095d8" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 62 :</span> Signaux de contrôle d'une mémoire</caption>

<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><code>Enable</code></th>
<th scope="col" class="org-right"><code>Lecture/écriture</code></th>
<th scope="col" class="org-left">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">X</td>
<td class="org-left">Aucune</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">Écriture</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">Lecture</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org2bec9f8" class="outline-4">
<h4 id="org2bec9f8"><span class="section-number-4">11.3.2.</span> Bus de données</h4>
<div class="outline-text-4" id="text-11-3-2">
<p>
Pour acheminer les données lues ou à écrire dans la mémoire, on
utilise des tampons émetteur-récepteurs de bus (voir section <a href="#org1dec145">6.14</a>), organisés en vecteur, pour créer un
<b>bus de données</b> qui permet un aller-retour des données, selon le sens
de l'action. Cela permet de diminuer de moitié le nombre de connexions
nécessaires pour l'échange des données.  Un signal dérivé des signaux
<code>Lecture/écriture</code> et <code>Chip select (CS)</code> est typiquement utilisé pour
commander l'entrée de contrôle (voir figure <a href="#orgeba9a35">135</a>).
</p>


<div id="orgeba9a35" class="figure">
<p><img src="Images_svg/bus_trans8.svg" alt="bus_trans8.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;135&nbsp;: </span>Bus de données, 8 bits</p>
</div>
</div>
</div>

<div id="outline-container-org7513171" class="outline-4">
<h4 id="org7513171"><span class="section-number-4">11.3.3.</span> Chronogrammes</h4>
<div class="outline-text-4" id="text-11-3-3">
<p>
La figure <a href="#orgea13d42">136</a> présente un chronogramme qui décrit
l'opération d'écriture dans une mémoire RAM. Les valeurs d'adresses
sont d'abord présentée aux entrées d'adressage.  Le signal <code>L/not E</code>
est amené au niveau bas, en même temps que le signal <code>CS</code> est activé
(au niveau bas). Après un court délai, les données sont mises sur le
bus de données et seront écrites dans la mémoire. On peut voir que les
lignes du bus de données sont en mode <b>haute impédance</b> lorsque le bus
est inactif (situation représentée symboliquement sur l'illustration
par un signal situé entre les niveaux 0 et 1).
</p>


<div id="orgea13d42" class="figure">
<p><img src="Images_svg/chron_ram_ecriture.svg" alt="chron_ram_ecriture.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;136&nbsp;: </span>Mémoire RAM, chronogramme pour l'écriture</p>
</div>

<p>
La figure <a href="#orge9e6cff">137</a> présente un chronogramme qui décrit
l'opération de lecture d'une mémoire RAM. Les valeurs d'adresses sont
d'abord présentée aux entrées d'adressage.  Le signal <code>L/not E</code> est
maintenu au niveau élevé en même temps que le signal <code>CS</code> est activé
(au niveau bas). Après un court délai, les données sont disponibles sur
le bus de données.
</p>


<div id="orge9e6cff" class="figure">
<p><img src="Images_svg/chron_ram_lecture.svg" alt="chron_ram_lecture.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;137&nbsp;: </span>Mémoire RAM, chronogramme pour la lecture</p>
</div>

<p>
La cellule de base d'une mémoire RAM qui permet de stocker un bit est
illustrée à la figure <a href="#org165a8c1">138</a>. Elle est construite autour d'un
loquet SR et de portes logiques pour le contrôle. Une mémoire complète
de \(m\) mots de taille \(n\) bits sera constituée d'une matrice de
format \(m \times n\) de telles cellules, avec un décodeur d'adresses
pour sélectionner quel mot sera affecté par l'opération choisie.
</p>


<div id="org165a8c1" class="figure">
<p><img src="Images_svg/cell_ram.svg" alt="cell_ram.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;138&nbsp;: </span>Cellule mémoire RAM</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org8f492b0" class="outline-3">
<h3 id="org8f492b0"><span class="section-number-3">11.4.</span> Mémoires mortes</h3>
<div class="outline-text-3" id="text-11-4">
<p>
Dans son mode d'utilisation normal, une mémoire morte peut seulement
être lue. Il n'est donc pas nécessaire de préciser l'opération qui
sera effectuée. Il y aura donc des entrées pour les adresses et un
signal de contrôle de type <code>CS</code>.
</p>

<p>
La figure <a href="#orgf87bb32">139</a> montre l'essentiel d'une mémoire ROM de
16 mots de 4 bits. Un décodeur d'adresse permet de sélectionner quel
mot sera lu, et la sortie est disponible sur les lignes \(A_3, \ldots,
A_0\). 
</p>

<p>
Pour simplifier la représentation de ce genre de configuration, on
utilise une schématisation symbolique compacte pour les portes OU de
sortie, dans laquelle chacune des 16 lignes horizontales représente en
fait 16 entrées d'une porte OU. La présence d'une croix à
l'intersection d'une ligne horizontale et d'une ligne verticale
signifie que le signal de la ligne horizontale est connecté à une des
entrées de la porte.  Avec cette schématisation, on peut voir que les
deux premiers mots stockés dans la mémoire illustrée dans l'exemple
seraient 0101 et 1101. La même schématisation compacte s'emploie aussi
pour des portes ET.
</p>



<div id="orgf87bb32" class="figure">
<p><img src="Images_svg/proto_rom1_prog.svg" alt="proto_rom1_prog.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;139&nbsp;: </span>Modèle d'une mémoire ROM</p>
</div>

<p>
Cette relativement petite mémoire comporte ainsi 64 intersections
programmables, permettant de définir la valeur des 16 mots de mémoire
de 8 bits chacun.
</p>
</div>

<div id="outline-container-org4874534" class="outline-4">
<h4 id="org4874534"><span class="section-number-4">11.4.1.</span> Implémentation de fonctions combinatoires</h4>
<div class="outline-text-4" id="text-11-4-1">
<p>
Comme on l'a vu dans la section <a href="#orgf841fbd">6.9</a>, un décodeur permet de
générer les \(2^k\) minterms possibles avec ses \(k\)
entrées. Regrouper avec une porte OU les minterms d'une
fonction permet d'implémenter cette fonction. Une mémoire ROM permet
de faire exactement cela sans avoir rien à ajouter, car elle est munie
d'un décodeur d'entrées et la porte OU de sortie fait déjà partie de
la ROM. On peut donc interpréter le fonctionnement d'une mémoire ROM
de \(k\) bits d'adresse et avec des mots de taille \(m\) comme un
dispositif qui permet, pour les entrées qui sont ses adresses, de
mettre en oeuvre \(m\) fonctions combinatoires différentes (une par
bit de mot) de \(k\) entrées.
</p>

<p>
Par exemple, la sortie \(A_2\) de la mémoire de la figure
<a href="#orgf87bb32">139</a> implémente la fonction \[ A_2 = \sum (0,1,4,8) \]
exprimée en somme de minterms.
</p>
</div>
</div>

<div id="outline-container-orge53dcd9" class="outline-4">
<h4 id="orge53dcd9"><span class="section-number-4">11.4.2.</span> Tableau de correspondance</h4>
<div class="outline-text-4" id="text-11-4-2">
<p>
Cette approche qui consiste à réaliser une fonction logique
combinatoire au moyen d'une mémoire qui spécifie, pour chaque
combinaison d'entrée possible, une valeur de sortie, est largement
utilisée dans les composants programmables. On parle alors de tableau
de correspondance (en anglais, <i>LookUp Table</i>, (LUT)). Il s'agit ni
plus ni moins que de stocker en mémoire le tableau de vérité de la
fonction à réaliser. Dans les composants programmables, on utilise
plutôt des mémoires RAM pour les tableaux de correspondance, afin que
la configuration des fonctions puisse être changée selon
l'application.
</p>
</div>
</div>

<div id="outline-container-org2363aca" class="outline-4">
<h4 id="org2363aca"><span class="section-number-4">11.4.3.</span> Catégories de mémoires ROM</h4>
<div class="outline-text-4" id="text-11-4-3">
<p>
On distingue quatre grandes approches technologiques pour réaliser des
mémoires mortes. Leurs usages typiques sont surtout déterminés par la
façon de les configurer (on dit couramment <i>programmer</i>, même s'il
s'agit d'un intervention au niveau du matériel).
</p>

<p>
Dans la <b>programmation par masque</b>, la mémoire est programmée lors de
la fabrication de la puce. Le fabricant se base sur un tableau de
vérité fourni par le client pour établir des connexions qui seront
implémentées (ou pas) dans le procédé de fabrication via des masques
qui empêchent la déposition de matériau conducteur sur les couches du
circuit intégré.  Cette approche convient à la production de masse à
grand volume.
</p>

<p>
Dans la <b>programmation sur mesure</b>, on utilise un type de mémoire qui
comporte initialement des connexions entre toutes les sorties du
décodeur et toutes les entrées des portes OU de sortie (la mémoire en
configuration initiale comporte des 1 partout). La programmation, qui
peut se faire chez le développeur au moyen d'un dispositif de
programmation (ou programmeur) spécialement conçu à cette fin,
consiste à supprimer les connexions qui ne sont pas nécessaires en
envoyant des impulsions à forte tension pour faire fondre les fusibles
de connexions spécifiques. Un fusible fondu (pas de connexion)
correspondant à un bit 0 dans la mémoire. Cette programmation est
bien entendu irréversible: impossible de reconnecter une fois que le
fusible est fondu.
</p>

<p>
Avec un <b>PROM</b> (pour <i>Programmable ROM</i>), il est possible d'effacer la
configuration dans son ensemble en soumettant la puce à une lumière
ultraviolet pendant un certain temps. Ce bombardement énergétique
permet de décharger les grilles flottantes des dispositifs qui
implémente les connexions. La mémoire PROM peut être reconfigurée de
nouveau.
</p>

<p>
Avec la <b>programmation électrique</b>, il est possible de reconfigurer
l'ensemble d'une mémoire dite EEPROM (<i>Electrically Erasable PROM</i>)
en la soumettant à un signal électrique d'effacement. 
</p>

<p>
Les ROM à <b>programmation <i>flash</i></b> sont semblables aux EEPROM, mais la
reconfiguration peut se faire adresse par adresse.  Il est notamment
possible de reconfigurer une mémoire sans la retirer de son circuit.
Fonctionnellement, ces mémoires sont à mi-chemin entre la mémoire RAM
et la mémoire sur disque. Les mémoires <i>flash</i> tendent d'ailleurs de
plus en plus à remplacer ce dernier type dans les systèmes portables:
téléphones, ordinateurs portables, etc.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org8873d6d" class="outline-2">
<h2 id="org8873d6d"><span class="section-number-2">12.</span> Logique programmable</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-orgff6a562" class="outline-3">
<h3 id="orgff6a562"><span class="section-number-3">12.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-12-1">
<ul class="org-ul">
<li>Être familier avec les différents types de composants logiques programmables</li>
<li>Pouvoir identifier les avantages et limitations des différents types</li>
<li>Comprendre le fonctionnement d'une matrice logique programmable</li>
<li>Comprendre le fonctionnement d'un composant logique à matrice programmable</li>
<li>Comprendre le fonctionnement d'un circuit séquentiel programmable</li>
<li>Être familier avec le concept de bloc logique programmable</li>
<li>Comprendre l'organisation d'une cellule logique programmable et
apprécier sa flexibilité</li>
</ul>
</div>
</div>

<div id="outline-container-orgd7f4260" class="outline-3">
<h3 id="orgd7f4260"><span class="section-number-3">12.2.</span> Dispositifs programmables</h3>
<div class="outline-text-3" id="text-12-2">
<p>
On a vu qu'une mémoire ROM est un dispositif logique programmable qui,
grâce à la matrice d'interconnexion entre son décodeur (qui génère
tous les minterms) et les portes OU de sortie, permet de réaliser des
fonctions logiques arbitraires. D'autres composants utilisent à divers
degrés cette approche pour offrir des possibilités de configuration
flexibles.
</p>

<p>
Il existe une grande variété de dispositifs programmables, des plus
simples aux plus complexes. De nombreux manufacturiers offrent des
variantes plus ou moins équivalentes dans chacune des gammes de
produits. Nous allons nous limiter à présenter brièvement les grandes
familles typiques, en ordre de complexité croissante.
</p>
</div>

<div id="outline-container-org60e45cf" class="outline-4">
<h4 id="org60e45cf"><span class="section-number-4">12.2.1.</span> Matrice logique programmable (PLA)</h4>
<div class="outline-text-4" id="text-12-2-1">
<p>
Une <b>matrice logique programmable</b> (en anglais, <i>Programmable Logic
Array</i>, (PLA)) est un dispositif spécifiquement conçu pour la
réalisation de fonctions combinatoires arbitraires. Elle fonctionne
selon une approche qui s'apparente à l'utilisation d'une mémoire morte
pour réaliser une fonction logique arbitraire.
</p>

<p>
La figure <a href="#org93c4a1d">140</a> montre une matrice permettant de
réaliser deux fonctions pouvant comporter jusqu'à quatre termes
produits de trois variables. Puisque le nombre de termes produits est
limité, il n'est généralement pas possible de se baser directement sur
les minterms des fonctions pour l'implémentation. On doit donc
simplifier les fonctions avant l'implémentation. Un même terme produit
peut contribuer à plus d'une fonction.
</p>

<p>
La programmation des portes XOR de sortie permet de choisir
la fonction directe ou son complément. 
</p>

<p>
Les PLAs offerts sur le marché proposent des configurations avec des
plus grands nombres d'entrées, de termes et de sorties, typiquement
des dizaines.
</p>


<div id="org93c4a1d" class="figure">
<p><img src="Images_svg/pla.svg" alt="pla.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;140&nbsp;: </span>Matrice logique programmable</p>
</div>
</div>
</div>

<div id="outline-container-org5c40955" class="outline-4">
<h4 id="org5c40955"><span class="section-number-4">12.2.2.</span> Logique à matrice programmable (PAL)</h4>
<div class="outline-text-4" id="text-12-2-2">
<p>
Les dispositifs à <b>logique à matrice programmable</b> (an anglais,
<i>Programmable Array Logic</i> (PAL)) sont une autre variante sur ce
thème, avec une matrice OU fixe et une matrice ET configurable. Ils
sont moins flexibles que les PLAs.
</p>

<p>
La figure <a href="#orgfc64321">141</a> montre un dispositif de logique à matrice
programmable à quatre variables d'entrée, permettant de réaliser trois
fonctions pouvant comporter jusqu'à trois minterms. Les sorties
(directes et complémentée pour la première fonction) peuvent être
acheminées aux entrées des autres fonctions. Encore ici, le nombre de
termes produits est limité, et on doit simplifier les fonctions avant
l'implémentation. Cependant, puisqu'il n'y a pas de matrice OU, il
n'est pas possible de partager un terme produit entre deux fonctions.
</p>

<p>
Les PALs offerts sur le marché proposent des configurations avec des
plus grands nombres d'entrées d'entrées, de termes et de sorties,
typiquement des dizaines.
</p>



<div id="orgfc64321" class="figure">
<p><img src="Images_svg/pal.svg" alt="pal.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;141&nbsp;: </span>Logique à matrice programmable</p>
</div>
</div>
</div>

<div id="outline-container-orgc2fcc24" class="outline-4">
<h4 id="orgc2fcc24"><span class="section-number-4">12.2.3.</span> Logique programmable séquentielle</h4>
<div class="outline-text-4" id="text-12-2-3">
<p>
En combinant un dispositif logique programmable (en anglais,
<i>Programmable Logic Device</i>, (PLD)) avec un certain nombre de
bascules, il est possible de proposer un circuit programmable
séquentiel. La configuration générale est telle qu'illustré sur la
figure <a href="#org2fc8e7d">142</a>.
</p>



<div id="org2fc8e7d" class="figure">
<p><img src="Images_png/circuit_seq_prog.png" alt="circuit_seq_prog.png" /> 
</p>
<p><span class="figure-number">Figure&nbsp;142&nbsp;: </span>Modèle de circuit séquentiel programmable</p>
</div>

<p>
Plusieurs fabricants proposent une variété de dispositifs de ce type,
avec diverses options de configuration, d'interconnexion, etc.  On
offre par exemple des dispositifs complexes qui combinent plusieurs
cellules programmables sur un même circuit intégré, reliables au moyen
d'un réseau d'interconnexion configurable. La disposition générale de
ce genre de dispositif complexe est présentée à la figure <a href="#orgc0d12bc">143</a>.
</p>


<div id="orgc0d12bc" class="figure">
<p><img src="Images_png/CPLD.png" alt="CPLD.png" />
</p>
<p><span class="figure-number">Figure&nbsp;143&nbsp;: </span>Modèle de circuit séquentiel programmable complexe</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org7a4d58d" class="outline-3">
<h3 id="org7a4d58d"><span class="section-number-3">12.3.</span> Circuits intégrés programmables</h3>
<div class="outline-text-3" id="text-12-3">
<p>
La version la plus sophistiquée des circuits logiques programmables
est sans contredit le circuit intégré programmable (en anglais, <i>Field
Programmable gate array</i>, (FPGA)). Un FPGA est constitué d'une matrice
de blocs polyvalents appelés <b>blocs logiques programmables</b> qui
permettent, selon leur configuration, de réaliser n'importe quelle
fonction logique. Un bloc logique est typiquement constitué d'une ou
de quelques <b>cellules logiques</b> élémentaires.
</p>

<p>
La figure <a href="#org888d0c3">144</a> montre une version simplifiée d'une cellule
logique comportant:
</p>
<ul class="org-ul">
<li>un tableau de correspondance (LUT) à quatre entrées</li>
<li>un additionneur complet</li>
<li>une cellule de mémoire</li>
</ul>


<div id="org888d0c3" class="figure">
<p><img src="Images_svg/cell_logique.svg" alt="cell_logique.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;144&nbsp;: </span>Cellule logique</p>
</div>

<p>
Le tableau de correspondance (LUT) à quatre entrées \(a, b, c, d\) est
fractionné en deux LUT de trois entrées, combinés par un multiplexeur
contrôlé par l'entrée \(d\). Pour des opérations arithmétiques, les
sorties des LUTs à trois entrées sont additionnées avec une retenue
externe \(R_i\). Le multiplexeur du centre, commandé par le signal de
sélection \(S_1\), sélectionne le résultat d'addition ou la fonction
réalisée par la LUT à 4 entrées. Selon le signal de sélection \(S_2\),
la valeur obtenue peut être acheminée directement en sortie de la
cellule (cellule en mode combinatoire) ou être stockée dans la bascule
D (cellule en mode séquentiel). Dans d'autres configuration typiques
de cellules, l'additionneur complet est remplacé par un tableau de
correspondance.
</p>

<p>
En plus de la matrice de blocs logiques, un circuit intégré
programmable comporte également des composants consacrés aux
entrées/sorties, des lignes d'interconnexion programmables pour relier
les blocs entre eux, des lignes de distribution de signaux d'horloge,
et possiblement de la mémoire RAM supplémentaire.
</p>

<p>
Les LUTs font appel à de la mémoire RAM pour implémenter les tableaux
de vérité, ce qui permet une configuration dynamique qui doit être
chargée lors de la mise en route du circuit programmable. Un autre
avantage est que ces mémoires permettent des vitesses de
fonctionnement nettement plus rapides que si on utilisait des mémoires
ROM.  Les données de configuration peuvent être stockées dans de la
mémoire <i>flash</i> externe par exemple. Le circuit FPGA peut donc être
reconfiguré et adapté à différentes fonctions, simplement en écrivant
de nouvelles données dans la mémoire externe qui contient ses
informations de configuration.
</p>

<p>
La configuration et la programmation d'un circuit programmable FPGA se
fait au moyen d'outils de synthèse spécialisés, souvent en fonction
d'une spécification au moyen d'un langage descriptif de matériel (en
anglais, <i>Hardware Description Language</i>, (HDL)).
</p>
</div>
</div>
</div>

<div id="outline-container-org1d0b147" class="outline-2">
<h2 id="org1d0b147"><span class="section-number-2">13.</span> Langages descriptifs et de modélisation</h2>
<div class="outline-text-2" id="text-13">
</div>
<div id="outline-container-org9f5453d" class="outline-3">
<h3 id="org9f5453d"><span class="section-number-3">13.1.</span> Objectifs</h3>
<div class="outline-text-3" id="text-13-1">
<ul class="org-ul">
<li>Pouvoir expliquer la différence entre un language descriptif de
matériel et un langage de programmation</li>
<li>Pouvoir expliquer les mécanismes d'assignation de signaux et la notion de concurrence</li>
<li>Savoir distinguer entre une description d'entité et une architecture</li>
<li>Savoir distinguer entre un modèle structural et un modèle
comportemental</li>
<li>Savoir distinguer entre un signal et une variable</li>
<li>Être familier avec les principaux types utilisés en descriptions
de circuits</li>
<li>Pouvoir préparer une description (modèle) de circuit en langage VHDL</li>
<li>Pouvoir préparer un banc d'essai permettant de tester un modèle de circuit</li>
<li>Pouvoir simuler un modèle VHDL au moyen d'un banc d'essai et
interpréter les résultats</li>
<li>Pouvoir élaborer une description complète en VHDL pour un système simple</li>
</ul>
</div>
</div>


<div id="outline-container-orgfcf7a9d" class="outline-3">
<h3 id="orgfcf7a9d"><span class="section-number-3">13.2.</span> Modélisation et simulation</h3>
<div class="outline-text-3" id="text-13-2">
<p>
Lorsque vient le temps de concevoir, simuler, tester et élaborer des
systèmes numériques complexes, les approches manuelles que nous avons
employées jusqu'ici ne suffisent plus. Il faut alors faire appel à des
familles d'outils plus puissants de conception assistée par
ordinateur. Avec ces outils, il est possible de concevoir et de
spécifier précisément le design voulu, en simuler le fonctionnement,
le valider par une batterie de tests, afin de s'assurer que le tout
correspond aux besoins de l'application avant même de solliciter une
seule porte logique physique.
</p>

<p>
Un élément clé de cette démarche est la possibilité de décrire
précisément le(s) circuit(s) qui seront implémentés au moyen d'un
langage approprié. Un tel <b>langage descriptif de matériel</b> (en anglais
<i>Hardware Description Language</i>, (HDL)), qui s'apparente à un langage
de programmation, permet de décrire de façon textuelle les différents
éléments de notre circuit, leurs interconnexions et interactions.
</p>

<p>
Alors qu'un langage de programmation spécifie essentiellement des
procédures et les données qui y sont associées, un HDL est un langage
de modélisation qui décrit des structures matérielles et le
comportement de systèmes logiques. Un HDL peut spécifier des
diagrammes logiques, des expressions logiques, voire, des tableaux de
vérité. Il permet aussi de décrire le comportement du système à
différents niveaux d'abstraction et les relations hiérarchiques entres
les différents sous-systèmes qui le composent.
</p>

<p>
On peut voir un modèle HDL comme la description des relations entre
les entrées et les sorties du système. Entrées et sorties sont
modélisées comme des <b>signaux</b>.
</p>
</div>
</div>

<div id="outline-container-org751d87a" class="outline-3">
<h3 id="org751d87a"><span class="section-number-3">13.3.</span> Le langage VHDL</h3>
<div class="outline-text-3" id="text-13-3">
<p>
Parmi les nombreux HDLs en usage, quelques uns ont été
standardisés. Les plus répandus sont <i>Verilog</i> et VHDL. C'est ce
dernier langage que nous allons utiliser.  Le V dans l'acronyme VHDL
(VHSIC Hardware Description Language) provient d'un autre acronyme,
VHSIC pour <i>Very High Speed Integrated Circuits</i> (circuits intégrés à
très haute vitesse). On comprend que le langage a été créé dans
l'optique de concevoir des circuits intégrés rapides et complexes.
</p>

<p>
Un design en VHDL est un ensemble d'entités de conception. Une entité,
celle du plus haut niveau, invoque les autres entités comme
composantes.  Le design dans son ensemble est structuré de façon
hiérarchique.
</p>
</div>
</div>

<div id="outline-container-org28e68cb" class="outline-3">
<h3 id="org28e68cb"><span class="section-number-3">13.4.</span> Entité</h3>
<div class="outline-text-3" id="text-13-4">
<p>
Une <b>entité</b> définit le nom d'un modèle et spécifie ses interfaces,
c'est-à-dire, les entrées et les sorties qui permettent au modèle
d'interagir avec son environnement. Le nom, la direction et le type
de chaque signal d'interface sont déclarés dans le <b>port</b> de
l'entité. La fonction du modèle n'est aucunement précisée. Il s'agit
uniquement de décrire la «coquille» d'une boîte noire.
</p>

<p>
La déclaration d'entité spécifie le nom de l'entité, et la liste des
ports d'entrée et de sortie. La forme générale est comme ci-dessous (les
éléments entre crochets sont optionnels). 
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;1&nbsp;: </span>Déclaration d'entité</label><pre class="src src-vhdl">entity Nom_Entite is 
[generic /generic_declarations/);]

port (noms_signaux: mode type;

noms_signaux: mode type;
  .
  .
  .
noms_signaux: mode type);

end [Nom_Entite];
</pre>
</div>

<p>
La déclaration commence avec le mot réservé <b>entity</b>, suivi du nom et
du mot réservé <b>is</b>. Viennent ensuite les déclarations de ports avec le
mot réservé <b>port</b>. La déclaration se termine avec le mot réservé
<b>end</b>, et optionnellement, le nom de l'entité.
</p>

<ul class="org-ul">
<li><i>Nom<sub>Entite</sub></i> est un nom arbitraire choisi par le concepteur.</li>

<li><i>noms<sub>signaux</sub></i> donne une liste d'un ou de plusieurs identifiants
séparés par des virgules qui définissent les signaux externes
d'interfaces.</li>

<li><b>mode</b>: est un des mots réservés suivants, qui définissent la
direction des signaux:

<ul class="org-ul">
<li><b>in</b>: le signal est une entrée</li>

<li><b>out</b>: le signal est une sortie de l'entité, qui peut être lue
par les autres entités qui y sont raccordées</li>

<li><b>buffer</b> le signal est une sortie qui peut être lue de
l'intérieur de l'architecture de l'entité</li>

<li><b>inout</b> le signal peut être une entrée ou une sortie</li>
</ul></li>

<li><i>type</i>: est un type de signal prédéfini ou défini par le
concepteur. Par exemple, bit, bit<sub>vector</sub>, Boolean, character,
std<sub>logic</sub>, ou std<sub>ulogic</sub>.

<ul class="org-ul">
<li><i>bit</i>: une valeur binaire  0 ou 1</li>

<li><i>bit<sub>vector</sub></i>: un vecteur de bits</li>

<li><i>std<sub>logic</sub>, std<sub>ulogic</sub>, std<sub>logic</sub><sub>vector</sub>, std<sub>ulogic</sub><sub>vector</sub></i>: des
valeurs binaires plus nuancées (voir librairies)</li>

<li><i>boolean</i>: deux valeurs possibles: TRUE ou FALSE</li>

<li><i>integer</i>: des valeurs entières</li>

<li><i>real</i>: des valeurs réelles</li>

<li><i>character</i>: des caractères</li>

<li><i>time</i>: des valeurs de temps</li>
</ul></li>

<li><b>generic:</b> les déclarations génériques sont optionnelles et
spécifient des constantes locales utilisées pour préciser par
exemple des valeurs de temps ou des tailles de vecteurs. Un
générique peut avoir une valeur de défaut. La syntaxe est comme ci-bas.</li>
</ul>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;2&nbsp;: </span>Déclarations génériques</label><pre class="src src-vhdl">generic (

nom_constante: type [:=valeur];

nom_constante: type [:=valeur];
.
.
.
nom_constante: type [:=valeur] );
</pre>
</div>


<p>
Le listing qui suit montre un exemple simple de déclaration d'entité. 
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;3&nbsp;: </span>Déclaration d'entité 2</label><pre class="src src-vhdl">entity ALU is
port (argl, arg2: in bit_vector;
add_or_sub: in bit;
result: out bit_vector);
end ALU;
</pre>
</div>
</div>
</div>

<div id="outline-container-org28ec914" class="outline-3">
<h3 id="org28ec914"><span class="section-number-3">13.5.</span> Architecture</h3>
<div class="outline-text-3" id="text-13-5">
<p>
Une <b>architecture</b> est une réalisation (ou implémentation) de
l'intérieur de la boîte noire. Jumelée à une entité, elle décrit
comment les sorties de l'entité sont obtenues à partir de ses
entrées. Il est possible d'associer de multiples architectures à une
même entité.
</p>

<p>
Une architecture peut contenir:
</p>

<ul class="org-ul">
<li>des déclarations de données</li>

<li>des affectations concurrentes de signaux</li>

<li>des blocs processus</li>

<li>des instanciations de composantes</li>
</ul>

<p>
La structure typique d'une architecture est comme dans le listing suivant.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;4&nbsp;: </span>Déclaration d'architecture</label><pre class="src src-vhdl">architecture nom_d_architecture of NOM_ENTITE is

-- Déclarations de types de données

-- Déclarations de composants

-- Déclarations de signaux

-- Déclarations de constantes

-- Déclarations de fonctions

-- Déclarations de procédures

begin

-- Énoncés concurrents ou séquentiels

end nom_d_architecture;
</pre>
</div>

<p>
Les énoncés qui peuvent se trouver dans le corps de l'architecture
(entre le <i>begin</i> et le <i>end</i> peuvent être des instanciations de
composants, des assignations de signaux ou des énoncés de processus.
</p>
</div>
</div>

<div id="outline-container-orgd5b923c" class="outline-3">
<h3 id="orgd5b923c"><span class="section-number-3">13.6.</span> Signaux et assignation</h3>
<div class="outline-text-3" id="text-13-6">
<p>
Un signal représente en quelque sorte un «fil». Une assignation comme
</p>

<p>
A &lt;= NOT(B);
</p>

<p>
signifie que A et B sont des signaux reliés dont l'un est l'inverse
logique de l'autre.  Ainsi,
</p>

<p>
A &lt;= B; 
</p>

<p>
signifie que les deux signaux A et B auront la même valeur logique.
</p>
</div>
</div>

<div id="outline-container-orgec6f4c5" class="outline-3">
<h3 id="orgec6f4c5"><span class="section-number-3">13.7.</span> Notes sur la syntaxe</h3>
<div class="outline-text-3" id="text-13-7">
<p>
Des expressions aussi complexes que désiré peuvent être écrites, en
utilisant des parenthèses pour spécifier les priorités d'évaluation
des opérations (si elles doivent être différentes de la précédence
implicite de VHDL).
</p>

<p>
Voici des exemples d'expressions.
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;5&nbsp;: </span>Expressions</label><pre class="src src-vhdl">a &lt;= ((b and c and f) or (t nor r)) nand p;

a(3 downto 0) &lt;=
b(4 downto 1) when (p and q)
else (p &amp; q &amp; q &amp; p);
</pre>
</div>

<p>
Les commentaires sont possibles: tout ce qui suit deux tirets (- -)
est ignoré.  Toutes les assignations doivent se terminer avec un
point-virgule (;)
</p>

<p>
Voici d'autres exemples d'assignations.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;6&nbsp;: </span>Assignations et commentaires</label><pre class="src src-vhdl">A &lt;= B OR C;

A &lt;= B AND C;

A &lt;= B NOR C;

A &lt;= B NAND C;

A &lt;= B XOR C;

A &lt;= NOT B; --ceci est un commentaire

A &lt;= (B AND C) OR (D AND E); --(aucune précédence 
			     -- pré-établie de AND/OR)
</pre>
</div>

<p>
On se contentera de ces opérations pour le moment. Les parenthèses
permettent de préciser l'ordre des opérations.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;7&nbsp;: </span>Précédence d'opérations et associativité</label><pre class="src src-vhdl">A &lt;= B AND C AND D; -- ceci fonctionne

A &lt;= B NAND C NAND D; -- pas ceci: NAND n'est pas associatif

A &lt;= NOT(B AND C AND D); -- ceci fonctionne
</pre>
</div>

<p>
Voici encore d'autres exemples d'assignations.  Le dernier de ces exemples
fait appel à des vecteurs de signaux. On verra plus loin comment
définir ces regroupements de signaux.
</p>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;8&nbsp;: </span>Assignations avec vecteurs de signaux</label><pre class="src src-vhdl">Sum &lt;= A XOR B XOR Cin;

Cout &lt;= (A AND B) OR (A AND Cin);

Cout &lt;= (A AND B) OR (A AND Cin) OR (B AND Cin);

a &lt;= b when c else a; -- sélection (multiplexage)

a(6 downto 1) &lt;= c &amp; d(3 downto 0) &amp; e; -- concaténation 
					-- bit-à-bit ("&amp;")

</pre>
</div>

<p>
De façon générale, VHDL est insensible aux MAJUSCULES ou minuscules,
et ignore les espaces supplémentaires et sauts de lignes. On doit
déclarer le type de tous les objets: signaux, constantes ou variables.
</p>
</div>
</div>

<div id="outline-container-org38253bc" class="outline-3">
<h3 id="org38253bc"><span class="section-number-3">13.8.</span> Concurrence</h3>
<div class="outline-text-3" id="text-13-8">
<p>
Dans un corps d'architecture, les assignations sont
<b>concurrentes</b>. Par exemple, dans ce qui suit, les deux énoncés sont
évalués en parallèle. Les valeurs pour q et qb sont continuellement
mises à jour: dès qu'un des signaux à droite de l'assignation change
(on dit qu'un évènement se produit sur le signal), l'énoncé est évalué
de nouveau.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;9&nbsp;: </span>Énoncés concurrents</label><pre class="src src-vhdl">q &lt;= r nor qb; -- énoncé 1
qb &lt;= s nor q; -- énoncé 2
</pre>
</div>

<p>
<b>Ce n'est pas comme en programmation</b> où les énoncés sont évalués
l'un après l'autre, une seule fois. Tous les énoncés concurrents sont
continuellement évalués.
</p>

<p>
L'effet de ces énoncés sera exactement le même si on les place dans un
autre ordre dans la description, comme ci-dessous.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;10&nbsp;: </span>Énoncés concurrents équivalents</label><pre class="src src-vhdl">qb &lt;= s nor q; -- énoncé 1
q &lt;= r nor qb; -- énoncé 2
</pre>
</div>

<p>
Le langage décrit à la base un circuit et non pas une procédure:
toutes les portes sont toujours alimentées, et les fils sont toujours
connectés. L'ordre dans lequel on donne la description n'a aucune
importance. On verra plus loin qu'il est aussi possible de définir des blocs
dans lesquels l'exécution est séquentielle comme en programmation.
</p>
</div>
</div>

<div id="outline-container-org58afca0" class="outline-3">
<h3 id="org58afca0"><span class="section-number-3">13.9.</span> Vecteurs de bits</h3>
<div class="outline-text-3" id="text-13-9">
<p>
Il est possible de grouper des signaux pour en faire des vecteurs, qui
sont des groupes ordonnés de bits: un mot, un bus, etc. De cette
façon, les spécifications sont plus compactes et faciles à
interpréter.
</p>

<p>
La convention la plus naturelle ordonne les indices de bits 
</p>
<pre class="example">
A(msb) $\longleftrightarrow$ A(lsb),
</pre>

<p>
mais l'ordre inverse est également possible. Il vaut mieux établir une
convention et s'y tenir pour éviter les errreurs d'interprétation.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;11&nbsp;: </span>Vecteur de bits</label><pre class="src src-vhdl">A(VALEUR_HAUTE downto VALEUR_BASSE)

A(15 downto 0) -- A comporte 16 bits

A(7 downto 3) -- 5 bits du milieu de A

A(0 to 7) -- A comporte 8 bits, énumérés de façon croissante
</pre>
</div>

<p>
L'opérateur de concaténation &amp; permet de combiner des groupes de bits
ensemble.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;12&nbsp;: </span>Concaténation</label><pre class="src src-vhdl">A(15 downto 0) &lt;= B(7 downto 0) &amp;
		  C(7 downto 0);
</pre>
</div>

<p>
Considérons par exemple la partie du calcul de somme de la description
d'un additionneur 8 bits ci-dessous.  Avec des déclarations adéquates,
on pourrait écrire un calcul de somme plus compact.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;13&nbsp;: </span>Calcul de somme initial</label><pre class="src src-vhdl">Sum(7 downto 0) &lt;= A(7 downto 0)
xor B(7 downto 0)
xor C(7 downto 0);

C(7 downto 0) &lt;= (A(7 downto 0) and
B(7 downto 0)
)
or (A(7 downto 0) and
(C(6 downto 0) &amp; Cin)
)
or (B(7 downto 0) and
(C(6 downto 0) &amp; Cin)
);

Cout &lt;= C(7);
</pre>
</div>



<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;14&nbsp;: </span>Calcul de somme compact</label><pre class="src src-vhdl">Sum &lt;= A xor B xor (C(6 downto 0) &amp; Cin);

C &lt;= (A and B) or
(A and (C(6 downto 0) &amp; Cin) ) or
(B and (C(6 downto 0) &amp; Cin) );

Cout &lt;= C(7);
</pre>
</div>
</div>
</div>

<div id="outline-container-org905a75a" class="outline-3">
<h3 id="org905a75a"><span class="section-number-3">13.10.</span> Modèle complet</h3>
<div class="outline-text-3" id="text-13-10">
<p>
Considérons la bascule JK maître-esclave de la figure <a href="#org43f1485">94</a>
ci-dessous, construite au moyen de portes simples.  Un modèle
vhdl complet pour cette bascule JK maître-esclave est donné ensuite.
</p>


<div id="orgd8c2633" class="figure">
<p><img src="Images_svg/JK-MS.svg" alt="JK-MS.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure&nbsp;145&nbsp;: </span>Bascule JK maître-esclave à modéliser</p>
</div>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;15&nbsp;: </span>Bascule JK maître-esclave</label><pre class="src src-vhdl">library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Bascule JK maître-esclave.
-- La bascule maître mémorise sur une horloge haute, 
-- la bascule esclave mémorise sur un horloge basse. 
-- Les deux rétroactions évitent les conditions 
-- interdites aux entrées 
entity mainJK is
  port (
    J: in std_logic; -- entrée J (set) de la bascule
    C: in std_logic; -- entrée d'horloge
    K: in std_logic; -- entrée K (reset) de la bascule
    Q: out std_logic; -- bit stocké
    notQ: out std_logic -- inverse du bit stocké
    );
end main;

architecture Complet of mainJK is
  signal notQ_temp: std_logic;
  signal Q_temp: std_logic;
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
begin
  s0 &lt;= NOT C;
  s2 &lt;= NOT ((notQ_temp AND J AND C) OR s1);
  s1 &lt;= NOT (s2 OR (C AND K AND Q_temp));
  Q_temp &lt;= NOT ((s2 AND s0) OR notQ_temp);
  notQ_temp &lt;= NOT (Q_temp OR (s0 AND s1));
  Q &lt;= Q_temp;
  notQ &lt;= notQ_temp;
end Complet;
</pre>
</div>
</div>
</div>

<div id="outline-container-org236772d" class="outline-3">
<h3 id="org236772d"><span class="section-number-3">13.11.</span> Modèle comportemental</h3>
<div class="outline-text-3" id="text-13-11">
<p>
Un modèle comportemental d'une entité est un ensemble d'énoncés qui
sont exécutés séquentiellement. Ces énoncés peuvent se trouver dans
des blocs PROCESS, FUNCTION ou PROCEDURE. Un tel bloc est concurrent
avec les autres énoncés du modèle général. Il est possible d'utiliser
des variables à l'intérieur des processus. Un énoncé d'assignation
spécifique aux variables permet d'assigner (sans délai) une valeur à
une variable qui a été préalablement déclarée. On se rapproche alors
de la programmation traditionnelle. Les variables sont locales aux
processus. Dans un bloc processus, il est possible d'avoir des
boucles, des branchements conditionnels, etc. Dans le corps de
l'entité, un bloc processus apparaît comme une grosse porte logique
arbitrairement définie par le concepteur du bloc.
</p>
</div>
</div>

<div id="outline-container-org36a3c41" class="outline-3">
<h3 id="org36a3c41"><span class="section-number-3">13.12.</span> Modèle flux de données</h3>
<div class="outline-text-3" id="text-13-12">
<p>
Dans un modèle flux de données, c'est le mouvement des données qui est
exprimé par un ensemble d'énoncés concurrents. On peut faire appel à
des opérateurs logiques AND, OR, NOT, etc., pour décrire les relations
entres les signaux.
</p>
</div>
</div>

<div id="outline-container-org593e34f" class="outline-3">
<h3 id="org593e34f"><span class="section-number-3">13.13.</span> Modèle structural</h3>
<div class="outline-text-3" id="text-13-13">
<p>
Un modèle structural décrit des ensembles de composants
interconnectés. Un énoncé d'instanciation d'un composant (qui revient
à dire quelque chose comme «utiliser le composant X ici» est un énoncé
concurrent qui indique de créer une instance de la «chose» spécifiée.
</p>

<p>
Une telle description structurale se contente de préciser quels
composants seront reliés à quels autres composants, sans référence au
comportement desdits composants.
</p>

<p>
Les énoncés qui suivent le <b>begin</b> spécifient l'instanciation de
composants et les interconnexions. Un énoncé d'instantiation de
composant crée un nouveau niveau hiérarchique. Chaque ligne commence
avec un <i>nom d'instance</i>, suivi de deux-points (':'), d'un nom de
composant et du mot réservé <b>port map</b>.  Ce <b>port map</b> spécifie les
interconnexions du composant. On se rappellera que l'ordre de ces
énoncés est sans conséquences.
</p>
</div>
</div>

<div id="outline-container-org181b628" class="outline-3">
<h3 id="org181b628"><span class="section-number-3">13.14.</span> Bloc processus</h3>
<div class="outline-text-3" id="text-13-14">
<p>
Un énoncé <i>process</i> permet de définir un processus. Le format est le
suivant.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;16&nbsp;: </span>Bloc processus</label><pre class="src src-vhdl">[étiquette_processus:] process [ (liste_sensibilité) ] [is]
[déclarations_processus]
begin
--   liste d'énoncés séquentiels tels que:
-- assignations de signaux 
-- assignations de variables
-- énoncés /case/
-- énoncés /exit/
-- énoncés /if/ 
-- énoncés /loop/ 
-- énoncés /next/
-- énoncés /null/
-- appels de procedure
-- énoncés /wait/
end process [etiquette_processus];
</pre>
</div>

<p>
Voici un exemple d'un modèle avec bloc processus d'une bascule D
déclenchée sur un front montant avec mise à zéro asynchrone.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;17&nbsp;: </span>Bascule D, front montant, mise à zéro asynchrone</label><pre class="src src-vhdl">library ieee;
use ieee.std_logic_1164.all;

entity DFF_CLEAR is
   port (CLK, CLEAR, D : in std_logic;
      Q : out std_logic);

end DFF_CLEAR;

architecture COMPORT_DFF of DFF_CLEAR is
begin
DFF_PROCESS: process (CLK, CLEAR)
   begin
      if (CLEAR = '1') then
	 Q &lt;= '0';
      elsif (CLK'event and CLK = '1') then
	 Q &lt;= D;
      end if;
   end process;
end COMPORT_DFF;
</pre>
</div>

<p>
Le processus, déclaré à l'intérieur d'une architecture, est un énoncé
concurrent.  Mais tout ce qui se déroule à l'intérieur du processus
est exécuté de façon séquentielle. Comme tout énoncé concurrent, le
processus lit et écrit des signaux sur ses ports d'interface. Dans
l'exemple précédent, la sortie Q reçoit des valeurs par assignation au
sein du processus. L'expression CLK'<b>event</b> <b>and</b> CLK = '1' teste une
condition de front montant sur l'interface d'entrée CLK.
</p>

<p>
Il ne peut pas y avoir de déclarations de signaux dans un processus;
seules des variables ou des constantes peuvent être déclarées.
</p>

<p>
Une <b>liste de sensibilité</b> est un ensemble de signaux qui déclenchent
l'exécution du processus. N'importe quel changement sur un des signaux
de la liste provoque l'exécution immédiate du processus.
</p>

<p>
S'il n'y a pas de liste de sensibilité, il faudra inclure un énoncé
<i>wait</i> pour s'assurer que le processus se termine. Il n'est pas permis
d'avoir à la fois une liste de sensibilité et un énoncé <i>wait</i> pour un
même processus. Les variables et constantes utilisées dans le
processus sont définie dans la portion déclarations<sub>processus</sub>. 
</p>

<p>
Les énoncés entre <b>begin</b> et <b>end</b> sont exécutés séquentiellement. Les
assignations de variables, dénotées :=, sont exécutées immédiatement. 
</p>

<p>
Un énoncé concurrent est comme un processus d'une seule ligne, dont la
liste de sensibilité est constituée de tous les signaux qui sont à
droite de l'assignation.
</p>

<p>
Il est possible de définir un processus dont le corps est une
description combinatoire. Par exemple, le processus suivant permet de
modéliser une porte OU entre les entrées a et b. 
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;18&nbsp;: </span>Processus avec porte OU combinatoire</label><pre class="src src-vhdl">proc1: process
  begin
    wait on a, b;
    s &lt;= a or b;
  end process proc1;
</pre>
</div>

<p>
La sensibilité d'un tel processus (ici obtenue au moyen de l'énoncé
<i>wait</i> on a, b;) doit comporter tous les signaux utilisés pour que
l'exécution se fasse dès qu'une des entrées change de valeur.
</p>

<p>
Les assignations de signaux dans un processus ne prennent effet qu'une
fois que le processus est suspendu. Cela veut notamment dire que c'est
seulement la dernière assignation à un signal donné qui sera
effectivement exécutée.
</p>

<p>
Si un processus effectue une lecture d'un signal qui se verra aussi
assigner une valeur par le processus, la lecture prendra en compte la
valeur précédente du signal <b>avant</b> qu'il soit affecté par
l'assignation. Il est donc possible de créer de la rétroaction au sein
d'un même processus.
</p>
</div>
</div>

<div id="outline-container-orga5de0fc" class="outline-3">
<h3 id="orga5de0fc"><span class="section-number-3">13.15.</span> Modélisation du délai</h3>
<div class="outline-text-3" id="text-13-15">
<p>
Deux formes de délai peuvent être modélisés en VHDL. Le délai inertiel
et le délai de transport.
</p>
</div>

<div id="outline-container-orgf06adf0" class="outline-4">
<h4 id="orgf06adf0"><span class="section-number-4">13.15.1.</span> Délai inertiel</h4>
<div class="outline-text-4" id="text-13-15-1">
<p>
Le délai inertiel est la forme de délai par défaut. Le mot réservé
<i>after</i> suppose par défaut un délai inertiel. Avec du délai inertiel,
deux changements consécutifs du signal d'entrée qui sont plus
rapprochés temporellement que la valeur de délai ne seront pas
reflétés sur le signal de sortie. On modélise alors une inertie du
circuit, qui est trop lent pour réagir lorsque les changements
d'entrée sont trop rapides pour lui. Par exemple, avec une
assignation comme la suivante:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;19&nbsp;: </span>Délai inertiel</label><pre class="src src-vhdl">b &lt;= a after 30 ns;
</pre>
</div>

<p>
Si le signal a passe de '0' à '1' à 10 ns et de '1' à '0' à 20 ns, la
sortie ne changera pas du tout et restera tout le temps à '0'.
</p>
</div>
</div>

<div id="outline-container-orgfcc8386" class="outline-4">
<h4 id="orgfcc8386"><span class="section-number-4">13.15.2.</span> Délai de transport</h4>
<div class="outline-text-4" id="text-13-15-2">
<p>
Le délai de transport applique un retard dans le signal de sortie. Par
exemple, avec la spécification suivante:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;20&nbsp;: </span>Délai de transport</label><pre class="src src-vhdl">b &lt;= transport a after 20 ns;
</pre>
</div>
<p>
Si le signal a passe de '0' à '1' à 10 ns et de '1' à '0' à 20 ns, la
sortie passera de '0' à '1' à 30 ns et de '1' à '0' à 40 ns,
reproduisant en sortie la même forme d'onde qu'en entrée, mais
retardée de 20 ns.
</p>
</div>
</div>
</div>

<div id="outline-container-org56d357f" class="outline-3">
<h3 id="org56d357f"><span class="section-number-3">13.16.</span> Librairies</h3>
<div class="outline-text-3" id="text-13-16">
<p>
Des librairies de types peuvent être définies pour préciser des types
d'objets qui pourront ensuite être utilisés de façon standard. Par
exemple, la librairie IEEE std<sub>logic</sub><sub>1164</sub> définit le type logique
<i>std<sub>logic</sub></i> qui apporte plus de nuances que le simple type binaire,
qui lui ne comporte que deux valeurs numériques '0' et '1'.
</p>

<p>
Le tableau suivant donne la liste des valeurs possibles avec
<i>std<sub>logic</sub></i>. Comme on peut le voir, les signaux pourront ainsi assumer
des valeurs comme Z (haute impédance pour les signaux trois-états), X
(pour valeur inconnue), - pour valeur facultative, etc. Il y a même
des nuances pour la solidité des valeurs logiques.
</p>

<table id="org967fc41" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 63 :</span> Valeurs pour <i>std<sub>logic</sub></i></caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Symbole</th>
<th scope="col" class="org-left">Interprétation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">'1'</td>
<td class="org-left">1 Logique</td>
</tr>

<tr>
<td class="org-left">'0’</td>
<td class="org-left">0 Logique</td>
</tr>

<tr>
<td class="org-left">'Z'</td>
<td class="org-left">Haute impédance</td>
</tr>

<tr>
<td class="org-left">'W'</td>
<td class="org-left">Signal faible, indéterminé entre 0 ou 1</td>
</tr>

<tr>
<td class="org-left">'L'</td>
<td class="org-left">0 faible, <i>pulldown</i></td>
</tr>

<tr>
<td class="org-left">'H'</td>
<td class="org-left">1 faible, <i>pullup</i></td>
</tr>

<tr>
<td class="org-left">'-'</td>
<td class="org-left"><i>Don't care</i></td>
</tr>

<tr>
<td class="org-left">'U'</td>
<td class="org-left">Non-initialisé</td>
</tr>

<tr>
<td class="org-left">'X'</td>
<td class="org-left">Inconnu, conflit entre sources multiples</td>
</tr>
</tbody>
</table>

<p>
Une clause <i>use</i> permet de spécifier les librairies à utiliser au
début du fichier de spécification. Par exemple, le fichier vhdl
pourrait commencer avec les déclarations du listing suivant:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;21&nbsp;: </span>Déclaration de librairies</label><pre class="src src-vhdl">library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
</pre>
</div>

<p>
On a déjà vu un exemple de l'utilisation de librairies dans le modèle
de la bascule JK maître-esclave.
</p>
</div>
</div>

<div id="outline-container-org4ac69b7" class="outline-3">
<h3 id="org4ac69b7"><span class="section-number-3">13.17.</span> Encapsulation</h3>
<div class="outline-text-3" id="text-13-17">
<p>
Il est possible de grouper des énoncés ensemble, et de les ré-utiliser
au besoin, dans d'autre modèles. Ceci nous permet de «cacher» la
description dans une boîte. Dans ce cas-ci, il s'agit d'un loquet SR
construit avec des portes NOR.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;22&nbsp;: </span>Encapsulation</label><pre class="src src-vhdl">entity rs is
port(r, s: in bit; q, qb: out bit);
end rs;

architecture norlogic of rs is
begin
q &lt;= r nor qb;
qb &lt;= s nor q;
end nor_logic;
</pre>
</div>

<p>
L'entité définie est une composante qui peut être utilisée dans
d'autres circuits, à l'intérieur d'une hiérarchie de design. Voici
comment on peut utiliser le composant loquet pour modéliser un loquet D.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;23&nbsp;: </span>Utilisation d'une composante</label><pre class="src src-vhdl">entity Dlatch is
port (clk,d: in bit; q,qb: out bit);
end Dlatch;

architecture test of Dlatch is
--
signal db, cr, cs: bit;
--
component rs_ff
port (r, s: in bit;
q, qb: out bit);
end component;
--
label rs0;
--
for rs0: rs_ff
use entity rs(nor_logic);

begin
db &lt;= not d;
cr &lt;= db and clk;
cs &lt;= d and clk;
rs0: rs_ff port map(cr, cs, q, qb);
end test;
</pre>
</div>

<p>
Voici un exemple de bascule maître-esclave conçue de façon structurale
à partir du composant loquet:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;24&nbsp;: </span>Bascule maître-esclave structurale</label><pre class="src src-vhdl">entity MS is
port (clear,reset,set,clock: in bit;
q, qbar: out bit);
end MS;

architecture ms_struct of MS is
signal clrbar, r0, s0, q0, qbar0,
r1, s1, cbar: bit;
label rs0, rs1;
component rs_ff
port (r,s: in bit; q,qbar: out bit);
end component;
for rs0, rs1: rs_ff
use entity RS(nor_logic);
begin
clrbar &lt;= not clear;
cbar &lt;= not clock;
r0 &lt;= (reset and clock) or clear;
s0 &lt;= (set and clock) and clrbar;
rs0: rs_ff port map(r0,s0,q0,qbar0);
r1 &lt;= (qbar0 and cbar) or clear;
s1 &lt;= (q0 and cbar) and clrbar;
rs1: rs_ff port map(r1,s1,q,qbar);
end ms_struct;
</pre>
</div>

<p>
Voici un exemple de compteur élaboré à partir de cette bascule maître-esclave:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;25&nbsp;: </span>Compteur basé sur la bascule</label><pre class="src src-vhdl">entity CNTER is
port (clock, clear: in bit;
a: out bit_vector(3 downto 0));
end CNTER;

architecture count of CNTER is
signal b: bit_vector(3 downto 0);
component ms_ff
port (clr, r, s, c: in bit;
q, qbar: out bit);
end component;
label ms0, msl, ms2, ms3;
for ms0, msl, ms2, ms3: ms_ff
use entity MS(ms_struct);
begin
ms0: ms_ff port map(
clear,a(0),b(0),clock,a(0),b(0));
ms1: ms_ff port map(
clear,a(1),b(1),a(0),a(1),b(1));
ms2: ms_ff port map(
clear,a(2),b(2),a(1),a(2),b(2));
ms3: ms_ff port map(
clear,a(3),b(3),a(2),a(3),b(3));
end count;
</pre>
</div>
</div>
</div>


<div id="outline-container-org07fe218" class="outline-3">
<h3 id="org07fe218"><span class="section-number-3">13.18.</span> Description de design en VHDL</h3>
<div class="outline-text-3" id="text-13-18">
<p>
La description complète du système à simuler est placée dans un
fichier avec extension .vhdl qui est ensuite compilé et simulé.  On
appelle cette description «fichier de design» ou design tout court.
</p>

<p>
Un design en VHDL est un ensemble d'entités de conception. L'entité de
plus haut niveau invoque les autres entités comme composantes. Le design
dans son ensemble est appelé hiérarchie de design.
</p>
</div>

<div id="outline-container-orgf7602a3" class="outline-4">
<h4 id="orgf7602a3"><span class="section-number-4">13.18.1.</span> Multiplicateur huit bits</h4>
<div class="outline-text-4" id="text-13-18-1">
<p>
Voici l'exemple d'un multiplicateur huit bits construit à partir de
plusieurs autres composants.  Les listings qui suivent donnent le
détail de la modélisation.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;26&nbsp;: </span>Multiplicateur 8 bits: entités</label><pre class="src src-vhdl">entity multiply is
port (load, clock: in bit;
input1, input2: in
bit_vector(7 downto 0);
product: out
bit_vector(15 downto 0);
output_valid: out bit);
end multiply;
--
entity adder is
port(a: in bit_vector(7 downto 0);
b: in bit_vector(7 downto 0);
cin: in bit;
sum: out bit_vector(7 downto 0)
cout: out bit) ;
end adder;
--
entity D_FF is
port(din: in bit_vector(7 downto 0)
dout: out bit_vector(7 downto 0)
enable: in bit);
end D_FF;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;27&nbsp;: </span>Multiplicateur 8 bits: composante adder</label><pre class="src src-vhdl">architecture logic of adder is
signal cw, cx: bit_vector(7 downto 0);
--
begin
cw(0) &lt;= cin;
cw(7 downto 1) &lt;= cx(6 downto 1);
cx &lt;= (a and b) or (a and cw) or (b and cw);
sum &lt;= a xor b xor cw;
cout &lt;= cx(7);
end logic;
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;28&nbsp;: </span>Multiplicateur 8 bits: composante FF</label><pre class="src src-vhdl">architecture edge of D_FF is
-- une bascule D de 8 bits de large
signal x, y, z, w, qb, e :
bit_vector(7 downto 0);
begin
e &lt;= "11111111" when enable else 0;
x &lt;= din nand y;
y &lt;= e nand (not w);
z &lt;= e nand w;
w &lt;= z nand x;
dout &lt;= z nand qb;
qb &lt;= y nand dout;
end edge;
</pre>
</div>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;29&nbsp;: </span>Multiplicateur 8 bits: déclarations</label><pre class="src src-vhdl">architecture mult of multiply is
signal mux1, mux2, mux3, mux4:
bit_vector(7 downto 0);
signal control, adder_out:
bit_vector(7 downto 0);
signal accum:
bit_vector(15 downto 0);
signal carry_out: bit;
label l1, l2, l3, l4;

component add
port (argl, arg2: in bitvec;
c_in: in bit;
result: out bitvec;
c_out: out bit);
end component;
for l4: add use entity adder(logic);

component latch
port (xin: in bitvec;
xout: out bitvec; enable: in bit);
end component;
for l1, l2, l3: latch use
entity D_FF(edge);
</pre>
</div>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;30&nbsp;: </span>Multiplicateur 8 bits: descriptions</label><pre class="src src-vhdl">begin mux1(7 downto 0) &lt;= 255 when load else "0" &amp; contro1(7 downto
1); l1: latch port map ( mux1, control, clock);

mux2 &lt;= 0 when load else
carry_out &amp; adder_out(7 downto 1);
l2: latch port map (
mux2, accum(15 downto 8), clock);

mux3 &lt;= input2 when load else
adder_out(0) &amp; accum(7 downto 1);
l3: latch port map (
mux3, accum(7 downto 0), clock);

mux4 &lt;= input1 when accum(0) else 0;
l4: add port map (
mux4, accum(15 downto 8), "0",
adder_out, carry_out);

output_valid &lt;= not(control(0));
product &lt;= accum when output_valid
else 0;
end mult;
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org2cf741d" class="outline-3">
<h3 id="org2cf741d"><span class="section-number-3">13.19.</span> Banc d'essai</h3>
<div class="outline-text-3" id="text-13-19">
<p>
Pour simuler un circuit avec un HDL, on doit lui appliquer des signaux
aux entrées afin que le simulateur puisse générer les sorties
correspondantes. Une description qui vise à générer ces signaux
d'entrée est appelée un <b>banc d'essai</b>.
</p>


<div class="org-src-container">
<pre class="src src-ditaa">Banc d'essai

+--------------+       +---------------+       +------------------+        
|              |       |               |       |                  |        
|              |       |     Modèle    |       |    Validation    |        
|              |       |               |       |                  |        
|   Stimulus   +------&gt;|        à      +------&gt;|       des        |
|              |       |               |       |                  |        
|              |       |     tester    |       |     sorties      |        
|              |       |               |       |                  |        
+--------------+       +---------------+       +------------------+         
</pre>
</div>


<div id="org35f1b84" class="figure">
<p><img src="Images_png/banc_essai.png" alt="banc_essai.png" />
</p>
<p><span class="figure-number">Figure&nbsp;146&nbsp;: </span>Banc d'essai</p>
</div>

<p>
Le bloc stimulus génère les signaux d'excitation qui sont appliqués
aux entrées du modèle à tester. Un bloc se charge de valider les
sorties observées, ce qui peut être fait automatiquement.
</p>

<p>
On commence par définir une entité de niveau supérieur pour le banc
d'essai:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;31&nbsp;: </span>Entité banc d'essai</label><pre class="src src-vhdl">entity test_bench is

end entity test_bench;
</pre>
</div>

<p>
L'entité ne comporte pas de ports, puisque le banc d'essai ne comporte
pas d'entrées ou de sorties externes.
</p>
</div>
</div>

<div id="outline-container-org9e26d76" class="outline-3">
<h3 id="org9e26d76"><span class="section-number-3">13.20.</span> Instanciation</h3>
<div class="outline-text-3" id="text-13-20">
<p>
Il faut ensuite instancier le modèle à tester. L'instanciation peut se
faire comme composant ou directement. À moins de vouloir définir un
<i>package</i> pour le modèle à tester, le composant doit être défini <b>avant</b>
le code principal. 
</p>

<p>
Voici un exemple de déclaration d'instanciation par composant. Les
noms de composant et de ports doivent correspondre à ceux du modèle à
tester.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;32&nbsp;: </span>Banc d'essai: instanciation par composant</label><pre class="src src-vhdl">component and_gate is 
port ( 
   a : in std_logic; 
   b : in std_logic; 
   and_out : out std_logic 
); 
end component and_gate; 
</pre>
</div>

<p>
Le composant est ensuite relié au modèle de test. 
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;33&nbsp;: </span>Composant lié</label><pre class="src src-vhdl">and_gate_instance: component and_gate
  port map (
    a       =&gt; signal_a,
    b       =&gt; signal_b,
    and_out =&gt; signal_and_out
  );
</pre>
</div>

<p>
Chaque instanciation doit avoir son propre nom. Ici, c'est
<i>and<sub>gate</sub><sub>instance</sub></i>. Les noms de signaux à gauche sont les noms des
ports du composant. Les noms à droite sont les signaux qui sont reliés
aux ports. Ces signaux doivent être déclarés avant utilisation et
avoir le bon type.
</p>

<p>
Voici un exemple d'instanciation directe:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;34&nbsp;: </span>Instanciation directe</label><pre class="src src-vhdl">and_gate_instance: entity work.and_gate(ltr)
  port map (
    a       =&gt; signal_a,
    b       =&gt; signal_b,
    and_out =&gt; signal_and_out
  );
</pre>
</div>

<p>
Dans ce cas, il faut également préciser la librairie et l'architecture
pour le modèle à tester. Ici, la librairie est "work" et
l'architecture est "ltr".
</p>
</div>
</div>

<div id="outline-container-org73cd4cf" class="outline-3">
<h3 id="org73cd4cf"><span class="section-number-3">13.21.</span> Écoulement du temps</h3>
<div class="outline-text-3" id="text-13-21">
<p>
Pour tester le modèle, on doit typiquement produire des signaux qui
varient en fonction du temps. Pour ce faire, il est possible
d'utiliser les énoncés <i>after</i> et <i>wait</i>. Il existe un type prédéfini
VHDL pour le temps, qui utilise les unités suivantes:
</p>

<table id="org80ddbb8" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 64 :</span> Unités de temps</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Unité</th>
<th scope="col" class="org-left">Valeur</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">fs</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">ps</td>
<td class="org-left">1000 fs</td>
</tr>

<tr>
<td class="org-left">ns</td>
<td class="org-left">1000 ps</td>
</tr>

<tr>
<td class="org-left">us</td>
<td class="org-left">1000 ns</td>
</tr>

<tr>
<td class="org-left">ms</td>
<td class="org-left">1000 us</td>
</tr>

<tr>
<td class="org-left">sec</td>
<td class="org-left">1000 ms</td>
</tr>

<tr>
<td class="org-left">min</td>
<td class="org-left">60 sec</td>
</tr>

<tr>
<td class="org-left">hr</td>
<td class="org-left">60 min</td>
</tr>
</tbody>
</table>

<p>
La plus petite unité de temps correspond à une femtoseconde (\(10^{-15}\) seconde).
</p>

<p>
Voici des exemples d'énoncés liés au temps:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;35&nbsp;: </span>Énoncés liés au temps</label><pre class="src src-vhdl">time_ex &lt;= 100 ps; -- 100 picoseconds 
time_ex &lt;= 1.2 ns; -- 1200 picoseconds
time_ex &lt;= 1.2 sec; -- 1200 milliseconds
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgd88eebd"></a>Énoncé <i>after</i><br />
<div class="outline-text-5" id="text-13-21-0-1">
<p>
L'énoncé <i>after</i> ajoute un aspect temporel à une assignation. La
partie de l'énoncé qui précède la virgule est une assignation qui
fonctionne comme toute assignation normale. La deuxième partie de
l'énoncé spécifie une nouvelle valeur pour le signal, qui prendra effet
au temps (futur) indiqué.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;36&nbsp;: </span>Énoncé after</label><pre class="src src-vhdl">&lt;signal&gt; &lt;= &lt;valeur_initiale&gt;, &lt;valeur_finale&gt; after &lt;temps&gt;;
</pre>
</div>

<p>
Voici un exemple d'utilisation pour créer un signal de mise à zéro:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;37&nbsp;: </span>Signal de mise à zéro</label><pre class="src src-vhdl">reset &lt;= '1', '0' after 1 us;
</pre>
</div>

<p>
L'exemple suivant montre une méthode simple pour générer un signal
d'horloge. La période obtenue sera le double du délai, soit ici 20 ns.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;38&nbsp;: </span>Signal d'horloge</label><pre class="src src-vhdl">clock &lt;= not clock after 10 ns;
</pre>
</div>
</div>
</li>

<li><a id="org158fb7b"></a>L'énoncé <i>wait</i><br />
<div class="outline-text-5" id="text-13-21-0-2">
<p>
L'énoncé <i>wait</i> suspend l'exécution dans un bloc processus pendant un
certain temps. Rappelons que le processus ne peut pas avoir de liste
de sensibilité. Trois types d'usage de <i>wait</i> sont possibles:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;39&nbsp;: </span>Énoncé wait</label><pre class="src src-vhdl">wait for &lt;time&gt;; 

wait until &lt;condition&gt; for &lt;time&gt;;

wait on &lt;signal_name&gt;;
</pre>
</div>

<p>
Dans le premier cas, l'exécution est stoppée pendant la durée
indiquée.
</p>

<p>
Dans le deuxième cas, l'exécution est stoppée jusqu'à ce que la
condition soit remplie. Il est possible de fonder les conditions sur
des macros pour les fronts montants <i>rising<sub>edge</sub></i> ou descendants
<i>falling<sub>edge</sub></i>. La portion <i>for</i> est optionnelle. Elle permet de
prévoir un temps d'attente maximal. L'attente s'arrêtera donc si la
condition est remplie ou après l'écoulement du temps spécifié.
</p>

<p>
Dans le troisième cas, on attend simplement qu'un évènement se
produise sur le signal spécifié pour cesser l'attente. Il est possible
de spécifier une liste de signaux en les séparant par des virgules:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;40&nbsp;: </span>Liste de signaux en attente d'évènement</label><pre class="src src-vhdl">wait on sig_a, sig_b;
</pre>
</div>
</div>
</li>
</ol>
</div>


<div id="outline-container-org5bef9d9" class="outline-3">
<h3 id="org5bef9d9"><span class="section-number-3">13.22.</span> Exemples de banc d'essai</h3>
<div class="outline-text-3" id="text-13-22">
<p>
On va tester un circuit séquentiel simple comportant deux entrées A et
B qui passent par une porte ET, et une bascule avec sortie Q.
</p>
</div>

<div id="outline-container-org7a2bcba" class="outline-4">
<h4 id="org7a2bcba"><span class="section-number-4">13.22.1.</span> Création d'une entité vide pour le banc d'essai</h4>
<div class="outline-text-4" id="text-13-22-1">
<p>
L'extrait de code suivant montre le point de départ de notre banc
d'essai.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;41&nbsp;: </span>Entité vide pour banc d'essai</label><pre class="src src-vhdl">entity exemple_tb is
end entity exemple_tb;

architecture test of exemple_tb is

--

end architecture exemple_tb;
</pre>
</div>
</div>
</div>

<div id="outline-container-org57cd228" class="outline-4">
<h4 id="org57cd228"><span class="section-number-4">13.22.2.</span> Instanciation du modèle à tester</h4>
<div class="outline-text-4" id="text-13-22-2">
<p>
On fait une instanciation directe ici. L'extrait de code suivant
montre comment la spécifier, en supposant que les signaux in<sub>a</sub>, in<sub>b</sub>
et out<sub>q</sub> ont été déclarés précédemment:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;42&nbsp;: </span>Instanciation du modèle</label><pre class="src src-vhdl">
-- Instanciation du modèle à tester 
dut: entity work.exemple_design(rtl)
  port map (
    a =&gt; in_a,
    b =&gt; in_b,
    q =&gt; out_q
   );

</pre>
</div>
</div>
</div>

<div id="outline-container-orgaea0135" class="outline-4">
<h4 id="orgaea0135"><span class="section-number-4">13.22.3.</span> Génération de l'horloge et du signal de mise à zéro</h4>
<div class="outline-text-4" id="text-13-22-3">
<p>
Il faut ensuite générer les signaux d'horloge et de mise à zéro, en
spécifiant les éléments temporels. Les deux signaux seront définis de
façon concurrente. On prévoit une inversion d'horloge à toutes les 10
ns, ce qui donne une période de 20 ns qui correspond à une fréquence
de 50 MHz. L'extrait de code suivant montre les détails:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;43&nbsp;: </span>Génération de signaux de test</label><pre class="src src-vhdl">-- Reset et clock
clock &lt;= not clock after 10 ns;
reset &lt;= '1', '0' after 50 ns;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd98612b" class="outline-4">
<h4 id="orgd98612b"><span class="section-number-4">13.22.4.</span> Stimulus</h4>
<div class="outline-text-4" id="text-13-22-4">
<p>
Le dernier élément à spécifier est le stimulus, c'est-à-dire, les
signaux qui seront appliqués aux entrées de notre modèle à
tester. Nous utilisons un processus pour générer les quatre
combinaisons possibles de nos deux entrées.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;44&nbsp;: </span>Stimulus pour entrées</label><pre class="src src-vhdl">  -- Génération du stimulus
  stimulus:
  process begin
    -- Attendre que reset soit activé
    wait until (reset = '0');

    -- Générer chaque condition, avec 2 périodes entre chaque
    -- itération pour laisser du temps pour la propagation
    and_in &lt;= "00";
    wait for 20 ns;
    and_in &lt;= "01";
    wait for 20 ns;
    and_in &lt;= "10";
    wait for 20 ns;
    and_in &lt;= "11";

    -- Fin du test
    wait;
  end process stimulus;

end architecture exemple_tb;
</pre>
</div>
</div>
</div>

<div id="outline-container-org1656510" class="outline-4">
<h4 id="org1656510"><span class="section-number-4">13.22.5.</span> Exemples complets</h4>
<div class="outline-text-4" id="text-13-22-5">
<p>
Dans le premier exemple, on fait appel ici au mot réservé <i>alias</i> qui
permet de rendre le code plus facile à comprendre en nommant un
sous-ensemble du type <i>array</i> qui a été utilisé pour générer les
combinaisons d'entrées.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;45&nbsp;: </span>Premier exemple complet de banc d'essai</label><pre class="src src-vhdl">entity exemple_tb is
end entity exemple_tb;

architecture test of exemple_tb is
  signal clock  : std_logic := '0';
  signal reset  : std_logic := '1';
  signal and_in : std_logic_vector(1 down 0) := (others =&gt; '0');
  alias in_a is and_in(0);
  alias in_b is and_in(1);
  signal out_q  : std_logic;
begin
  -- Reset et clock
  clock &lt;= not clock after 10 ns;
  reset &lt;= '1', '0' after 50 ns;
  -- Instanciation du modèle à tester 
  dut: entity work.exemple_design(rtl)
    port map (
      a =&gt; in_a,
      b =&gt; in_b,
      q =&gt; out_q );
  -- Génération du stimulus
  stimulus:
  process begin
    wait until (reset = '0');  -- Attendre reset relâché
    -- Générer chaque condition, avec 2 périodes entre chaque
    -- itération pour laisser du temps pour la propagation
    and_in &lt;= "00";
    wait for 2 ns;
    and_in &lt;= "01";
    wait for 2 ns;
    and_in &lt;= "10";
    wait for 2 ns;
    and_in &lt;= "11";
    -- Fin du test
    wait;
  end process stimulus;
end architecture exemple_tb;
</pre>
</div>

<p>
Le listing du deuxième exemple de banc d'essai, qui teste le
fonctionnement d'un compteur haut/bas de quatre bits modélisé de façon
comportementale, est présenté en trois portions. Une façon différente
de générer le signal d'horloge y est utilisée.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;46&nbsp;: </span>Deuxième exemple complet de banc d'essai, portion 1</label><pre class="src src-vhdl">library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;


entity up_down_counter is
  port( clock : in std_logic;
	reset : in std_logic;
	up_down : in std_logic;
	counter : out std_logic_vector(3 downto 0));
end up_down_counter;

architecture bhv of up_down_counter is
  signal t_count: unsigned(3 downto 0);
begin
  process (clock, reset)
  begin
    if (reset='1') then
      t_count &lt;= "0000";
    elsif rising_edge(clock) then
      if up_down = '0' then
	t_count &lt;= t_count + 1;
      else
	t_count &lt;= t_count - 1;
      end if;
    end if;
  end process;

  counter &lt;= std_logic_vector(t_count);
end bhv;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tb_up_down is
end tb_up_down;

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;47&nbsp;: </span>Deuxième exemple complet de banc d'essai, portion 2</label><pre class="src src-vhdl"><span class="linenr">39: </span>architecture behavior of tb_up_down is
<span class="linenr">40: </span>
<span class="linenr">41: </span>-- déclaration de composant pour le modèle à tester
<span class="linenr">42: </span>
<span class="linenr">43: </span>component up_down_counter
<span class="linenr">44: </span>port(
<span class="linenr">45: </span>clock : in std_logic;
<span class="linenr">46: </span>reset : in std_logic;
<span class="linenr">47: </span>up_down : in std_logic;
<span class="linenr">48: </span>counter : out std_logic_vector(3 downto 0)
<span class="linenr">49: </span>);
<span class="linenr">50: </span>end component up_down_counter;
<span class="linenr">51: </span>
<span class="linenr">52: </span>--Inputs
<span class="linenr">53: </span>signal clock : std_logic := '0';
<span class="linenr">54: </span>signal reset : std_logic := '0';
<span class="linenr">55: </span>signal up_down : std_logic := '0';
<span class="linenr">56: </span>
<span class="linenr">57: </span>--Outputs
<span class="linenr">58: </span>signal counter : std_logic_vector(3 downto 0);
<span class="linenr">59: </span>
<span class="linenr">60: </span>-- Clock period definitions
<span class="linenr">61: </span>constant clock_period : time := 20 ns;
<span class="linenr">62: </span>
<span class="linenr">63: </span>begin
<span class="linenr">64: </span>
<span class="linenr">65: </span>-- Instanciation du composant à tester
<span class="linenr">66: </span>uut: component up_down_counter
<span class="linenr">67: </span>  port map (
<span class="linenr">68: </span>    clock =&gt; clock,
<span class="linenr">69: </span>    reset =&gt; reset,
<span class="linenr">70: </span>    up_down =&gt; up_down,
<span class="linenr">71: </span>    counter =&gt; counter
<span class="linenr">72: </span>);
<span class="linenr">73: </span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;48&nbsp;: </span>Deuxième exemple complet de banc d'essai, portion 3</label><pre class="src src-vhdl"><span class="linenr">73: </span>
<span class="linenr">74: </span>-- Processus d'horloge
<span class="linenr">75: </span>clock_process: process
<span class="linenr">76: </span>begin
<span class="linenr">77: </span>clock &lt;= '0';
<span class="linenr">78: </span>wait for clock_period/2;
<span class="linenr">79: </span>clock &lt;= '1';
<span class="linenr">80: </span>wait for clock_period/2;
<span class="linenr">81: </span>end process;
<span class="linenr">82: </span>
<span class="linenr">83: </span>-- Processus de stimulus
<span class="linenr">84: </span>stim_proc: process
<span class="linenr">85: </span>begin
<span class="linenr">86: </span>-- hold reset state for 100 ns.
<span class="linenr">87: </span>wait for 20 ns;
<span class="linenr">88: </span>reset &lt;= '1';
<span class="linenr">89: </span>wait for 20 ns;
<span class="linenr">90: </span>reset &lt;= '0';
<span class="linenr">91: </span>up_down &lt;= '0';
<span class="linenr">92: </span>wait for 200 ns;
<span class="linenr">93: </span>up_down &lt;= '1';
<span class="linenr">94: </span>wait;
<span class="linenr">95: </span>end process;
<span class="linenr">96: </span>
<span class="linenr">97: </span>end;
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgd89ba08" class="outline-3">
<h3 id="orgd89ba08"><span class="section-number-3">13.23.</span> Compilation et simulation</h3>
<div class="outline-text-3" id="text-13-23">
<p>
Voici enfin les grandes étapes permettant de passer de la spécification d'un
modèle à une simulation du comportement du circuit modélisé. 
</p>

<ol class="org-ol">
<li>Créer un fichier vhdl. Ce fichier ne contient qu'une seule paire
entité.architecture de niveau supérieur, qui sera le banc
d'essai. Il y aura typiquement d'autres entités de niveau
inférieur, notamment le modèle de circuit à simuler.</li>
</ol>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Programme&nbsp;49&nbsp;: </span>Entité de niveau supérieur</label><pre class="src src-vhdl">entity MACHIN is
...
end MACHIN;

architecture TRUC of MACHIN is
...
end TRUC;
</pre>
</div>

<ol class="org-ol">
<li>Compiler cette description. Les commandes à utiliser dépendent du
simulateur qui est utilisé, mais deux étapes sont normalement
requises:
<ul class="org-ul">
<li>l'<b>analyse</b> du code source</li>
<li>l'<b>élaboration</b> du design</li>
</ul></li>

<li>Une fois le design élaboré, on peut <b>simuler</b> le résultat. Si le
simulateur ne permet pas directement la visualisation des
résultats, il faudra sauvegarder les résultats de simulation sous un
format qui permettra ensuite de les visualiser avec un autre outil.</li>

<li>Pour <b>visualiser</b> le résultat, on peut utiliser un outil intégré ou encore un
outil externe qui permet de visualiser les signaux obtenus (formes d'ondes,
résultats interprétés).</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org8eded96" class="outline-2">
<h2 id="org8eded96"><span class="section-number-2">14.</span> Préparation et simulation des modèles VHDL</h2>
<div class="outline-text-2" id="text-14">
</div>
<div id="outline-container-org117b1a7" class="outline-3">
<h3 id="org117b1a7"><span class="section-number-3">14.1.</span> Éditeurs</h3>
<div class="outline-text-3" id="text-14-1">
<p>
N'importe quel éditeur de programmation peut être utilisé pour éditer
les modèles VHDL. Certains simulateurs comportent un éditeur
intégré. Il peut être avantageux d'utiliser un éditeur avec fonction
de surlignage syntaxique pour le langage.
</p>
</div>
</div>

<div id="outline-container-org541c10d" class="outline-3">
<h3 id="org541c10d"><span class="section-number-3">14.2.</span> Simulateurs gratuits</h3>
<div class="outline-text-3" id="text-14-2">
<p>
Voici quelques simulateurs gratuits. 
</p>
</div>

<div id="outline-container-org139eb9a" class="outline-4">
<h4 id="org139eb9a"><span class="section-number-4">14.2.1.</span> Modelsim/Questa</h4>
<div class="outline-text-4" id="text-14-2-1">
<p>
Des versions de ce simulateur sont offertes par plusieurs
fabricants de circuit intégrés programmables:
</p>

<p>
Intel: 
</p>

<p>
<a href="https://www.intel.com/content/www/us/en/collections/products/fpga/software/downloads.html?s=Newest&amp;f=%255B%257B%2522name%2522%3A%2522quartusedition%2522%2C%2522facetId%2522%3A%2522quartusedition%2522%2C%2522currentValues%2522%3A%255B%255D%257D%2C%257B%2522name%2522%3A%2522quartusaddon%2522%2C%2522facetId%2522%3A%2522quartusaddon%2522%2C%2522currentValues%2522%3A%255B%257B%2522value%2522%3A%2522Intel%25C2%25AE%2520FPGA%2520Simulation%2520Tools%2522%2C%2522state%2522%3A%2522idle%2522%2C%2522children%2522%3A%255B%257B%2522value%2522%3A%2522Questa*-Intel%25C2%25AE%2520FPGA%2520Starter%2520Edition%2522%2C%2522state%2522%3A%2522selected%2522%257D%255D%257D%255D%257D%2C%257B%2522name%2522%3A%2522fpgadevicefamily%2522%2C%2522facetId%2522%3A%2522fpgadevicefamily%2522%2C%2522currentValues%2522%3A%255B%255D%257D%2C%257B%2522name%2522%3A%2522fpgaplatform%2522%2C%2522facetId%2522%3A%2522fpgaplatform%2522%2C%2522currentValues%2522%3A%255B%255D%257D%2C%257B%2522facetId%2522%3A%2522os-rdc%2522%2C%2522name%2522%3A%2522OperatingSystem%2522%2C%2522currentValues%2522%3A%255B%255D%257D%2C%257B%2522facetId%2522%3A%2522%40emtcontenttype_en%2522%2C%2522name%2522%3A%2522ContentType%2522%2C%2522currentValues%2522%3A%255B%255D%257D%2C%257B%2522facetId%2522%3A%2522lastupdated-rdc%2522%2C%2522name%2522%3A%2522lastupdated%2522%2C%2522currentValues%2522%3A%255B%255D%257D%255D&amp;q=lite">FPGA Software Download Center</a>
</p>


<ul class="org-ul">
<li>Fonctionne sous Windows ou Linux (Red Hat ou Ubuntu)</li>
<li>Un des simulateurs les plus populaires</li>
<li>L'utilisation requiert une license (gratuite) spécifique à un
ordinateur donné, qu'il faut demander par courriel</li>
<li>L'installation et l'activation comportent plusieurs étapes</li>
</ul>


<p>
Lattice:
</p>

<p>
<a href="http://www.latticesemi.com/icecube2">iCEcube2 Design Software</a>
</p>

<ul class="org-ul">
<li>Fonctionne sous Windows ou Linux (Red Hat)</li>
<li>Fait partie d'un suite logicielle en support à la gamme de FPGA du
fabricant</li>
<li>L'utilisation requiert une license (gratuite) spécifique à un
ordinateur donné</li>
</ul>

<p>
Microchip:
</p>

<p>
<a href="https://www.microchip.com/en-us/products/fpgas-and-plds/fpga-and-soc-design-tools/fpga/libero-software-later-versions#downloads">Libero SoC Design Suite</a>
</p>

<ul class="org-ul">
<li>Fonctionne sous Windows ou Linux (Red Hat)</li>
<li>Fait partie d'un suite logicielle (Libero) en support à la gamme de
FPGA du fabricant</li>
<li>L'utilisation requiert une license (gratuite) spécifique à un
ordinateur donné</li>
</ul>
</div>
</div>

<div id="outline-container-org7c40ed0" class="outline-4">
<h4 id="org7c40ed0"><span class="section-number-4">14.2.2.</span> Active-HDL (version étudiant)</h4>
<div class="outline-text-4" id="text-14-2-2">
<p>
<a href="https://www.aldec.com/en/products/fpga_simulation/active_hdl_student">Free Active-HDL Student Edition</a>
</p>

<ul class="org-ul">
<li>Fonctionne sous Windows</li>
<li>License gratuite pour étudiants (on doit indiquer son université)</li>
<li>L'inscription donne accès à une page de téléchargement</li>
</ul>
</div>
</div>

<div id="outline-container-org1b6b330" class="outline-4">
<h4 id="org1b6b330"><span class="section-number-4">14.2.3.</span> Vivado (Xilinx)</h4>
<div class="outline-text-4" id="text-14-2-3">
<p>
<a href="https://www.xilinx.com/support/download.html">Xilinx téléchargements</a>
</p>

<ul class="org-ul">
<li>Fonctionne sous Windows ou Linux (Red Hat ou Ubuntu)</li>
<li>Cette suite pour conception de circuits intégrés programmables
comporte un simulateur</li>
<li>L'utilisation requiert une license (gratuite) spécifique à un
ordinateur donné</li>
</ul>
</div>
</div>

<div id="outline-container-org412f991" class="outline-4">
<h4 id="org412f991"><span class="section-number-4">14.2.4.</span> GHDL/GTKWave</h4>
<div class="outline-text-4" id="text-14-2-4">
<p>
<a href="http://ghdl.free.fr/">http://ghdl.free.fr/</a>
</p>

<p>
<a href="https://github.com/ghdl/ghdl">https://github.com/ghdl/ghdl</a>
</p>

<p>
<a href="http://gtkwave.sourceforge.net/">http://gtkwave.sourceforge.net/</a>
</p>

<p>
<a href="https://github.com/gtkwave/gtkwave">https://github.com/gtkwave/gtkwave</a>
</p>

<p>
Ces deux logiciels sont à code source ouvert, donc entièrement
gratuits.
</p>

<ul class="org-ul">
<li>Fonctionnent sous Windows, Mac ou Linux</li>
<li>GHDL est utilisé pour la simulation</li>
<li>GTKWave est utilisé pour visualiser les résultats</li>
</ul>
</div>
</div>

<div id="outline-container-org5b49234" class="outline-4">
<h4 id="org5b49234"><span class="section-number-4">14.2.5.</span> EDA Playground</h4>
<div class="outline-text-4" id="text-14-2-5">
<p>
<a href="https://www.edaplayground.com/">EDA Playground</a>
</p>

<ul class="org-ul">
<li>Cette option, utilisable via un fureteur Web, ne nécessite pas
d'installation, et peu donc s'utiliser sous toutes les plateformes</li>
<li>On doit s'enregistrer</li>
<li>Il est possible de choisir le simulateur</li>
<li>On y trouve également des exemples de code</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf2083e4" class="outline-2">
<h2 id="orgf2083e4"><span class="section-number-2">15.</span> Exercices</h2>
<div class="outline-text-2" id="text-15">
</div>
<div id="outline-container-orgce4d4ec" class="outline-3">
<h3 id="orgce4d4ec">Série 1</h3>
<div class="outline-text-3" id="text-orgce4d4ec">
</div>

<div id="outline-container-org385bbf9" class="outline-4">
<h4 id="org385bbf9">Question</h4>
<div class="outline-text-4" id="text-org385bbf9">
<p>
Effectuez la conversion des nombres suivants dans la base demandée:
</p>

<ol class="org-ol">
<li>\((32)_{10} = ( )_{2}\)</li>

<li>\((F8,A7)_{16} = ( )_{2}\)</li>

<li>\((65)_{8} = ( )_{16}\)</li>

<li>\((240,51)_{8} = ( )_{10}\)</li>

<li>\((25)_{10} = ( )_{8}\)</li>

<li>\((100101011)_{2} = ( )_{10}\)</li>

<li>\((28)_{10} = ( )_{2}\)</li>

<li>\((E3)_{16} = ( )_{2}\)</li>

<li>\((B3)_{16} = ( )_{8}\)</li>

<li>\((11001011101)_{2} = ( )_{16}\)</li>

<li>\((754)_{8} = ( )_{10}\)</li>

<li>\((106)_{8} = ( )_{16}\)</li>

<li>\((27,52)_{10} = ( )_{2}\)</li>

<li>\((4F,3D9)_{16} = ( )_{2}\)</li>

<li>\((73,313)_{8} = ( )_{16}\)</li>

<li>\((364,3)_{8} = ( )_{10}\)</li>

<li>\((111101011)_{2} = ( )_{10}\)</li>

<li>\((31,22)_{10} = ( )_{2}\)</li>

<li>\((43,39)_{16} = ( )_{2}\)</li>

<li>\((43,37)_{8} = ( )_{8}\)</li>

<li>\((36)_{8} = ( )_{10}\)</li>

<li>\((101101111)_{2} = ( )_{10}\)</li>
</ol>
</div>
</div>
<div id="outline-container-org955c90e" class="outline-4">
<h4 id="org955c90e">Question</h4>
<div class="outline-text-4" id="text-org955c90e">
<p>
Donnez le nombre minimum de bits nécessaires pour définir un code
   pour représenter:
</p>

<ol class="org-ol">
<li>les chiffres de 0 à 9</li>

<li>les nombres de -17 à 17</li>

<li>les lettres A &hellip; Z et les chiffres 0 &hellip; 9</li>

<li>alphanumérique pour les lettres A &hellip; Z, a &hellip; z et les
chiffres 0 &hellip; 9</li>
</ol>
</div>
</div>



<div id="outline-container-orgf67a70a" class="outline-4">
<h4 id="orgf67a70a">Question</h4>
<div class="outline-text-4" id="text-orgf67a70a">
<p>
Calculez les compléments suivants (pour un nombre de bits \(n\)):
</p>

<ol class="org-ol">
<li>complément à deux de \((1101011)_2\) en supposant \(n=8\)</li>

<li>complément à deux de \((110101)_2\) en supposant \(n=8\)</li>

<li>complément à un de \((0101101)_2\) en supposant \(n=8\)</li>

<li>complément à deux de \((01112)_3\) en supposant \(n=7\)</li>

<li>complément à cinq de \((32402)_5\) en supposant \(n=7\)</li>

<li>compl. à 2 de \((10110001)_2\)</li>

<li>compl. à 2 de \((0001101)_2\)</li>

<li>compl. à 1 de \((0101101)_2\)</li>

<li>compl. à 2 de \((02112)_3\)</li>

<li>compl. à 5 de \((42102)_5\)</li>
</ol>
</div>
</div>

<div id="outline-container-org9e8daff" class="outline-4">
<h4 id="org9e8daff">Question</h4>
<div class="outline-text-4" id="text-org9e8daff">
<p>
Effectuez les calculs suivants selon la méthode indiquée:
</p>

<ol class="org-ol">
<li>\((2CF3)_{16} + (2B)_{16}\), (add. directe base 16). Réponse: \(( )_{16}\)</li>

<li>\((704)_{8} + (230)_{8}\), add. directe base 8, conversion). Réponse: \(( )_{8} = ( )_{10}\)</li>

<li>\((34)_{8} - (42)_{8}\), complément à 2, conversion. Réponse: \(( )_{2} = ( )_{16}\)</li>

<li>\((11011101)_{2} - (55)_{10}\), complément à 2, conversion. Réponse: \(( )_{2}\)</li>

<li>\((AC)_{16} + (4)_{16}\) par addition directe en base 16. Réponse: \(( )_{16}\)</li>

<li>\((E1)_{16} - (1B)_{16}\) en utilisant le complément à 1 en base 2. Réponse: \(( )_{16}\)</li>

<li>\((46)_{8} - (73)_{8}\) en utilisant le complément à 2 en base 2. Réponse: \(( )_{16}\)</li>

<li>\((BE)_{16} + (22)_{16}\), (add. directe base 16). Réponse: \(( )_{16}\)</li>

<li>\((73)_{8} + (103)_{8}\), add. directe base 8, conversion). Réponse: \(( )_{8} = ( )_{10}\)</li>

<li>\((22)_{8} - (26)_{8}\), compl. à 2, conversion. Réponse: \(( )_{2} = ( )_{16}\)</li>

<li>\((11011100)_{2} - (57)_{10}\), compl. à 2, conversion. Réponse: \(( )_{2}\)</li>

<li>\((AE)_{16} + (12)_{16}\), (add. directe base 16). Réponse: \(( )_{16}\)</li>

<li>\((63)_{8} + (135)_{8}\), add. directe base 8, conversion). Réponse: \(( )_{8} = ( )_{10}\)</li>

<li>\((35)_{8} - (26)_{8}\), compl. à 2, conversion. Réponse: \(( )_{2} = ( )_{16}\)</li>

<li>\((11011100)_{2} - (55)_{10}\), compl. à 2, conversion. Réponse: \(( )_{2}\)</li>
</ol>
</div>
</div>

<div id="outline-container-orga087b72" class="outline-4">
<h4 id="orga087b72">Question</h4>
<div class="outline-text-4" id="text-orga087b72">
<p>
Vous disposez de blocs permettant de calculer les fonctions
   suivantes:
</p>

<dl class="org-dl">
<dt>C4</dt><dd>complément à un d'un nombre de 4 bits</dd>

<dt>ADD4</dt><dd>addition de deux nombres de 4 bits, avec entrée pour retenue et
retenue de sortie.</dd>
</dl>

<p>
Indiquez par un schéma-bloc comment on peut relier ces blocs pour
calculer:
</p>

<ol class="org-ol">
<li>le complément à deux d'un nombre de 4 bits</li>

<li>le complément à deux d'un nombre de 8 bits</li>

<li>la somme de deux nombres de 8 bits</li>

<li>la soustraction de nombres de 4 bits</li>
</ol>
</div>
</div>

<div id="outline-container-orgf4c9e28" class="outline-4">
<h4 id="orgf4c9e28">Question</h4>
<div class="outline-text-4" id="text-orgf4c9e28">
<p>
Un réseau informatique comporte 60 ordinateurs. On doit assigner à
   chacun de ces ordinateurs un mot-code binaire unique.
</p>

<ol class="org-ol">
<li>Combien de bits par mot sont nécessaire pour la codification?</li>

<li>Combien de mots-code ne seront pas utilisés?</li>
</ol>
</div>
</div>

<div id="outline-container-org13934be" class="outline-4">
<h4 id="org13934be">Question</h4>
<div class="outline-text-4" id="text-org13934be">
<p>
Selon les critères d'achat du service des achats d'une entreprise, un
  article sera acheté s'il remplit au moins une des conditions
  suivantes:
</p>

<ul class="org-ul">
<li>il est peu coûteux ou de qualité, tout en étant disponible
rapidement,</li>

<li>il est peu coûteux et n'est pas disponible rapidement,</li>

<li>il est coûteux et de mauvaise qualité, tout en étant disponible
rapidement.</li>
</ul>

<p>
En utilisant la notation suivante:
</p>

<dl class="org-dl">
<dt>A</dt><dd>coûteux</dd>

<dt>B</dt><dd>de bonne qualité</dd>

<dt>C</dt><dd>disponible rapidement</dd>

<dt>(no term)</dt><dd>Exprimez les critères d'achat sous forme d'une expression
booléenne (non-simplifiée).</dd>

<dt>(no term)</dt><dd>Donnez le tableau de vérité de la fonction logique des critères
d'achat.</dd>

<dt>(no term)</dt><dd>Donnez la forme canonique, en somme de produit, de la fonction
logique des critères d'achat.</dd>

<dt>(no term)</dt><dd><p>
Déterminez si les expressions logiques suivantes sont égales à la
fonction logique des critères d'achat:
</p>

<p>
\[F_1 = A^{\prime} B^{\prime} + B^{\prime} C^{\prime}\]
</p>

<p>
\[F_2 = A^{\prime} B^{\prime} C^{\prime} + A^{\prime} B^{\prime} C + A^{\prime} B C^{\prime} + A B^{\prime} C^{\prime}\]
</p>

<p>
\[F_2 = B^{\prime} C^{\prime} + A^{\prime} B^{\prime} + A^{\prime} C\]
</p></dd>
</dl>
</div>
</div>

<div id="outline-container-org5808508" class="outline-4">
<h4 id="org5808508">Question</h4>
<div class="outline-text-4" id="text-org5808508">
<p>
Donnez le nombre minimum de bits nécessaires pour définir un code pour représenter
</p>

<ol class="org-ol">
<li>les jours de la semaine</li>

<li>les jours du mois</li>

<li>les jours dans l'année (nombre entre 1 et 365)</li>

<li>les jours de l'année (mois et date)</li>

<li>une date de naissance (jour, mois, année)</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org81fe5ea" class="outline-3">
<h3 id="org81fe5ea">Série 2</h3>
<div class="outline-text-3" id="text-org81fe5ea">
</div>

<div id="outline-container-org546acef" class="outline-4">
<h4 id="org546acef">Question</h4>
<div class="outline-text-4" id="text-org546acef">
<p>
La fonction logique à trois entrées \(S = F(A,B,C)\) donnée par son 
   tableau de vérité:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(A\)</th>
<th scope="col" class="org-right">\(B\)</th>
<th scope="col" class="org-right">\(C\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(S\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
doit être implémentée par un circuit logique.
</p>

<ol class="org-ol">
<li>Donnez l'expression de cette fonction:

<ul class="org-ul">
<li>Selon la première forme canonique ( \(\sum m_i\) )</li>

<li>Selon la deuxième forme canonique ( \(\prod M_i\) )</li>
</ul></li>

<li>Trouvez une expression simplifiée pour la fonction en utilisant
les théorèmes de l'algèbre de Boole.</li>

<li>Dessinez le circuit logique correspondant à l'expression
simplifiée trouvée.</li>
</ol>
</div>
</div>

<div id="outline-container-org08db61c" class="outline-4">
<h4 id="org08db61c">Question</h4>
<div class="outline-text-4" id="text-org08db61c">
<p>
Trouvez le complément de la fonction logique donnée par l'expression
   suivante en utilisant trois méthodes différentes.
   \[
    s = b (a^{\prime} c^{\prime} + a d + a c) + (b + c^{\prime}+
      d)^{\prime} + a^{\prime} b c^{\prime} d + a b c d
    \]
</p>
</div>
</div>

<div id="outline-container-orgcc8986d" class="outline-4">
<h4 id="orgcc8986d">Question</h4>
<div class="outline-text-4" id="text-orgcc8986d">
<p>
Considérez la fonction logique définie par l'expression \(F =
      [ (C + B) A^{\prime} + (A+B)^{\prime} ] B^{\prime}\).
</p>

<ol class="org-ol">
<li>Dessinez le circuit logique correspondant.</li>

<li>Dessinez un circuit équivalent qui n'utilise que des portes
NAND.</li>

<li>Dessinez un circuit équivalent qui n'utilise que des portes
NOR.</li>
</ol>
</div>
</div>

<div id="outline-container-orga3fd2a8" class="outline-4">
<h4 id="orga3fd2a8">Question</h4>
<div class="outline-text-4" id="text-orga3fd2a8">
<p>
On doit concevoir un circuit logique qui détermine le complément à deux
  d'une entrée \(a\) binaire (signée) de 4 bits notés
  \(a_3, a_2, a_1, a_0\). Il y aura donc 4 bits de sortie, \(s_3,
      s_2, s_1, s_0\). En considérant chacun des bits de sortie comme une
  fonction des quatre bits d'entrée, par ex. \(s_3 = f(a_3, a_2, a_1,
      a_0)\), donnez les tableaux de vérité pour \(s_3, s_2, s_1\), et \(s_0\).
</p>
</div>
</div>

<div id="outline-container-org3e0d081" class="outline-4">
<h4 id="org3e0d081">Question</h4>
<div class="outline-text-4" id="text-org3e0d081">
<p>
Complétez la figure ci-dessous (en ajoutant des connexions) afin de
  réaliser la fonction 
  \[
    S= a^\prime + b^\prime + c d
    \]
  <img src="Modeles_exercices/exbloc2a.svg" alt="exbloc2a.svg" class="org-svg" />
</p>
</div>
</div>

<div id="outline-container-orgfd609a3" class="outline-4">
<h4 id="orgfd609a3">Question</h4>
<div class="outline-text-4" id="text-orgfd609a3">
<p>
Complétez la figure ci-dessous (en ajoutant des connexions) afin de
  réaliser une fonction dont la sortie est 
</p>
<ul class="org-ul">
<li>\(S=1\) lorsque l'entrée est \( \leq 3\) ou impaire</li>
<li>\(S=0\) dans les autres cas.</li>
</ul>
<p>
    L'entrée \((a_3,a_2,a_1, a_0)\) représente un nombre entier
   décimal codé en BCD. Les entrées \( \geq 9\) peuvent donner
   n'importe quelle sortie.
<img src="Modeles_exercices/exbloc2b.svg" alt="exbloc2b.svg" class="org-svg" />
</p>
</div>
</div>

<div id="outline-container-org2711251" class="outline-4">
<h4 id="org2711251">Question</h4>
<div class="outline-text-4" id="text-org2711251">
<p>
Dessinez le circuit logique de la fonction \(S = a b + c^\prime +
    d^\prime \) en utilisant au plus quatre portes NAND.
</p>
</div>
</div>

<div id="outline-container-orgad7825d" class="outline-4">
<h4 id="orgad7825d">Question</h4>
<div class="outline-text-4" id="text-orgad7825d">
<p>
Simplifiez la fonction logique donnée par l'expression suivante:
  \[
    s = b (a^{\prime} c^{\prime} + a d + a c) + (b + c^{\prime}+
      d)^{\prime} + a^{\prime} b c^{\prime} d + a b c d
    \] 
  au moyen d'un
  diagramme de Karnaugh. Identifiez sur le diagramme les regroupements
  essentiels, les regroupements absoluments inutiles et les
  regroupements pour lesquels on a le choix. Donnez deux solutions
  aussi simplifiées.
</p>
</div>
</div>

<div id="outline-container-org5a43c55" class="outline-4">
<h4 id="org5a43c55">Question</h4>
<div class="outline-text-4" id="text-org5a43c55">
<p>
Considérez la fonction logique définie par l'expression 
  \[
    F = [ (A + B) C^{\prime} + (A+B)^{\prime} ] B^{\prime}
    \]
</p>

<ol class="org-ol">
<li>Dessinez le circuit logique correspondant.</li>

<li>Dessinez un circuit équivalent qui n'utilise que des portes
NAND.</li>

<li>Dessinez un circuit équivalent qui n'utilise que des portes
NOR.</li>

<li>Dessinez un circuit équivalent qui ne comporte que trois niveaux de
portes (incluant les inversions).</li>
</ol>
</div>
</div>

<div id="outline-container-orgebbec8f" class="outline-4">
<h4 id="orgebbec8f">Question</h4>
<div class="outline-text-4" id="text-orgebbec8f">
<p>
Simplifiez la fonction logique donnée par l'expression suivante:
  \[
    s = a b ( c^{\prime} d^{\prime} + c d) + c^{\prime}(a^{\prime}
      b^{\prime} + a^{\prime} b)
    \]
   au moyen d'un diagramme de Karnaugh. Donnez deux solutions aussi simplifiées.
</p>
</div>
</div>

<div id="outline-container-orgd6ee908" class="outline-4">
<h4 id="orgd6ee908">Question</h4>
<div class="outline-text-4" id="text-orgd6ee908">
<p>
Considérez la fonction logique définie par l'expression \(F = (AB + C)
      A^{\prime} + C + A^{\prime}\).
</p>

<ol class="org-ol">
<li>Dessinez le circuit logique correspondant.</li>

<li>Dessinez un circuit équivalent qui n'utilise que des portes
NAND.</li>

<li>Dessinez un circuit équivalent qui n'utilise que des portes
NOR.</li>

<li>Dessinez un circuit équivalent qui ne comporte que deux niveaux de
portes (excluant les inversions).</li>
</ol>
</div>
</div>

<div id="outline-container-orga35c65b" class="outline-4">
<h4 id="orga35c65b">Question</h4>
<div class="outline-text-4" id="text-orga35c65b">
<p>
Donnez le tableau  de vérité des deux fonctions qui, à partir d'une
  entrée binaire non-signée sur trois bits, donnent en sortie la
  représentation binaire non-signée sur deux bits du plus grand diviseur
  \(< 3\) de l'entrée, s'il y a lieu. Simplifiez les deux fonctions en
  tenant compte des cas facultatifs.
</p>
</div>
</div>

<div id="outline-container-org8df45c4" class="outline-4">
<h4 id="org8df45c4">Question</h4>
<div class="outline-text-4" id="text-org8df45c4">
<p>
Complétez la figure ci-dessous (en ajoutant des connexions) afin de
  réaliser une  fonction NAND à trois entrées \(S = (a b c)^\prime\).
  <img src="Modeles_exercices/exbloc2c.svg" alt="exbloc2c.svg" class="org-svg" />
</p>
</div>
</div>

<div id="outline-container-orge98e8d8" class="outline-4">
<h4 id="orge98e8d8">Question</h4>
<div class="outline-text-4" id="text-orge98e8d8">
<p>
Dans une application numérique, on doit concevoir un circuit logique
qui permet de détecter les nombre composés, qui peuvent être
décomposés en facteurs (nombres qui ne sont pas premiers. Le circuit
doit donner une sortie 1 quand un nombre composé est présenté à
l'entrée; par exemple, le circuit doit donner 1 pour une entrée 4
(0100) et 0 pour une entrée 3 (0011). Les nombres 0 et 1 seront
considérés comme des cas facultatifs.
</p>

<ol class="org-ol">
<li>Donnez le tableau de vérité pour réaliser cette application pour
un mot d'entrée (non-signé) de quatre bits, \(a, b, c\) et \(d\).</li>

<li>Au moyen d'un diagramme de Karnaugh, trouvez une expression
logique simplifiée pour cette fonction logique et ne représentez
que les impliquants premiers retenus pour la solution.</li>

<li>Donnez le schéma du circuit logique qui implémente cette fonction
en somme de produit à l'aide de portes NON-ET (pas de restrictions
sur le nombre d'entrées).</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org6212b56" class="outline-3">
<h3 id="org6212b56">Série 3</h3>
<div class="outline-text-3" id="text-org6212b56">
</div>

<div id="outline-container-orge653869" class="outline-4">
<h4 id="orge653869">Question</h4>
<div class="outline-text-4" id="text-orge653869">
<p>
À l'aide d'un diagramme de Karnaugh, simplifiez 
  \[
    S = A B^\prime +
    B^\prime CD + A^\prime B + B^\prime D + A^\prime B^\prime D
    \]
  en produit de sommes.
</p>
</div>
</div>

<div id="outline-container-orga2ff1e9" class="outline-4">
<h4 id="orga2ff1e9">Question</h4>
<div class="outline-text-4" id="text-orga2ff1e9">
<p>
À l'aide d'un diagramme de Karnaugh, simplifiez 
  \[
    S = ( A^\prime +
    B^\prime + C + D)(A+B^\prime +C^\prime +D)(A^\prime +B^\prime
    +C+D^\prime )(A+B^\prime +C^\prime +D^\prime )(A+C^\prime +D)
    \]
  en tenant compte des cas facultatifs suivants: \(\sum(3,8,11,14)\).
</p>
<ol class="org-ol">
<li>Donnez une solution qui n'utilise pas l'entrée \(D\).</li>
<li>Donnez une solution qui n'utilise pas l'entrée \(B\).</li>
</ol>
</div>
</div>

<div id="outline-container-orgd2a62c2" class="outline-4">
<h4 id="orgd2a62c2">Question</h4>
<div class="outline-text-4" id="text-orgd2a62c2">
<p>
À l'aide de la méthode Quine-McCluskey, simplifiez l'expression
  logique suivante: 
  \[
    F= A^\prime BCDEF^\prime  + A^\prime BCDEF+ AB^\prime CDEF+ ABCDEF^\prime 
    \]
  Tenez compte des cas facultatifs suivants: 
  \[
    A^\prime BCD^\prime EF^\prime +
    ABCDE^\prime F^\prime + A^\prime BCDE^\prime F+ ABCDEF
    \]
</p>
</div>
</div>

<div id="outline-container-orgb6607f7" class="outline-4">
<h4 id="orgb6607f7">Question</h4>
<div class="outline-text-4" id="text-orgb6607f7">
<p>
Considérez la fonction logique \(F\) définie par le tableau de vérité suivant
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(A\)</th>
<th scope="col" class="org-right">\(B\)</th>
<th scope="col" class="org-right">\(C\)</th>
<th scope="col" class="org-right">\(D\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(F\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
<p>
Vous devez réaliser cette fonction au moyen d'un multiplexeur à huit
entrées sans utiliser la variable \(A\) dans les lignes de
sélection. Complétez le tableau de réalisation et la figure
ci-dessous.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">\(E_0\)</th>
<th scope="col" class="org-left">\(E_1\)</th>
<th scope="col" class="org-left">\(E_2\)</th>
<th scope="col" class="org-left">\(E_3\)</th>
<th scope="col" class="org-left">\(E_4\)</th>
<th scope="col" class="org-left">\(E_5\)</th>
<th scope="col" class="org-left">\(E_6\)</th>
<th scope="col" class="org-left">\(E_7\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\(A\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">\(A^\prime\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<div id="org7a172a7" class="figure">
<p><img src="Modeles_exercices/exbloc3b.svg" alt="exbloc3b.svg" class="org-svg" />
</p>
</div>
</div>
</div>

<div id="outline-container-org80d5aca" class="outline-4">
<h4 id="org80d5aca">Question</h4>
<div class="outline-text-4" id="text-org80d5aca">
<p>
Simplifiez la fonction logique à six entrées
  \[
    S = F(A,B,C,D,E,F)
    \]
  représentée par la liste de minterms suivants
</p>

<p>
010000, 101000, 110100, 110101, 110110, 111100
</p>

<p>
en tenant compte des cas facultatifs représentés par les minterms
suivants
</p>

<p>
000000, 001100, 000111, 101001, 110111
</p>

<p>
par la méthode de Quine-McCluskey. Vous devez donner le détail de
toutes les étapes, remplir les tableaux de couverture initial et
réduit, identifier les impliquants premiers essentiels (i.p.e.), les
impliquants premiers absolument inessentiels (i.p.a.i.) et les
impliquants premiers inessentiels tout court (i.p.i.). Donnez la
solution sous la forme d'une expression en \(A,B,C,D,E,F\).
</p>
</div>
</div>

<div id="outline-container-org0c46d51" class="outline-4">
<h4 id="org0c46d51">Question</h4>
<div class="outline-text-4" id="text-org0c46d51">
<p>
Réalisez les fonctions logiques suivantes au moyen d'un multiplexeur
  4- vers-1.
</p>

<ol class="org-ol">
<li>\[f_1(a,b,c) = \sum m(2, 4, 5, 7)\]</li>

<li>\[f_2(a,b,c) = \prod M(0, 6, 7)\]</li>
</ol>
</div>
</div>

<div id="outline-container-org6f1ae0b" class="outline-4">
<h4 id="org6f1ae0b">Question</h4>
<div class="outline-text-4" id="text-org6f1ae0b">
<p>
Identifiez la fonction réalisée par le circuit ci-dessous, en donnant
  la liste des minterms en fonction des entrées \(a, b, c\) et \(d\).
<img src="Modeles_exercices/exbloc3c.svg" alt="exbloc3c.svg" class="org-svg" />
</p>
</div>
</div>

<div id="outline-container-org59537a2" class="outline-4">
<h4 id="org59537a2">Question</h4>
<div class="outline-text-4" id="text-org59537a2">
<p>
Un circuit combinatoire est défini par les trois fonctions logiques
  suivantes. Dessinez un circuit réalisant ces trois fonctions en
  utilisant un décodeur constitué de portes NAND (vous devez dessiner
  le schéma du décodeur), et des portes NAND et ET
  externes.
  \[
     F_1  = x y^{\prime} + x^{\prime}y
    z^{\prime} 
    \]
  \[
    F_2  =  (x + y^{\prime})z 
    \]
  \[ F_3  =  (x^{\prime}
    y + x y^{\prime} z)^{\prime}
    \]
</p>
</div>
</div>

<div id="outline-container-org57d88de" class="outline-4">
<h4 id="org57d88de">Question</h4>
<div class="outline-text-4" id="text-org57d88de">
<p>
Simplifiez la fonction donnée par l'expression suivante
  \[
    a^{\prime} b^{\prime} c d + a b c d + a b^{\prime} c^{\prime} d +
	a b c d^{\prime}
    \]
  en considérant les cas facultatifs suivants
  \[
    a b c^{\prime} + a^{\prime} b c^{\prime} d^{\prime} + a b^{\prime}
	c d^{\prime}
    \]
  par la méthode de Quine-McCluskey. Vous devez
  donner le détail de toutes les étapes, identifier à la fin les
  impliquants premiers essentiels (i.p.e.), les impliquants premiers
  absolument inessentiels (i.p.a.i.) et les impliquants premiers
  inessentiels tout court (i.p.i.). et donner la solution finale avec
  les variables.
</p>
</div>
</div>

<div id="outline-container-org0504cf6" class="outline-4">
<h4 id="org0504cf6">Question</h4>
<div class="outline-text-4" id="text-org0504cf6">
<p>
Concevez un circuit qui permet de comparer deux mots de 3 bits et qui
  donne 1 lorsqu'ils sont égaux et 0 sinon. Vous devez utiliser des
  portes XOR et d'autres portes.
</p>
</div>
</div>

<div id="outline-container-orgc2b52ce" class="outline-4">
<h4 id="orgc2b52ce">Question</h4>
<div class="outline-text-4" id="text-orgc2b52ce">
<p>
La fonction logique à quatre entrées \(S = F(A,B,C, D)\) donnée par son 
  tableau de vérité:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">\(A\)</th>
<th scope="col" class="org-right">\(B\)</th>
<th scope="col" class="org-right">\(C\)</th>
<th scope="col" class="org-right">\(D\)</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">\(S\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">X</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">X</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">X</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
<p>
doit être implémentée par un circuit logique.
</p>

<ol class="org-ol">
<li>Simplifiez la description de cette fonction en utilisant un diagramme de Karnaugh.</li>

<li>Trouvez le tableau de couverture pour la fonction et réduisez-le en tableau réduit.</li>

<li>Identifiez les impliquants premiers essentiels (i.p.e.), les
impliquants premiers absolument inessentiels (i.p.a.i.) et les
impliquants premiers inessentiels tout court (i.p.i.).</li>

<li>Dessinez le circuit logique simplifié, réalisé en n'utilisant que des portes NAND.</li>
</ol>
</div>
</div>

<div id="outline-container-orgecb73bd" class="outline-4">
<h4 id="orgecb73bd">Question</h4>
<div class="outline-text-4" id="text-orgecb73bd">
<p>
Un circuit combinatoire est défini par les trois fonctions logiques
  suivantes. Dessinez un circuit réalisant ces trois fonctions en
  utilisant un décodeur et des portes externes.
  \[
    F_1  = x^{\prime} y^{\prime} z^{\prime} + xz 
    \]
  \[
    F_2  = x y z^{\prime} + x^{\prime} y 
    \]
  \[
    F_3  = x^{\prime} y^{\prime} z + x y
    \]
</p>
</div>
</div>

<div id="outline-container-orgc7074f2" class="outline-4">
<h4 id="orgc7074f2">Question</h4>
<div class="outline-text-4" id="text-orgc7074f2">
<p>
 Identifiez la fonction logique \(F(A,B,C,D)\) définie par le circuit
   logique suivant:
<img src="Modeles_exercices/exbloc3d.svg" alt="exbloc3d.svg" class="org-svg" />
</p>
<ol class="org-ol">
<li>Donnez son tableau de vérité.</li>

<li>Donnez la forme canonique somme de produits de cette fonction.</li>
</ol>
</div>
</div>

<div id="outline-container-org2464b4d" class="outline-4">
<h4 id="org2464b4d">Question</h4>
<div class="outline-text-4" id="text-org2464b4d">
<p>
Considérez le tableau de couverture suivant:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">0101</th>
<th scope="col" class="org-right">0110</th>
<th scope="col" class="org-right">0000</th>
<th scope="col" class="org-right">1100</th>
<th scope="col" class="org-right">1101</th>
<th scope="col" class="org-right">1011</th>
<th scope="col" class="org-right">0111</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">-10-</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">110-</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">1011</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">-00-</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">01--</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">-111</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table>

<ol class="org-ol">
<li>Complétez le tableau en mettant les '+' dans les cases
appropriées.</li>

<li>Identifiez les i.p.e. et les i.p.a.i.</li>

<li>Donnez les cas facultatifs qui ont été utilisés pour obtenir les
i.p.</li>

<li>Donnez le tableau réduit correspondant.</li>

<li>Donnez un exemple de ligne qui en domine une autre.</li>

<li>Donnez un exemple de colonne qui en domine une autre.</li>

<li>Donnez une forme canonique de la fonction.</li>

<li>Donnez l'expression simplifiée de la fonction \(F(u,v,w,x)\).</li>
</ol>
</div>
</div>

<div id="outline-container-org9486c92" class="outline-4">
<h4 id="org9486c92">Question</h4>
<div class="outline-text-4" id="text-org9486c92">
<p>
Trouvez l'expression minimale pour les deux fonctions suivantes,
   sachant qu'elles doivent être implémentées dans un même
   circuit. Utilisez la méthode Quine-McCluskey.
   \[
     F_1(A, B, C, D)
     =\sum(2,5,6,7,10,11,14,15)
     \]
   \[
     F_2 = A B C D + A^\prime B C D +
     A^\prime B^\prime C D + A B^\prime C + ABC
     \]
</p>
</div>
</div>

<div id="outline-container-orgc55ce1e" class="outline-4">
<h4 id="orgc55ce1e">Question</h4>
<div class="outline-text-4" id="text-orgc55ce1e">
<p>
La fonction logique à trois entrées \(S = F(A,B,C)\) représentée par le
  tableau de vérité:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">A</th>
<th scope="col" class="org-right">B</th>
<th scope="col" class="org-right">C</th>
<th scope="col" class="org-right">S</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
doit être implémentée par un circuit logique.
</p>

<ol class="org-ol">
<li>Donnez l'expression de cette fonction:

<ul class="org-ul">
<li>Selon la première forme canonique ( \(\sum m_i\) )</li>

<li>Selon la deuxième forme canonique ( \(\prod M_i\) )</li>
</ul></li>

<li>Trouvez une expression simplifié pour cette fonction en utilisant
un diagramme de Karnaugh en format horizontal.</li>

<li>Donnez l'expression du <b>complément</b> de cette fonction:

<ul class="org-ul">
<li>Selon la première forme canonique ( \(\sum m_i\) )</li>

<li>En complémentant votre expression simplifiée au moyen du
théorême de DeMorgan.</li>
</ul></li>

<li>Dessinez le circuit logique à partir de l'expression simplifiée
trouvée.</li>
</ol>
</div>
</div>

<div id="outline-container-orge8c8782" class="outline-4">
<h4 id="orge8c8782">Question</h4>
<div class="outline-text-4" id="text-orge8c8782">
<p>
Simplifiez la fonction logique donnée par la forme canonique
  suivante:
  \[
    m_0 + m_2 + m_4 + m_5 + m_8 + m_A + m_B + m_E
    \]
  au
  moyen d'un diagramme de Karnaugh (la numérotation des termes est en
  hexadécimal). Identifiez sur le diagramme les regroupements
  essentiels, les regroupements absoluments inutiles et les
  regroupements pour lesquels on a le choix. Donnez deux solutions
  aussi simplifiées.
</p>
</div>
</div>

<div id="outline-container-orgbc489ac" class="outline-4">
<h4 id="orgbc489ac">Question</h4>
<div class="outline-text-4" id="text-orgbc489ac">
<p>
Considérez la fonction logique définie par l'expression
  \[
    F =
      (A + B) A^{\prime} C + C^{\prime}(A+B^{\prime}) + A^{\prime}B
      C^{\prime}
    \]
</p>

<ol class="org-ol">
<li>Dessinez le circuit logique correspondant.</li>

<li>Dessinez un circuit équivalent qui n'utilise que des portes
NAND.</li>

<li>Dessinez un circuit équivalent qui n'utilise que des portes
NOR.</li>

<li>Dessinez un circuit équivalent qui ne comporte que 3 niveaux de
portes (incluant les inversions).</li>
</ol>
</div>
</div>

<div id="outline-container-org0eb4427" class="outline-4">
<h4 id="org0eb4427">Question</h4>
<div class="outline-text-4" id="text-org0eb4427">
<p>
Donnez le tableau de vérité pour les fonctions logiques correspondant
  à:
</p>

<ol class="org-ol">
<li>\[f(A, B) = A + B^{\prime}\]</li>

<li>\[f(a, b, c) = a(b+c^{\prime})(b^{\prime}+c)\]</li>
</ol>
</div>
</div>

<div id="outline-container-org36d7243" class="outline-4">
<h4 id="org36d7243">Question</h4>
<div class="outline-text-4" id="text-org36d7243">
<p>
Considérez la fonction logique donnée par l'expression suivante:
</p>

\begin{multline*}
F = A^{\prime} B^{\prime} C^{\prime} D^{\prime} E^{\prime} + {A} B^{\prime} C^{\prime} D^{\prime} E^{\prime} + A^{\prime} B^{\prime} {C} D^{\prime} E^{\prime} + A^{\prime} {B} {C} {D} E^{\prime} \\ + {A} {B} C^{\prime} D^{\prime} {E} + {A} B^{\prime} C^{\prime} D^{\prime} {E} + {A} B^{\prime} D^{\prime} E^{\prime} \\ + {A} B^{\prime} {C} {D} {E} + {A} B^{\prime}  {C} D^{\prime} {E}
\end{multline*}

<p>
Les cas suivants sont facultatifs:
</p>
\begin{displaymath}
A^{\prime} B^{\prime} C^{\prime} D^{\prime} {E} + {A} {B} C^{\prime} {D} {E} +  A^{\prime}B^{\prime} {C} D^{\prime} {E} + {A} {B} {C} D^{\prime} {E}
\end{displaymath}

<ol class="org-ol">
<li>Simplifiez cette expression logique par la méthode de
Quine-McCluskey, en tenant compte des cas facultatifs. Identifiez
clairement les implicants essentiels et non-essentiels.</li>

<li>Dessinez un réseau logique qui réalise votre expression logique
simplifiée en n'utilisant que des portes NAND.</li>
</ol>
</div>
</div>

<div id="outline-container-orgaa62a64" class="outline-4">
<h4 id="orgaa62a64">Question</h4>
<div class="outline-text-4" id="text-orgaa62a64">
<p>
Vous devez concevoir un circuit logique combinatoire qui calcule la
valeur absolue d'un nombre de 4 bits signé en complément à deux. Les
seules valeurs d'entrée possibles sont donc de -7 à 7 inclusivement,
les autres nombres seront considérées comme des cas facultatifs. Vous
disposez de composants programmables pour réaliser cette fonction.
</p>

<ol class="org-ol">
<li>Réalisez votre circuit logique combinatoire en utilisant un PROM à
quatre entrées et deux sorties tel qu'illustré.
Vous devez mettre des croix aux endroits où vous voulez que les
connections soient effectuées (dans la section programmable).</li>
</ol>

<div id="org2c5875a" class="figure">
<p><img src="Modeles_exercices/prom.svg" alt="prom.svg" class="org-svg" />
</p>
</div>

<ol class="org-ol">
<li>Réalisez votre circuit logique combinatoire en utilisant le PAL à
quatre entrées et deux sorties tel qu'illustré.
Vous devez mettre des croix aux endroits où vous voulez que les
connections soient effectuées (dans la section programmable).</li>
</ol>

<div id="org2fcc4ee" class="figure">
<p><img src="Modeles_exercices/pal1.svg" alt="pal1.svg" class="org-svg" />
</p>
</div>
</div>
</div>

<div id="outline-container-org6c74d03" class="outline-4">
<h4 id="org6c74d03">Question</h4>
<div class="outline-text-4" id="text-org6c74d03">
<p>
Considérez le circuit logique ci-dessous. Le signal \(A\) passe de 0 à 1
l'instant 15 ns; le signal \(B\) passe de 1 à 0 à l'instant 15 ns; le
signal \(C\) passe de 1 à 0 à l'instant 60 ns.
<img src="Modeles_exercices/exbloc3e.svg" alt="exbloc3e.svg" class="org-svg" />
</p>

<ol class="org-ol">
<li>Complétez un chronogramme qui montre les traces pour chacun des
signaux d'entrée \(A, B, C\) et de sortie \(T, U, V, X, Y, Z_1,
       Z_2, Z_3, F\), en supposant un temps de propagation de 10 ns
pour toutes les portes. Identifiez clairement sur le
chronogramme les temps de propagation et les éventuels problèmes
(glitchs) occasionnés par les délais.</li>

<li>Identifiez la fonction logique réalisée par ce circuit logique.</li>

<li>Déterminer le délai de propagation (des entrées à la sortie)
maximal pour ce circuit, et précisez le chemin critique.</li>

<li>Si ce circuit doit être utilisé à répétition, de façon périodique,
quelle est la plus courte période qu'on puisse utiliser tout en
étant sûr que le circuit fonctionne correctement.</li>

<li>On désire remplacer ce circuit par un circuit à trois niveaux
logiques. Donnez le schéma d'un circuit en forme somme de produit
qui remplit la même fonction.</li>

<li>Donnez le délai de propagation maximal pour le nouveau circuit
somme de produit.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org49146e7" class="outline-3">
<h3 id="org49146e7">Série 4</h3>
<div class="outline-text-3" id="text-org49146e7">
</div>

<div id="outline-container-org2325143" class="outline-4">
<h4 id="org2325143">Question</h4>
<div class="outline-text-4" id="text-org2325143">
<p>
Construisez un décodeur 5-vers-32 en utilisant quatre décodeurs
  3-vers-8 avec entrée <i>enable</i>.
</p>
</div>
</div>

<div id="outline-container-org2cb8a14" class="outline-4">
<h4 id="org2cb8a14">Question</h4>
<div class="outline-text-4" id="text-org2cb8a14">
<p>
Vous devez concevoir un encodeur à priorité à quatre
  entrées. L'entrée \(D_0\) doit avoir la plus grande priorité et
  l'entrée \(D_3\) doit avoir la plus faible priorité, avec la
  priorité des autres entrées qui suivent le même ordre. Les sorties
  seront \(s_1, s_0\) et \(v\) qui indique la validité des sorties:
  \(v=0\) si toutes les entrées sont à 0; \(v=1\) si au moins une
  entrée est 1.
</p>
</div>
</div>

<div id="outline-container-orgf162989" class="outline-4">
<h4 id="orgf162989">Question</h4>
<div class="outline-text-4" id="text-orgf162989">
<p>
Un circuit séquentiel à deux bascules D, \(A\) et \(B\), comporte
  deux entrées \(x\) et \(y\) et une sortie \(z\). Les équations de
  prochain état sont:
</p>

<p>
\[A_{n+1} = x^\prime y + x A\]
</p>

<p>
\[B_{n+1} = x^\prime B + x A\]
</p>

<p>
L'équation de sortie est 
</p>

<p>
\[z=B\]
</p>

<ol class="org-ol">
<li>Dessinez le schéma logique du circuit</li>

<li>Déterminez le tableau d'états</li>

<li>Dessinez le diagramme d'état</li>
</ol>
</div>
</div>

<div id="outline-container-org9504ac3" class="outline-4">
<h4 id="org9504ac3">Question</h4>
<div class="outline-text-4" id="text-org9504ac3">
<p>
 Considérez le circuit logique suivant:
<img src="Modeles_exercices/exbloc4a.svg" alt="exbloc4a.svg" class="org-svg" />
</p>

<ol class="org-ol">
<li>Quelle est la fonction combinatoire réalisée par la section
logique combinatoire, c'est-à-dire, quelle est la fonction \(S =
         f(A,B)\) ?</li>

<li>Complétez le diagramme temporel de la figure, en supposant un
temps de propagation <b>maximum</b> de 10 ns pour les portes NOR et OU,
et de 40 ns pour les bascules.</li>

<li>Si les temps de maintien \(t_{h}\) et de prépositionnement \(t_{su}\)
sont de 5 ns pour toutes les bascules, quelle est la fréquence
maximale d'horloge utilisable pour que le circuit fonctionne
convenablement? Utilisez un diagramme temporel pour évaluer la
période minimum.</li>
</ol>
</div>
</div>

<div id="outline-container-org18ab466" class="outline-4">
<h4 id="org18ab466">Question</h4>
<div class="outline-text-4" id="text-org18ab466">
<p>
 Analysez le circuit logique suivant:
<img src="Modeles_exercices/exbloc4b.svg" alt="exbloc4b.svg" class="org-svg" />
</p>

<ol class="org-ol">
<li>Analysez le comportement du circuit, en supposant qu'au départ les
entrées sont \(A=0\) et \(B=0\) et la sortie \(S=0\). Vous devez
supposer des changements des valeurs d'entrées et décrire les
changements des sorties, en tenant compte de la mémoire du
circuit.</li>

<li>Identifiez la fonction des entrées \(A\) et \(B\).</li>

<li>Identifiez la fonction du circuit.</li>
</ol>
</div>
</div>

<div id="outline-container-org73b0459" class="outline-4">
<h4 id="org73b0459">Question</h4>
<div class="outline-text-4" id="text-org73b0459">
<p>
Considérez circuit séquentiel décrit par le diagramme d'état suivant:
</p>

<div id="org2f3f379" class="figure">
<p><img src="Modeles_exercices/ex_bloc5b.svg" alt="ex_bloc5b.svg" class="org-svg" />
</p>
</div>
<ol class="org-ol">
<li>En utilisant l'assignation d'états \(a = 00, b = 01, c = 10, d
         = 11\), construisez le tableau d'état pour ce circuit séquentiel.</li>

<li>Concevez le circuit en utilisant des portes standards et des
bascules D.</li>
</ol>
</div>
</div>

<div id="outline-container-org65c4f66" class="outline-4">
<h4 id="org65c4f66">Question</h4>
<div class="outline-text-4" id="text-org65c4f66">
<p>
Vous devez concevoir un circuit logique séquentiel à une entrée et
  une sortie qui identifie les deux séquences d'entrée 0110 et 11111
  appliquées immédiatement après une remise à zéro asynchrone du
  circuit. Donnez le diagramme d'état simplifié pour ce circuit.
</p>
</div>
</div>

<div id="outline-container-org6f95fcd" class="outline-4">
<h4 id="org6f95fcd">Question</h4>
<div class="outline-text-4" id="text-org6f95fcd">
<p>
Vous devez concevoir un circuit logique séquentiel à une entrée et
 une sortie qui identifie les deux séquences d'entrée 0110
 et 11111. Les séquences d'entrée doivent être identifiées à
 n'importe quel moment où elles apparaissent en entrée.
</p>
</div>
</div>

<div id="outline-container-orgaf210f7" class="outline-4">
<h4 id="orgaf210f7">Question</h4>
<div class="outline-text-4" id="text-orgaf210f7">
<p>
Déterminez le diagramme d'état pour un circuit séquentiel synchrone
  avec une entrée \(x\) et une sortie \(z\) qui est utilisé pour
  reconnaître la séquence d'entrée 101. La sortie doit donc être \(z=1\)
  lorsque le dernier 1 de la séquence 101 est identifié. \(z\) est
  ensuite remis à zéro au prochain coup d'horloge. Deux séquences 101
  peuvent se chevaucher. On a par exemple,
  \[
    x  =  010101101
    \]
  \[ z = 000101001
    \]
</p>
</div>
</div>

<div id="outline-container-orga6516ad" class="outline-4">
<h4 id="orga6516ad">Question</h4>
<div class="outline-text-4" id="text-orga6516ad">
<p>
Déterminez le diagramme d'état pour un circuit séquentiel synchrone
  avec une entrée \(x\) et une sortie \(z\) qui est utilisé pour
  reconnaître la séquence d'entrée 101. La sortie doit donc être \(z=1\)
  lorsque le dernier 1 de la séquence 101 est identifié. \(z\) est
  ensuite remis à zéro au prochain coup d'horloge. Les chevauchements de 101 ne sont pas 
  permis. Par exemple,
  \[
    x = 010101101
    \]
  \[
    z = 000100001
    \]
</p>
</div>
</div>

<div id="outline-container-orgcea070a" class="outline-4">
<h4 id="orgcea070a">Question</h4>
<div class="outline-text-4" id="text-orgcea070a">
<p>
Concevez le circuit séquentiel synchrone décrit par le diagramme
  d'état ci-dessous. Vous devez considérer des bascules JK et D et
  choisir la solution la plus simple. Présentez clairement toutes les
  étapes, jusqu'au schéma du circuit correspondant.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">État courant</th>
<th scope="col" class="org-right">Entrée</th>
<th scope="col" class="org-right">Prochain</th>
<th scope="col" class="org-right">Sortie</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">00</td>
<td class="org-right">0</td>
<td class="org-right">01</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">00</td>
<td class="org-right">1</td>
<td class="org-right">11</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">01</td>
<td class="org-right">0</td>
<td class="org-right">10</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">01</td>
<td class="org-right">1</td>
<td class="org-right">00</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-right">0</td>
<td class="org-right">00</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-right">1</td>
<td class="org-right">10</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">00</td>
<td class="org-right">0</td>
<td class="org-right">10</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">00</td>
<td class="org-right">1</td>
<td class="org-right">01</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org826ad1e" class="outline-4">
<h4 id="org826ad1e">Question</h4>
<div class="outline-text-4" id="text-org826ad1e">
<p>
Les deux bascules du circuit suivant sont activées par les
   transitions montantes du signal présent à leur entrée
   d'horloge. 
   <img src="Modeles_exercices/exbloc4c.svg" alt="exbloc4c.svg" class="org-svg" />
</p>

<p>
Tracez le chronogramme pour \(X, X^\prime, Y, S\)
</p>
</div>
</div>

<div id="outline-container-org0c596d3" class="outline-4">
<h4 id="org0c596d3">Question</h4>
<div class="outline-text-4" id="text-org0c596d3">
<p>
Vous devez analyser le circuit séquentiel suivant:
<img src="Modeles_exercices/exbloc4d.svg" alt="exbloc4d.svg" class="org-svg" />
</p>

<ol class="org-ol">
<li>Donnez les équations pour le décodeur de prochain état.</li>

<li>Donnez le tableau d'activation avec état présent, entrée, entrées
des bascules, prochain état, sortie.</li>

<li>Donnez le diagramme d'état correspondant.</li>

<li>tracez le chronogramme de fonctionnement, en
faisant abstraction des délais de propagation.</li>

<li><p>
En sachant que la bascule a les caractéristiques suivantes:
</p>

<ul class="org-ul">
<li>temps de pré-positionnement minimum: 11 ns</li>

<li>temps de maintien minimum: 9 ns</li>

<li>temps de propagation maximum: de Horloge à \(Q\) ou
\(Q^{\prime}\): \(t_{pLH}\) = 15 ns, \(t_{pHL}\) = 13 ns.</li>
</ul>

<p>
et en suppoosant un délai de propagation de 15 ns pour la porte
XOR, déterminez la période minimale et la fréquence
maximale qu'on puisse utiliser tout en étant assuré que le circuit
fonctionne correctement. Donnez les détails de votre raisonnement. 
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orgcf5d6a0" class="outline-4">
<h4 id="orgcf5d6a0">Question</h4>
<div class="outline-text-4" id="text-orgcf5d6a0">
<p>
Vous devez concevoir un circuit logique utilisé dans un système
permettant de trier des données. Le circuit reçoit deux nombres
non-signés de 4 bits, multiplexés en série sur une même entrée. Par
exemple, si les entrées sont 1010 et 1110, le circuit recevra
</p>
<ol class="org-ol">
<li>Le circuit doit acheminer le plus grand des deux nombres à</li>
</ol>
<p>
une sortie (parallèle) appelée PG et le plus petit à une sortie
(parallèle) appelée PP. Vous devez réaliser votre circuit en utilisant
les éléments suivants:
</p>

<ul class="org-ul">
<li>démultiplexeur un-vers-deux</li>

<li>multiplexeur 4 bits deux-vers-un</li>

<li>registre à décalage entrée série/sortie parallèle</li>

<li>comparateur de magnitude: deux entrées parallèles de 4 bits: \(A\) et
\(B\), trois sorties: \(A>B\), \(A=B\), \(A<B\)</li>

<li>registre entrée parallèle/sortie parallèle</li>
</ul>

<p>
Donnez un schéma-bloc de votre circuit en indiquant seulement les
blocs qui traitent les données (pas les blocs qui serviront à contrôler
le circuit).
</p>
</div>
</div>

<div id="outline-container-org384febe" class="outline-4">
<h4 id="org384febe">Question</h4>
<div class="outline-text-4" id="text-org384febe">
<p>
On doit concevoir un système séquentiel avec une entrée \(E\) et une
sortie, et qui génère les séquences de sortie suivantes:
</p>

<ul class="org-ul">
<li>si \(E=0\), séquence de sortie = 1100, périodique</li>

<li>si \(E=1\), séquence de sortie = 1011, périodique</li>
</ul>

<p>
On envisage deux versions du système:
</p>

<dl class="org-dl">
<dt>version 1</dt><dd>si  \(E\) change, la séquence de sortie suit le
changement au vol.</dd>

<dt>version 2</dt><dd>si \(E\) change, la séquence de sortie recommence à
partir du début.</dd>
</dl>

<p>
Par exemple,
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Entrée</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">1</th>
<th scope="col" class="org-right">0</th>
<th scope="col" class="org-right">0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Sortie version 1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">Sortie version 2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Donnez un diagramme d'état pour chacune des deux versions.
</p>
</div>
</div>

<div id="outline-container-org5d85c47" class="outline-4">
<h4 id="org5d85c47">Question</h4>
<div class="outline-text-4" id="text-org5d85c47">
<p>
Considérez le tableau d'état suivant:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">État présent</th>
<th scope="col" class="org-right">Entrée \(A\)</th>
<th scope="col" class="org-left">État suivant</th>
<th scope="col" class="org-right">Sortie \(S\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">a</td>
<td class="org-right">0</td>
<td class="org-left">c</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">a</td>
<td class="org-right">1</td>
<td class="org-left">a</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">0</td>
<td class="org-left">e</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">b</td>
<td class="org-right">1</td>
<td class="org-left">f</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">0</td>
<td class="org-left">b</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">1</td>
<td class="org-left">d</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-right">0</td>
<td class="org-left">a</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-right">1</td>
<td class="org-left">b</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-right">0</td>
<td class="org-left">e</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-right">1</td>
<td class="org-left">f</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">f</td>
<td class="org-right">0</td>
<td class="org-left">c</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">f</td>
<td class="org-right">1</td>
<td class="org-left">f</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>
<p>
correspondant à un circuit séquentiel synchrone.
</p>

<ol class="org-ol">
<li>Simplifiez ce tableau d'état en identifiant les états
équivalents, en utilisant la méthode du tableau d'implication.</li>

<li>Donnez le diagramme d'état simplifié correspondant au tableau
d'état simplifié. Nommez les états simplifiés qui restent a,
b, c, &hellip;</li>

<li>Assignez des codes aux états, en commençant avec la
représentation binaire de 0 pour a, de 1 pour b, etc.</li>

<li>Donnez les diagrammes de Karnaugh pour le décodeur de prochain
état en supposant des bascules JK, et les fonctions simplifiées
correspondantes.</li>

<li>Donnez le diagramme de Karnaugh pour le décodeur de sortie.</li>

<li>Dessinez le schéma du circuit séquentiel obtenu.</li>
</ol>
</div>
</div>

<div id="outline-container-orga15ef85" class="outline-4">
<h4 id="orga15ef85">Question</h4>
<div class="outline-text-4" id="text-orga15ef85">
<p>
Considérez le circuit séquentiel synchrone ci-dessous.
<img src="Modeles_exercices/exbloc4e.svg" alt="exbloc4e.svg" class="org-svg" />
</p>

<p>
Déterminez la vitesse d'horloge maximale en considérant les
caractéristiques suivantes:
</p>

<ul class="org-ul">
<li>Portes: temps de propagation maximum: 10 ns.</li>

<li>Bascules: temps de prépositionnement minimum: 12 ns.</li>

<li>Bascules: temps de maintien minimum: 15 ns.</li>

<li>Bascules: temps de propagation maximum: de H à \(Q\) ou
\(Q^{\prime}\): \(t_{pLH}\) = 25 ns, \(t_{pHL}\) = 20 ns.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4ce4b64" class="outline-3">
<h3 id="org4ce4b64">Série 5</h3>
<div class="outline-text-3" id="text-org4ce4b64">
</div>

<div id="outline-container-orgb66fe0e" class="outline-4">
<h4 id="orgb66fe0e">Question</h4>
<div class="outline-text-4" id="text-orgb66fe0e">
<p>
Faire le diagramme d'état d'un circuit séquentiel synchrone qui génère
à sa sortie un 1 lorsqu'il détecte à son entrée la séquence 0110 ou la
séquence 0101.
</p>
</div>
</div>

<div id="outline-container-orgf6474bd" class="outline-4">
<h4 id="orgf6474bd">Question</h4>
<div class="outline-text-4" id="text-orgf6474bd">
<p>
Un circuit séquentiel synchrone est construit à partir de trois
   bascules, \(A\), \(B\), et \(C\). Il comporte une entrée \(x\) et
   une sortie \(y\). Son diagramme d'état est donné ci-dessous. 
<img src="Modeles_exercices/ex_bloc5.svg" alt="ex_bloc5.svg" class="org-svg" />
</p>

<p>
Vous devez concevoir ce circuit en considérant les états inutilisés
comme des cas facultatifs. Le circuit final doit être analysé pour
déterminer si, à partir des états inutilisés, le système revient vers
son fonctionnement normal.
</p>
<ol class="org-ol">
<li>Conception avec des bascules D</li>
<li>Conception avec des bascules JK</li>
</ol>
</div>
</div>

<div id="outline-container-orgf05ec18" class="outline-4">
<h4 id="orgf05ec18">Question</h4>
<div class="outline-text-4" id="text-orgf05ec18">
<p>
Faire le diagramme d'état d'un compteur synchrone qui produit les
  séquences d'états suivants, selon la valeur de l'entrée \(x\)
</p>

<ul class="org-ul">
<li>\(x=0\), séquence: 0, 6, 2, 1, 4, 0, 6, 2, 1, 4, &hellip;</li>
<li>\(x=1\), séquence: 0, 6, 5, 7, 2, 1, 0, 6, 5, 7, 2, 1, &hellip;</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Notes de bas de page: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Pour simplifier, dans le contexte, on appellera ici ces cinq
lettres des <i>chiffres</i> de la notation hexadécimale.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Certains postulats viennent en paires; nous les distinguons ici au
moyen d'étiquettes &spades; ou &hearts;.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Auteur: Guy Bégin</p>
<p class="date">Created: 2023-07-17 Mon 10:33</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
